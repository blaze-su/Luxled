;
$(document).ready(function() {
    // $('.mainContent').css('min-height', ($(window).outerHeight() - $(".footer").outerHeight()) - $(".header").outerHeight());
    catalogFilters();
    headerMenuItemHover();
    catalogCheckBox();
    catalogAccordion();
    catalogSorting();
    productPhotoGalery();
    productMoreTableRowColor();
    productMoreTab();
    orderForm();
    footerMenu();
    $('img').on('mousedown', function(e) { e.preventDefault(); });
    hScroll($('.header__catalogItem'), $('.header__catalog'));
    hScroll($('.portfolio__item'), $('.portfolio__itemBox'));
    hScroll($('.productMore__galeryPictureOtherCase '), $('.productMore__galeryPictureOtherBox'));

    mediaCenter(5, $('.whyWe__belief'), $('.whyWe__beliefs'), $('.totalWidth'));
    mediaCenter(3, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection'));
    mediaCenter(4, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection--full'));

    if ($(window).outerWidth() <= 1023) {
        mediaCenter(8, $('.footer__paymentLink'), $('.footer__paymentLinks'));
    }
    var mySwiper = new Swiper('.swiper2', {
        pagination: '.swiper-pagination',
        paginationClickable: true,
        paginationElement: 'li'
    });
    // catalogFilterBox();
});

$(window).resize(function() {
    mediaCenter(5, $('.whyWe__belief'), $('.whyWe__beliefs'), $('.totalWidth'));
    mediaCenter(3, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection'));
    mediaCenter(4, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection--full'));
    if ($(window).outerWidth() <= 1023) {
        mediaCenter(8, $('.footer__paymentLink'), $('.footer__paymentLinks'));
    }
    productMoreTableRowColor();
});

// var catalogFilterBox = function() {
//     $('.catalog__optionsItem').on('click', function() {
//         var top = $(this).offset().top - $('.catalog__optionItems').offset().top;
//         $('.catalog__optionFindProductBox').addClass('catalog__optionFindProductBox--active').css('top', top);
//     });
// };

var mediaCenter = function(count, elem, box, boxControlSize) {
    var size;
    if (elem.length < count) {
        for (var i = 1; i <= elem.length + 1; i++) {
            if (boxControlSize) {
                size = boxControlSize.width();
            } else {
                size = box.width();
            }
            if (i == elem.length + 1) {
                if (i == 1) {
                    box.css('max-width', elem.outerWidth(true) * i);
                } else {
                    box.css('max-width', elem.outerWidth(true) * (i - 1));
                }
                break
            }
            if (size < elem.outerWidth(true) * i) {
                if (i == 1) {
                    box.css('max-width', elem.outerWidth(true) * i);
                } else {
                    box.css('max-width', elem.outerWidth(true) * (i - 1));
                }
                break
            }
        }
    } else {
        for (var i = 1; i <= count + 1; i++) {
            if (boxControlSize) {
                size = boxControlSize.width();
            } else {
                size = box.width();
            }
            if (size < elem.outerWidth(true) * i) {
                if (i == 1) {
                    box.css('max-width', elem.outerWidth(true) * i);
                } else {
                    box.css('max-width', elem.outerWidth(true) * (i - 1));
                }
                break
            }
        }
    }
};

var hScroll = function(el, elB) {
    el.on('mousedown', function(e) {
        e.preventDefault();
        var x = e.pageX - $(this).offset().left;
        $(this).on('mousemove', function(e) {
            $(this).on('click', function(e) {
                e.preventDefault();
            });
            var xx = e.pageX - $(this).offset().left;
            if (xx < x) {
                var curTr = elB.scrollLeft() + (x - xx);
                elB.scrollLeft(curTr);
            }
            if (xx > x) {
                var curTr = elB.scrollLeft() - (xx - x);
                elB.scrollLeft(curTr);
            }
        });
        elB.on('mouseup', function() {
            el.unbind('mousemove');
            setTimeout(function() {
                el.unbind('click');
            }, 1);
        });
        elB.on('mouseleave', function() {
            el.unbind('mousemove');
        });
    });
};

var productPhotoGalery = function() {
    var firstSrc = $('.productMore__galeryPictureOther').eq(0).attr('src');
    $('.productMore__galeryPictureMain').attr('src', firstSrc);
    $('.productMore__galeryPictureOtherCase').eq(0).addClass('productMore__galeryPictureOtherCase--active');
    $('.productMore__galeryPictureOther').on('click', function() {

        var needSrc = $(this).attr('src');
        $('.productMore__galeryPictureMain').attr('src', needSrc);

        $('.productMore__galeryPictureOtherCase--active').removeClass('productMore__galeryPictureOtherCase--active');

        $(this).closest('.productMore__galeryPictureOtherCase').addClass('productMore__galeryPictureOtherCase--active');

    });
};

var productMoreTableRowColor = function() {
    var rows = $('.productMore__infoCharacteristicsTableRow');
    var firstColor = '#f4f4f4';
    var secondColor = '#ffffff';
    var transparent = 'transparent';
    if ($(window).outerWidth() >= 600) {
        for (var i = 0; i < rows.length; i++) {
            if (i % 2 == 0) {
                rows.eq(i).css('background-color', firstColor);
            } else {
                rows.eq(i).css('background-color', secondColor);
            }
        }
    } else {
        rows.css('background-color', transparent);
        for (var i = 0; i < rows.length; i++) {
            if (i === 0) {
                rows.eq(i).find('.productMore__infoCharacteristicsTableColl').css('background-color', firstColor);
            } else {
                rows.eq(i).find('.productMore__infoCharacteristicsTableColl').eq(0).css('background-color', secondColor);
                rows.eq(i).find('.productMore__infoCharacteristicsTableColl').eq(1).css('background-color', firstColor);
            }
        }
    }
};

var productMoreTab = function() {
    var tabs = $('.productMore__infoTab');
    var links = $('.productMore__infoMenuLink');

    links.on('click', function(e) {
        e.preventDefault();
        $('.productMore__infoMenuLink--active').removeClass('productMore__infoMenuLink--active')
        $(this).addClass('productMore__infoMenuLink--active');
        var path = $(this).attr('href');
        tabs.each(function(index) {
            if (tabs.eq(index).attr('id') === path) {
                tabs.css('display', 'none');
                $(this).css('display', 'block');
            }
        });
    });

    tabs.eq(0).css('display', 'block');
    var tabId0 = tabs.eq(0).attr('id');

    $('.productMore__infoMenuLink').each(function(index) {
        if (links.eq(index).attr('href') === tabId0) {
            $(this).addClass('productMore__infoMenuLink--active');
        }
    });
};

var catalogCheckBox = function() {
    $('.catalog__optionsItem').on('click', function() {
        if ($(this).find('input').prop('checked') == true) {
            $(this).addClass('catalog__optionsItem--checked');
        } else {
            $(this).removeClass('catalog__optionsItem--checked');
        }
    });
};

var catalogAccordion = function() {
    $('.catalog__option').on('click', function() {
        $(this).find('.accordionIcon').toggleClass('accordionIcon--active');
        $(this).find('.catalog__optionsItemList').toggleClass('catalog__optionsItemList--active');
    });
};

var catalogSorting = function() {
    $('.catalog__sortingTitleBox').on('click', function() {
        $(this).find('.accordionIcon').toggleClass('accordionIcon--active');
        $(this).next().toggleClass('catalog__sortingList--active');
    });
};

var orderForm = function() {
    var phone = $('.orders__form').find('input[name="phone"]');
    phone.mask("+7(999) 999-99-99");

    var form = $('.orders__form');
    var titleError = $('.orders__formErrorTitle');
    var visionTitleError = titleError.css('display');

    if (visionTitleError === 'block') {
        form.css('margin-top', '55px');
    }

    var inputRequire = $('.orders__formItem--require > input');

};

var headerMenuItemHover = function() {
    // $('body').on('click', function() {
    //     if ($('.header__menuList').hasClass('header__menuList--full')) {
    //         $('.header__menuList').removeClass('header__menuList--full');
    //     }
    // });
    $('.header__catalogBtn').on('click', function() {
        if ($('.header__catalogBtnText').css('display') === 'none') {
            $('.header__menuList').toggleClass('header__menuList--full');
        } else {
            $('.header__menuList').toggleClass('header__menuList--active');
        }
    });
    $('.header__menuItem').on('mouseover', function() {
        if ($('.header__menuList').hasClass('header__menuList--active')) {
            $(this).find('.header__menuItemAfter').css('display', 'block');
            var index = $(this).index();
            var top;
            if (index != 0) {
                top = (-50 * index) + 49;
            } else {
                top = -1;
            }
            $(this).find('.header__subMenu').css({
                'display': 'flex',
                'top': top
            });
        }
    });
    $('.header__menuItem').on('mouseout', function() {
        $(this).find('.header__menuItemAfter').css('display', 'none');
        $(this).find('.header__subMenu').css('display', 'none');
    });
};

var catalogFilters = function() {
    $('.filtersBtn').on('click', function() {
        $('.catalog__options').toggleClass('catalog__options--active');
    });
};

var footerMenu = function() {
    $('.footer__menuTitle').on('click', function() {
        var i = $('.footer__menu--active').index();
        var j = $(this).closest('.footer__menu').index();
        if (j === i) {
            $(this).closest('.footer__menu').toggleClass('footer__menu--active');
        } else {
            $('.footer__menu--active').removeClass('footer__menu--active');
            $(this).closest('.footer__menu').toggleClass('footer__menu--active');
        }

    });
};

/**
 * Swiper 3.4.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * 
 * http://www.idangero.us/swiper/
 * 
 * Copyright 2017, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: March 10, 2017
 */
! function() {
    "use strict";
    var e, a = function(t, s) {
        function r(e) { return Math.floor(e) }

        function i() {
            var e = x.params.autoplay,
                a = x.slides.eq(x.activeIndex);
            a.attr("data-swiper-autoplay") && (e = a.attr("data-swiper-autoplay") || x.params.autoplay), x.autoplayTimeoutId = setTimeout(function() { x.params.loop ? (x.fixLoop(), x._slideNext(), x.emit("onAutoplay", x)) : x.isEnd ? s.autoplayStopOnLast ? x.stopAutoplay() : (x._slideTo(0), x.emit("onAutoplay", x)) : (x._slideNext(), x.emit("onAutoplay", x)) }, e)
        }

        function n(a, t) {
            var s = e(a.target);
            if (!s.is(t))
                if ("string" == typeof t) s = s.parents(t);
                else if (t.nodeType) { var r; return s.parents().each(function(e, a) { a === t && (r = t) }), r ? t : void 0 }
            if (0 !== s.length) return s[0]
        }

        function o(e, a) {
            a = a || {};
            var t = window.MutationObserver || window.WebkitMutationObserver,
                s = new t(function(e) { e.forEach(function(e) { x.onResize(!0), x.emit("onObserverUpdate", x, e) }) });
            s.observe(e, { attributes: void 0 === a.attributes || a.attributes, childList: void 0 === a.childList || a.childList, characterData: void 0 === a.characterData || a.characterData }), x.observers.push(s)
        }

        function l(e) {
            e.originalEvent && (e = e.originalEvent);
            var a = e.keyCode || e.charCode;
            if (!x.params.allowSwipeToNext && (x.isHorizontal() && 39 === a || !x.isHorizontal() && 40 === a)) return !1;
            if (!x.params.allowSwipeToPrev && (x.isHorizontal() && 37 === a || !x.isHorizontal() && 38 === a)) return !1;
            if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || document.activeElement && document.activeElement.nodeName && ("input" === document.activeElement.nodeName.toLowerCase() || "textarea" === document.activeElement.nodeName.toLowerCase()))) {
                if (37 === a || 39 === a || 38 === a || 40 === a) {
                    var t = !1;
                    if (x.container.parents("." + x.params.slideClass).length > 0 && 0 === x.container.parents("." + x.params.slideActiveClass).length) return;
                    var s = { left: window.pageXOffset, top: window.pageYOffset },
                        r = window.innerWidth,
                        i = window.innerHeight,
                        n = x.container.offset();
                    x.rtl && (n.left = n.left - x.container[0].scrollLeft);
                    for (var o = [
                            [n.left, n.top],
                            [n.left + x.width, n.top],
                            [n.left, n.top + x.height],
                            [n.left + x.width, n.top + x.height]
                        ], l = 0; l < o.length; l++) {
                        var p = o[l];
                        p[0] >= s.left && p[0] <= s.left + r && p[1] >= s.top && p[1] <= s.top + i && (t = !0)
                    }
                    if (!t) return
                }
                x.isHorizontal() ? (37 !== a && 39 !== a || (e.preventDefault ? e.preventDefault() : e.returnValue = !1), (39 === a && !x.rtl || 37 === a && x.rtl) && x.slideNext(), (37 === a && !x.rtl || 39 === a && x.rtl) && x.slidePrev()) : (38 !== a && 40 !== a || (e.preventDefault ? e.preventDefault() : e.returnValue = !1), 40 === a && x.slideNext(), 38 === a && x.slidePrev()), x.emit("onKeyPress", x, a)
            }
        }

        function p(e) {
            var a = 0,
                t = 0,
                s = 0,
                r = 0;
            return "detail" in e && (t = e.detail), "wheelDelta" in e && (t = -e.wheelDelta / 120), "wheelDeltaY" in e && (t = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (a = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (a = t, t = 0), s = 10 * a, r = 10 * t, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (s = e.deltaX), (s || r) && e.deltaMode && (1 === e.deltaMode ? (s *= 40, r *= 40) : (s *= 800, r *= 800)), s && !a && (a = s < 1 ? -1 : 1), r && !t && (t = r < 1 ? -1 : 1), { spinX: a, spinY: t, pixelX: s, pixelY: r }
        }

        function d(e) {
            e.originalEvent && (e = e.originalEvent);
            var a = 0,
                t = x.rtl ? -1 : 1,
                s = p(e);
            if (x.params.mousewheelForceToAxis)
                if (x.isHorizontal()) {
                    if (!(Math.abs(s.pixelX) > Math.abs(s.pixelY))) return;
                    a = s.pixelX * t
                } else {
                    if (!(Math.abs(s.pixelY) > Math.abs(s.pixelX))) return;
                    a = s.pixelY
                }
            else a = Math.abs(s.pixelX) > Math.abs(s.pixelY) ? -s.pixelX * t : -s.pixelY;
            if (0 !== a) {
                if (x.params.mousewheelInvert && (a = -a), x.params.freeMode) {
                    var r = x.getWrapperTranslate() + a * x.params.mousewheelSensitivity,
                        i = x.isBeginning,
                        n = x.isEnd;
                    if (r >= x.minTranslate() && (r = x.minTranslate()), r <= x.maxTranslate() && (r = x.maxTranslate()), x.setWrapperTransition(0), x.setWrapperTranslate(r), x.updateProgress(), x.updateActiveIndex(), (!i && x.isBeginning || !n && x.isEnd) && x.updateClasses(), x.params.freeModeSticky ? (clearTimeout(x.mousewheel.timeout), x.mousewheel.timeout = setTimeout(function() { x.slideReset() }, 300)) : x.params.lazyLoading && x.lazy && x.lazy.load(), x.emit("onScroll", x, e), x.params.autoplay && x.params.autoplayDisableOnInteraction && x.stopAutoplay(), 0 === r || r === x.maxTranslate()) return
                } else {
                    if ((new window.Date).getTime() - x.mousewheel.lastScrollTime > 60)
                        if (a < 0)
                            if (x.isEnd && !x.params.loop || x.animating) { if (x.params.mousewheelReleaseOnEdges) return !0 } else x.slideNext(), x.emit("onScroll", x, e);
                    else if (x.isBeginning && !x.params.loop || x.animating) { if (x.params.mousewheelReleaseOnEdges) return !0 } else x.slidePrev(), x.emit("onScroll", x, e);
                    x.mousewheel.lastScrollTime = (new window.Date).getTime()
                }
                return e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1
            }
        }

        function m(a, t) {
            a = e(a);
            var s, r, i, n = x.rtl ? -1 : 1;
            s = a.attr("data-swiper-parallax") || "0", r = a.attr("data-swiper-parallax-x"), i = a.attr("data-swiper-parallax-y"), r || i ? (r = r || "0", i = i || "0") : x.isHorizontal() ? (r = s, i = "0") : (i = s, r = "0"), r = r.indexOf("%") >= 0 ? parseInt(r, 10) * t * n + "%" : r * t * n + "px", i = i.indexOf("%") >= 0 ? parseInt(i, 10) * t + "%" : i * t + "px", a.transform("translate3d(" + r + ", " + i + ",0px)")
        }

        function u(e) { return 0 !== e.indexOf("on") && (e = e[0] !== e[0].toUpperCase() ? "on" + e[0].toUpperCase() + e.substring(1) : "on" + e), e }
        if (!(this instanceof a)) return new a(t, s);
        var c = { direction: "horizontal", touchEventsTarget: "container", initialSlide: 0, speed: 300, autoplay: !1, autoplayDisableOnInteraction: !0, autoplayStopOnLast: !1, iOSEdgeSwipeDetection: !1, iOSEdgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: .02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", coverflow: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0 }, flip: { slideShadows: !0, limitRotation: !0 }, cube: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 }, fade: { crossFade: !1 }, parallax: !1, zoom: !1, zoomMax: 3, zoomMin: 1, zoomToggle: !0, scrollbar: null, scrollbarHide: !0, scrollbarDraggable: !1, scrollbarSnapOnRelease: !1, keyboardControl: !1, mousewheelControl: !1, mousewheelReleaseOnEdges: !1, mousewheelInvert: !1, mousewheelForceToAxis: !1, mousewheelSensitivity: 1, mousewheelEventsTarged: "container", hashnav: !1, hashnavWatchState: !1, history: !1, replaceState: !1, breakpoints: void 0, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: "column", slidesPerGroup: 1, centeredSlides: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, onlyExternal: !1, threshold: 0, touchMoveStopPropagation: !0, touchReleaseOnEdges: !1, uniqueNavElements: !0, pagination: null, paginationElement: "span", paginationClickable: !1, paginationHide: !1, paginationBulletRender: null, paginationProgressRender: null, paginationFractionRender: null, paginationCustomRender: null, paginationType: "bullets", resistance: !0, resistanceRatio: .85, nextButton: null, prevButton: null, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, lazyLoading: !1, lazyLoadingInPrevNext: !1, lazyLoadingInPrevNextAmount: 1, lazyLoadingOnTransitionStart: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, control: void 0, controlInverse: !1, controlBy: "slide", normalizeSlideIndex: !0, allowSwipeToPrev: !0, allowSwipeToNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", passiveListeners: !0, containerModifierClass: "swiper-container-", slideClass: "swiper-slide", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", bulletClass: "swiper-pagination-bullet", bulletActiveClass: "swiper-pagination-bullet-active", buttonDisabledClass: "swiper-button-disabled", paginationCurrentClass: "swiper-pagination-current", paginationTotalClass: "swiper-pagination-total", paginationHiddenClass: "swiper-pagination-hidden", paginationProgressbarClass: "swiper-pagination-progressbar", paginationClickableClass: "swiper-pagination-clickable", paginationModifierClass: "swiper-pagination-", lazyLoadingClass: "swiper-lazy", lazyStatusLoadingClass: "swiper-lazy-loading", lazyStatusLoadedClass: "swiper-lazy-loaded", lazyPreloaderClass: "swiper-lazy-preloader", notificationClass: "swiper-notification", preloaderClass: "preloader", zoomContainerClass: "swiper-zoom-container", observer: !1, observeParents: !1, a11y: !1, prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", runCallbacksOnInit: !0 },
            g = s && s.virtualTranslate;
        s = s || {};
        var h = {};
        for (var v in s)
            if ("object" != typeof s[v] || null === s[v] || (s[v].nodeType || s[v] === window || s[v] === document || "undefined" != typeof Dom7 && s[v] instanceof Dom7 || "undefined" != typeof jQuery && s[v] instanceof jQuery)) h[v] = s[v];
            else { h[v] = {}; for (var f in s[v]) h[v][f] = s[v][f] }
        for (var w in c)
            if (void 0 === s[w]) s[w] = c[w];
            else if ("object" == typeof s[w])
            for (var y in c[w]) void 0 === s[w][y] && (s[w][y] = c[w][y]);
        var x = this;
        if (x.params = s, x.originalParams = h, x.classNames = [], void 0 !== e && "undefined" != typeof Dom7 && (e = Dom7), (void 0 !== e || (e = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7)) && (x.$ = e, x.currentBreakpoint = void 0, x.getActiveBreakpoint = function() {
                if (!x.params.breakpoints) return !1;
                var e, a = !1,
                    t = [];
                for (e in x.params.breakpoints) x.params.breakpoints.hasOwnProperty(e) && t.push(e);
                t.sort(function(e, a) { return parseInt(e, 10) > parseInt(a, 10) });
                for (var s = 0; s < t.length; s++)(e = t[s]) >= window.innerWidth && !a && (a = e);
                return a || "max"
            }, x.setBreakpoint = function() {
                var e = x.getActiveBreakpoint();
                if (e && x.currentBreakpoint !== e) {
                    var a = e in x.params.breakpoints ? x.params.breakpoints[e] : x.originalParams,
                        t = x.params.loop && a.slidesPerView !== x.params.slidesPerView;
                    for (var s in a) x.params[s] = a[s];
                    x.currentBreakpoint = e, t && x.destroyLoop && x.reLoop(!0)
                }
            }, x.params.breakpoints && x.setBreakpoint(), x.container = e(t), 0 !== x.container.length)) {
            if (x.container.length > 1) { var T = []; return x.container.each(function() { T.push(new a(this, s)) }), T }
            x.container[0].swiper = x, x.container.data("swiper", x), x.classNames.push(x.params.containerModifierClass + x.params.direction), x.params.freeMode && x.classNames.push(x.params.containerModifierClass + "free-mode"), x.support.flexbox || (x.classNames.push(x.params.containerModifierClass + "no-flexbox"), x.params.slidesPerColumn = 1), x.params.autoHeight && x.classNames.push(x.params.containerModifierClass + "autoheight"), (x.params.parallax || x.params.watchSlidesVisibility) && (x.params.watchSlidesProgress = !0), x.params.touchReleaseOnEdges && (x.params.resistanceRatio = 0), ["cube", "coverflow", "flip"].indexOf(x.params.effect) >= 0 && (x.support.transforms3d ? (x.params.watchSlidesProgress = !0, x.classNames.push(x.params.containerModifierClass + "3d")) : x.params.effect = "slide"), "slide" !== x.params.effect && x.classNames.push(x.params.containerModifierClass + x.params.effect), "cube" === x.params.effect && (x.params.resistanceRatio = 0, x.params.slidesPerView = 1, x.params.slidesPerColumn = 1, x.params.slidesPerGroup = 1, x.params.centeredSlides = !1, x.params.spaceBetween = 0, x.params.virtualTranslate = !0), "fade" !== x.params.effect && "flip" !== x.params.effect || (x.params.slidesPerView = 1, x.params.slidesPerColumn = 1, x.params.slidesPerGroup = 1, x.params.watchSlidesProgress = !0, x.params.spaceBetween = 0, void 0 === g && (x.params.virtualTranslate = !0)), x.params.grabCursor && x.support.touch && (x.params.grabCursor = !1), x.wrapper = x.container.children("." + x.params.wrapperClass), x.params.pagination && (x.paginationContainer = e(x.params.pagination), x.params.uniqueNavElements && "string" == typeof x.params.pagination && x.paginationContainer.length > 1 && 1 === x.container.find(x.params.pagination).length && (x.paginationContainer = x.container.find(x.params.pagination)), "bullets" === x.params.paginationType && x.params.paginationClickable ? x.paginationContainer.addClass(x.params.paginationModifierClass + "clickable") : x.params.paginationClickable = !1, x.paginationContainer.addClass(x.params.paginationModifierClass + x.params.paginationType)), (x.params.nextButton || x.params.prevButton) && (x.params.nextButton && (x.nextButton = e(x.params.nextButton), x.params.uniqueNavElements && "string" == typeof x.params.nextButton && x.nextButton.length > 1 && 1 === x.container.find(x.params.nextButton).length && (x.nextButton = x.container.find(x.params.nextButton))), x.params.prevButton && (x.prevButton = e(x.params.prevButton), x.params.uniqueNavElements && "string" == typeof x.params.prevButton && x.prevButton.length > 1 && 1 === x.container.find(x.params.prevButton).length && (x.prevButton = x.container.find(x.params.prevButton)))), x.isHorizontal = function() { return "horizontal" === x.params.direction }, x.rtl = x.isHorizontal() && ("rtl" === x.container[0].dir.toLowerCase() || "rtl" === x.container.css("direction")), x.rtl && x.classNames.push(x.params.containerModifierClass + "rtl"), x.rtl && (x.wrongRTL = "-webkit-box" === x.wrapper.css("display")), x.params.slidesPerColumn > 1 && x.classNames.push(x.params.containerModifierClass + "multirow"), x.device.android && x.classNames.push(x.params.containerModifierClass + "android"), x.container.addClass(x.classNames.join(" ")), x.translate = 0, x.progress = 0, x.velocity = 0, x.lockSwipeToNext = function() { x.params.allowSwipeToNext = !1, x.params.allowSwipeToPrev === !1 && x.params.grabCursor && x.unsetGrabCursor() }, x.lockSwipeToPrev = function() { x.params.allowSwipeToPrev = !1, x.params.allowSwipeToNext === !1 && x.params.grabCursor && x.unsetGrabCursor() }, x.lockSwipes = function() { x.params.allowSwipeToNext = x.params.allowSwipeToPrev = !1, x.params.grabCursor && x.unsetGrabCursor() }, x.unlockSwipeToNext = function() { x.params.allowSwipeToNext = !0, x.params.allowSwipeToPrev === !0 && x.params.grabCursor && x.setGrabCursor() }, x.unlockSwipeToPrev = function() { x.params.allowSwipeToPrev = !0, x.params.allowSwipeToNext === !0 && x.params.grabCursor && x.setGrabCursor() }, x.unlockSwipes = function() { x.params.allowSwipeToNext = x.params.allowSwipeToPrev = !0, x.params.grabCursor && x.setGrabCursor() }, x.setGrabCursor = function(e) { x.container[0].style.cursor = "move", x.container[0].style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", x.container[0].style.cursor = e ? "-moz-grabbin" : "-moz-grab", x.container[0].style.cursor = e ? "grabbing" : "grab" }, x.unsetGrabCursor = function() { x.container[0].style.cursor = "" }, x.params.grabCursor && x.setGrabCursor(), x.imagesToLoad = [], x.imagesLoaded = 0, x.loadImage = function(e, a, t, s, r, i) {
                function n() { i && i() }
                var o;
                e.complete && r ? n() : a ? (o = new window.Image, o.onload = n, o.onerror = n, s && (o.sizes = s), t && (o.srcset = t), a && (o.src = a)) : n()
            }, x.preloadImages = function() {
                function e() { void 0 !== x && null !== x && x && (void 0 !== x.imagesLoaded && x.imagesLoaded++, x.imagesLoaded === x.imagesToLoad.length && (x.params.updateOnImagesReady && x.update(), x.emit("onImagesReady", x))) }
                x.imagesToLoad = x.container.find("img");
                for (var a = 0; a < x.imagesToLoad.length; a++) x.loadImage(x.imagesToLoad[a], x.imagesToLoad[a].currentSrc || x.imagesToLoad[a].getAttribute("src"), x.imagesToLoad[a].srcset || x.imagesToLoad[a].getAttribute("srcset"), x.imagesToLoad[a].sizes || x.imagesToLoad[a].getAttribute("sizes"), !0, e)
            }, x.autoplayTimeoutId = void 0, x.autoplaying = !1, x.autoplayPaused = !1, x.startAutoplay = function() { return void 0 === x.autoplayTimeoutId && (!!x.params.autoplay && (!x.autoplaying && (x.autoplaying = !0, x.emit("onAutoplayStart", x), void i()))) }, x.stopAutoplay = function(e) { x.autoplayTimeoutId && (x.autoplayTimeoutId && clearTimeout(x.autoplayTimeoutId), x.autoplaying = !1, x.autoplayTimeoutId = void 0, x.emit("onAutoplayStop", x)) }, x.pauseAutoplay = function(e) { x.autoplayPaused || (x.autoplayTimeoutId && clearTimeout(x.autoplayTimeoutId), x.autoplayPaused = !0, 0 === e ? (x.autoplayPaused = !1, i()) : x.wrapper.transitionEnd(function() { x && (x.autoplayPaused = !1, x.autoplaying ? i() : x.stopAutoplay()) })) }, x.minTranslate = function() { return -x.snapGrid[0] }, x.maxTranslate = function() { return -x.snapGrid[x.snapGrid.length - 1] }, x.updateAutoHeight = function() {
                var e, a = [],
                    t = 0;
                if ("auto" !== x.params.slidesPerView && x.params.slidesPerView > 1)
                    for (e = 0; e < Math.ceil(x.params.slidesPerView); e++) {
                        var s = x.activeIndex + e;
                        if (s > x.slides.length) break;
                        a.push(x.slides.eq(s)[0])
                    } else a.push(x.slides.eq(x.activeIndex)[0]);
                for (e = 0; e < a.length; e++)
                    if (void 0 !== a[e]) {
                        var r = a[e].offsetHeight;
                        t = r > t ? r : t
                    }
                t && x.wrapper.css("height", t + "px")
            }, x.updateContainerSize = function() {
                var e, a;
                e = void 0 !== x.params.width ? x.params.width : x.container[0].clientWidth, a = void 0 !== x.params.height ? x.params.height : x.container[0].clientHeight, 0 === e && x.isHorizontal() || 0 === a && !x.isHorizontal() || (e = e - parseInt(x.container.css("padding-left"), 10) - parseInt(x.container.css("padding-right"), 10), a = a - parseInt(x.container.css("padding-top"), 10) - parseInt(x.container.css("padding-bottom"), 10), x.width = e, x.height = a, x.size = x.isHorizontal() ? x.width : x.height)
            }, x.updateSlidesSize = function() {
                x.slides = x.wrapper.children("." + x.params.slideClass), x.snapGrid = [], x.slidesGrid = [], x.slidesSizesGrid = [];
                var e, a = x.params.spaceBetween,
                    t = -x.params.slidesOffsetBefore,
                    s = 0,
                    i = 0;
                if (void 0 !== x.size) {
                    "string" == typeof a && a.indexOf("%") >= 0 && (a = parseFloat(a.replace("%", "")) / 100 * x.size), x.virtualSize = -a, x.rtl ? x.slides.css({ marginLeft: "", marginTop: "" }) : x.slides.css({ marginRight: "", marginBottom: "" });
                    var n;
                    x.params.slidesPerColumn > 1 && (n = Math.floor(x.slides.length / x.params.slidesPerColumn) === x.slides.length / x.params.slidesPerColumn ? x.slides.length : Math.ceil(x.slides.length / x.params.slidesPerColumn) * x.params.slidesPerColumn, "auto" !== x.params.slidesPerView && "row" === x.params.slidesPerColumnFill && (n = Math.max(n, x.params.slidesPerView * x.params.slidesPerColumn)));
                    var o, l = x.params.slidesPerColumn,
                        p = n / l,
                        d = p - (x.params.slidesPerColumn * p - x.slides.length);
                    for (e = 0; e < x.slides.length; e++) { o = 0; var m = x.slides.eq(e); if (x.params.slidesPerColumn > 1) { var u, c, g; "column" === x.params.slidesPerColumnFill ? (c = Math.floor(e / l), g = e - c * l, (c > d || c === d && g === l - 1) && ++g >= l && (g = 0, c++), u = c + g * n / l, m.css({ "-webkit-box-ordinal-group": u, "-moz-box-ordinal-group": u, "-ms-flex-order": u, "-webkit-order": u, order: u })) : (g = Math.floor(e / p), c = e - g * p), m.css("margin-" + (x.isHorizontal() ? "top" : "left"), 0 !== g && x.params.spaceBetween && x.params.spaceBetween + "px").attr("data-swiper-column", c).attr("data-swiper-row", g) } "none" !== m.css("display") && ("auto" === x.params.slidesPerView ? (o = x.isHorizontal() ? m.outerWidth(!0) : m.outerHeight(!0), x.params.roundLengths && (o = r(o))) : (o = (x.size - (x.params.slidesPerView - 1) * a) / x.params.slidesPerView, x.params.roundLengths && (o = r(o)), x.isHorizontal() ? x.slides[e].style.width = o + "px" : x.slides[e].style.height = o + "px"), x.slides[e].swiperSlideSize = o, x.slidesSizesGrid.push(o), x.params.centeredSlides ? (t = t + o / 2 + s / 2 + a, 0 === s && 0 !== e && (t = t - x.size / 2 - a), 0 === e && (t = t - x.size / 2 - a), Math.abs(t) < .001 && (t = 0), i % x.params.slidesPerGroup == 0 && x.snapGrid.push(t), x.slidesGrid.push(t)) : (i % x.params.slidesPerGroup == 0 && x.snapGrid.push(t), x.slidesGrid.push(t), t = t + o + a), x.virtualSize += o + a, s = o, i++) }
                    x.virtualSize = Math.max(x.virtualSize, x.size) + x.params.slidesOffsetAfter;
                    var h;
                    if (x.rtl && x.wrongRTL && ("slide" === x.params.effect || "coverflow" === x.params.effect) && x.wrapper.css({ width: x.virtualSize + x.params.spaceBetween + "px" }), x.support.flexbox && !x.params.setWrapperSize || (x.isHorizontal() ? x.wrapper.css({ width: x.virtualSize + x.params.spaceBetween + "px" }) : x.wrapper.css({ height: x.virtualSize + x.params.spaceBetween + "px" })), x.params.slidesPerColumn > 1 && (x.virtualSize = (o + x.params.spaceBetween) * n, x.virtualSize = Math.ceil(x.virtualSize / x.params.slidesPerColumn) - x.params.spaceBetween, x.isHorizontal() ? x.wrapper.css({ width: x.virtualSize + x.params.spaceBetween + "px" }) : x.wrapper.css({ height: x.virtualSize + x.params.spaceBetween + "px" }), x.params.centeredSlides)) {
                        for (h = [], e = 0; e < x.snapGrid.length; e++) x.snapGrid[e] < x.virtualSize + x.snapGrid[0] && h.push(x.snapGrid[e]);
                        x.snapGrid = h
                    }
                    if (!x.params.centeredSlides) {
                        for (h = [], e = 0; e < x.snapGrid.length; e++) x.snapGrid[e] <= x.virtualSize - x.size && h.push(x.snapGrid[e]);
                        x.snapGrid = h, Math.floor(x.virtualSize - x.size) - Math.floor(x.snapGrid[x.snapGrid.length - 1]) > 1 && x.snapGrid.push(x.virtualSize - x.size)
                    }
                    0 === x.snapGrid.length && (x.snapGrid = [0]), 0 !== x.params.spaceBetween && (x.isHorizontal() ? x.rtl ? x.slides.css({ marginLeft: a + "px" }) : x.slides.css({ marginRight: a + "px" }) : x.slides.css({ marginBottom: a + "px" })), x.params.watchSlidesProgress && x.updateSlidesOffset()
                }
            }, x.updateSlidesOffset = function() { for (var e = 0; e < x.slides.length; e++) x.slides[e].swiperSlideOffset = x.isHorizontal() ? x.slides[e].offsetLeft : x.slides[e].offsetTop }, x.currentSlidesPerView = function() {
                var e, a, t = 1;
                if (x.params.centeredSlides) { var s, r = x.slides[x.activeIndex].swiperSlideSize; for (e = x.activeIndex + 1; e < x.slides.length; e++) x.slides[e] && !s && (r += x.slides[e].swiperSlideSize, t++, r > x.size && (s = !0)); for (a = x.activeIndex - 1; a >= 0; a--) x.slides[a] && !s && (r += x.slides[a].swiperSlideSize, t++, r > x.size && (s = !0)) } else
                    for (e = x.activeIndex + 1; e < x.slides.length; e++) x.slidesGrid[e] - x.slidesGrid[x.activeIndex] < x.size && t++;
                return t
            }, x.updateSlidesProgress = function(e) {
                if (void 0 === e && (e = x.translate || 0), 0 !== x.slides.length) {
                    void 0 === x.slides[0].swiperSlideOffset && x.updateSlidesOffset();
                    var a = -e;
                    x.rtl && (a = e), x.slides.removeClass(x.params.slideVisibleClass);
                    for (var t = 0; t < x.slides.length; t++) {
                        var s = x.slides[t],
                            r = (a + (x.params.centeredSlides ? x.minTranslate() : 0) - s.swiperSlideOffset) / (s.swiperSlideSize + x.params.spaceBetween);
                        if (x.params.watchSlidesVisibility) {
                            var i = -(a - s.swiperSlideOffset),
                                n = i + x.slidesSizesGrid[t];
                            (i >= 0 && i < x.size || n > 0 && n <= x.size || i <= 0 && n >= x.size) && x.slides.eq(t).addClass(x.params.slideVisibleClass)
                        }
                        s.progress = x.rtl ? -r : r
                    }
                }
            }, x.updateProgress = function(e) {
                void 0 === e && (e = x.translate || 0);
                var a = x.maxTranslate() - x.minTranslate(),
                    t = x.isBeginning,
                    s = x.isEnd;
                0 === a ? (x.progress = 0, x.isBeginning = x.isEnd = !0) : (x.progress = (e - x.minTranslate()) / a, x.isBeginning = x.progress <= 0, x.isEnd = x.progress >= 1), x.isBeginning && !t && x.emit("onReachBeginning", x), x.isEnd && !s && x.emit("onReachEnd", x), x.params.watchSlidesProgress && x.updateSlidesProgress(e), x.emit("onProgress", x, x.progress)
            }, x.updateActiveIndex = function() {
                var e, a, t, s = x.rtl ? x.translate : -x.translate;
                for (a = 0; a < x.slidesGrid.length; a++) void 0 !== x.slidesGrid[a + 1] ? s >= x.slidesGrid[a] && s < x.slidesGrid[a + 1] - (x.slidesGrid[a + 1] - x.slidesGrid[a]) / 2 ? e = a : s >= x.slidesGrid[a] && s < x.slidesGrid[a + 1] && (e = a + 1) : s >= x.slidesGrid[a] && (e = a);
                x.params.normalizeSlideIndex && (e < 0 || void 0 === e) && (e = 0), t = Math.floor(e / x.params.slidesPerGroup), t >= x.snapGrid.length && (t = x.snapGrid.length - 1), e !== x.activeIndex && (x.snapIndex = t, x.previousIndex = x.activeIndex, x.activeIndex = e, x.updateClasses(), x.updateRealIndex())
            }, x.updateRealIndex = function() { x.realIndex = parseInt(x.slides.eq(x.activeIndex).attr("data-swiper-slide-index") || x.activeIndex, 10) }, x.updateClasses = function() {
                x.slides.removeClass(x.params.slideActiveClass + " " + x.params.slideNextClass + " " + x.params.slidePrevClass + " " + x.params.slideDuplicateActiveClass + " " + x.params.slideDuplicateNextClass + " " + x.params.slideDuplicatePrevClass);
                var a = x.slides.eq(x.activeIndex);
                a.addClass(x.params.slideActiveClass), s.loop && (a.hasClass(x.params.slideDuplicateClass) ? x.wrapper.children("." + x.params.slideClass + ":not(." + x.params.slideDuplicateClass + ')[data-swiper-slide-index="' + x.realIndex + '"]').addClass(x.params.slideDuplicateActiveClass) : x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + x.realIndex + '"]').addClass(x.params.slideDuplicateActiveClass));
                var t = a.next("." + x.params.slideClass).addClass(x.params.slideNextClass);
                x.params.loop && 0 === t.length && (t = x.slides.eq(0), t.addClass(x.params.slideNextClass));
                var r = a.prev("." + x.params.slideClass).addClass(x.params.slidePrevClass);
                if (x.params.loop && 0 === r.length && (r = x.slides.eq(-1), r.addClass(x.params.slidePrevClass)), s.loop && (t.hasClass(x.params.slideDuplicateClass) ? x.wrapper.children("." + x.params.slideClass + ":not(." + x.params.slideDuplicateClass + ')[data-swiper-slide-index="' + t.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicateNextClass) : x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + t.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicateNextClass), r.hasClass(x.params.slideDuplicateClass) ? x.wrapper.children("." + x.params.slideClass + ":not(." + x.params.slideDuplicateClass + ')[data-swiper-slide-index="' + r.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicatePrevClass) : x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + r.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicatePrevClass)), x.paginationContainer && x.paginationContainer.length > 0) {
                    var i, n = x.params.loop ? Math.ceil((x.slides.length - 2 * x.loopedSlides) / x.params.slidesPerGroup) : x.snapGrid.length;
                    if (x.params.loop ? (i = Math.ceil((x.activeIndex - x.loopedSlides) / x.params.slidesPerGroup), i > x.slides.length - 1 - 2 * x.loopedSlides && (i -= x.slides.length - 2 * x.loopedSlides), i > n - 1 && (i -= n), i < 0 && "bullets" !== x.params.paginationType && (i = n + i)) : i = void 0 !== x.snapIndex ? x.snapIndex : x.activeIndex || 0, "bullets" === x.params.paginationType && x.bullets && x.bullets.length > 0 && (x.bullets.removeClass(x.params.bulletActiveClass), x.paginationContainer.length > 1 ? x.bullets.each(function() { e(this).index() === i && e(this).addClass(x.params.bulletActiveClass) }) : x.bullets.eq(i).addClass(x.params.bulletActiveClass)), "fraction" === x.params.paginationType && (x.paginationContainer.find("." + x.params.paginationCurrentClass).text(i + 1), x.paginationContainer.find("." + x.params.paginationTotalClass).text(n)), "progress" === x.params.paginationType) {
                        var o = (i + 1) / n,
                            l = o,
                            p = 1;
                        x.isHorizontal() || (p = o, l = 1), x.paginationContainer.find("." + x.params.paginationProgressbarClass).transform("translate3d(0,0,0) scaleX(" + l + ") scaleY(" + p + ")").transition(x.params.speed)
                    }
                    "custom" === x.params.paginationType && x.params.paginationCustomRender && (x.paginationContainer.html(x.params.paginationCustomRender(x, i + 1, n)), x.emit("onPaginationRendered", x, x.paginationContainer[0]))
                }
                x.params.loop || (x.params.prevButton && x.prevButton && x.prevButton.length > 0 && (x.isBeginning ? (x.prevButton.addClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.disable(x.prevButton)) : (x.prevButton.removeClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.enable(x.prevButton))), x.params.nextButton && x.nextButton && x.nextButton.length > 0 && (x.isEnd ? (x.nextButton.addClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.disable(x.nextButton)) : (x.nextButton.removeClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.enable(x.nextButton))))
            }, x.updatePagination = function() {
                if (x.params.pagination && x.paginationContainer && x.paginationContainer.length > 0) {
                    var e = "";
                    if ("bullets" === x.params.paginationType) {
                        for (var a = x.params.loop ? Math.ceil((x.slides.length - 2 * x.loopedSlides) / x.params.slidesPerGroup) : x.snapGrid.length, t = 0; t < a; t++) e += x.params.paginationBulletRender ? x.params.paginationBulletRender(x, t, x.params.bulletClass) : "<" + x.params.paginationElement + ' class="' + x.params.bulletClass + '"></' + x.params.paginationElement + ">";
                        x.paginationContainer.html(e), x.bullets = x.paginationContainer.find("." + x.params.bulletClass), x.params.paginationClickable && x.params.a11y && x.a11y && x.a11y.initPagination()
                    }
                    "fraction" === x.params.paginationType && (e = x.params.paginationFractionRender ? x.params.paginationFractionRender(x, x.params.paginationCurrentClass, x.params.paginationTotalClass) : '<span class="' + x.params.paginationCurrentClass + '"></span> / <span class="' + x.params.paginationTotalClass + '"></span>', x.paginationContainer.html(e)), "progress" === x.params.paginationType && (e = x.params.paginationProgressRender ? x.params.paginationProgressRender(x, x.params.paginationProgressbarClass) : '<span class="' + x.params.paginationProgressbarClass + '"></span>', x.paginationContainer.html(e)), "custom" !== x.params.paginationType && x.emit("onPaginationRendered", x, x.paginationContainer[0])
                }
            }, x.update = function(e) {
                function a() {
                    x.rtl, x.translate;
                    t = Math.min(Math.max(x.translate, x.maxTranslate()), x.minTranslate()), x.setWrapperTranslate(t), x.updateActiveIndex(), x.updateClasses()
                }
                if (x) { x.updateContainerSize(), x.updateSlidesSize(), x.updateProgress(), x.updatePagination(), x.updateClasses(), x.params.scrollbar && x.scrollbar && x.scrollbar.set(); var t; if (e) { x.controller && x.controller.spline && (x.controller.spline = void 0), x.params.freeMode ? (a(), x.params.autoHeight && x.updateAutoHeight()) : (("auto" === x.params.slidesPerView || x.params.slidesPerView > 1) && x.isEnd && !x.params.centeredSlides ? x.slideTo(x.slides.length - 1, 0, !1, !0) : x.slideTo(x.activeIndex, 0, !1, !0)) || a() } else x.params.autoHeight && x.updateAutoHeight() }
            }, x.onResize = function(e) {
                x.params.onBeforeResize && x.params.onBeforeResize(x), x.params.breakpoints && x.setBreakpoint();
                var a = x.params.allowSwipeToPrev,
                    t = x.params.allowSwipeToNext;
                x.params.allowSwipeToPrev = x.params.allowSwipeToNext = !0, x.updateContainerSize(), x.updateSlidesSize(), ("auto" === x.params.slidesPerView || x.params.freeMode || e) && x.updatePagination(), x.params.scrollbar && x.scrollbar && x.scrollbar.set(), x.controller && x.controller.spline && (x.controller.spline = void 0);
                var s = !1;
                if (x.params.freeMode) {
                    var r = Math.min(Math.max(x.translate, x.maxTranslate()), x.minTranslate());
                    x.setWrapperTranslate(r), x.updateActiveIndex(), x.updateClasses(), x.params.autoHeight && x.updateAutoHeight()
                } else x.updateClasses(), s = ("auto" === x.params.slidesPerView || x.params.slidesPerView > 1) && x.isEnd && !x.params.centeredSlides ? x.slideTo(x.slides.length - 1, 0, !1, !0) : x.slideTo(x.activeIndex, 0, !1, !0);
                x.params.lazyLoading && !s && x.lazy && x.lazy.load(), x.params.allowSwipeToPrev = a, x.params.allowSwipeToNext = t, x.params.onAfterResize && x.params.onAfterResize(x)
            }, x.touchEventsDesktop = { start: "mousedown", move: "mousemove", end: "mouseup" }, window.navigator.pointerEnabled ? x.touchEventsDesktop = { start: "pointerdown", move: "pointermove", end: "pointerup" } : window.navigator.msPointerEnabled && (x.touchEventsDesktop = { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" }), x.touchEvents = { start: x.support.touch || !x.params.simulateTouch ? "touchstart" : x.touchEventsDesktop.start, move: x.support.touch || !x.params.simulateTouch ? "touchmove" : x.touchEventsDesktop.move, end: x.support.touch || !x.params.simulateTouch ? "touchend" : x.touchEventsDesktop.end }, (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && ("container" === x.params.touchEventsTarget ? x.container : x.wrapper).addClass("swiper-wp8-" + x.params.direction), x.initEvents = function(e) {
                var a = e ? "off" : "on",
                    t = e ? "removeEventListener" : "addEventListener",
                    r = "container" === x.params.touchEventsTarget ? x.container[0] : x.wrapper[0],
                    i = x.support.touch ? r : document,
                    n = !!x.params.nested;
                if (x.browser.ie) r[t](x.touchEvents.start, x.onTouchStart, !1), i[t](x.touchEvents.move, x.onTouchMove, n), i[t](x.touchEvents.end, x.onTouchEnd, !1);
                else {
                    if (x.support.touch) {
                        var o = !("touchstart" !== x.touchEvents.start || !x.support.passiveListener || !x.params.passiveListeners) && { passive: !0, capture: !1 };
                        r[t](x.touchEvents.start, x.onTouchStart, o), r[t](x.touchEvents.move, x.onTouchMove, n), r[t](x.touchEvents.end, x.onTouchEnd, o)
                    }(s.simulateTouch && !x.device.ios && !x.device.android || s.simulateTouch && !x.support.touch && x.device.ios) && (r[t]("mousedown", x.onTouchStart, !1), document[t]("mousemove", x.onTouchMove, n), document[t]("mouseup", x.onTouchEnd, !1))
                }
                window[t]("resize", x.onResize), x.params.nextButton && x.nextButton && x.nextButton.length > 0 && (x.nextButton[a]("click", x.onClickNext), x.params.a11y && x.a11y && x.nextButton[a]("keydown", x.a11y.onEnterKey)), x.params.prevButton && x.prevButton && x.prevButton.length > 0 && (x.prevButton[a]("click", x.onClickPrev), x.params.a11y && x.a11y && x.prevButton[a]("keydown", x.a11y.onEnterKey)), x.params.pagination && x.params.paginationClickable && (x.paginationContainer[a]("click", "." + x.params.bulletClass, x.onClickIndex), x.params.a11y && x.a11y && x.paginationContainer[a]("keydown", "." + x.params.bulletClass, x.a11y.onEnterKey)), (x.params.preventClicks || x.params.preventClicksPropagation) && r[t]("click", x.preventClicks, !0)
            }, x.attachEvents = function() { x.initEvents() }, x.detachEvents = function() { x.initEvents(!0) }, x.allowClick = !0, x.preventClicks = function(e) { x.allowClick || (x.params.preventClicks && e.preventDefault(), x.params.preventClicksPropagation && x.animating && (e.stopPropagation(), e.stopImmediatePropagation())) }, x.onClickNext = function(e) { e.preventDefault(), x.isEnd && !x.params.loop || x.slideNext() }, x.onClickPrev = function(e) { e.preventDefault(), x.isBeginning && !x.params.loop || x.slidePrev() }, x.onClickIndex = function(a) {
                a.preventDefault();
                var t = e(this).index() * x.params.slidesPerGroup;
                x.params.loop && (t += x.loopedSlides), x.slideTo(t)
            }, x.updateClickedSlide = function(a) {
                var t = n(a, "." + x.params.slideClass),
                    s = !1;
                if (t)
                    for (var r = 0; r < x.slides.length; r++) x.slides[r] === t && (s = !0);
                if (!t || !s) return x.clickedSlide = void 0, void(x.clickedIndex = void 0);
                if (x.clickedSlide = t, x.clickedIndex = e(t).index(), x.params.slideToClickedSlide && void 0 !== x.clickedIndex && x.clickedIndex !== x.activeIndex) {
                    var i, o = x.clickedIndex,
                        l = "auto" === x.params.slidesPerView ? x.currentSlidesPerView() : x.params.slidesPerView;
                    if (x.params.loop) {
                        if (x.animating) return;
                        i = parseInt(e(x.clickedSlide).attr("data-swiper-slide-index"), 10), x.params.centeredSlides ? o < x.loopedSlides - l / 2 || o > x.slides.length - x.loopedSlides + l / 2 ? (x.fixLoop(), o = x.wrapper.children("." + x.params.slideClass + '[data-swiper-slide-index="' + i + '"]:not(.' + x.params.slideDuplicateClass + ")").eq(0).index(), setTimeout(function() { x.slideTo(o) }, 0)) : x.slideTo(o) : o > x.slides.length - l ? (x.fixLoop(), o = x.wrapper.children("." + x.params.slideClass + '[data-swiper-slide-index="' + i + '"]:not(.' + x.params.slideDuplicateClass + ")").eq(0).index(), setTimeout(function() { x.slideTo(o) }, 0)) : x.slideTo(o)
                    } else x.slideTo(o)
                }
            };
            var b, C, S, z, M, P, E, I, k, D, L = "input, select, textarea, button, video",
                B = Date.now(),
                H = [];
            x.animating = !1, x.touches = { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 };
            var G, X;
            x.onTouchStart = function(a) {
                if (a.originalEvent && (a = a.originalEvent), (G = "touchstart" === a.type) || !("which" in a) || 3 !== a.which) {
                    if (x.params.noSwiping && n(a, "." + x.params.noSwipingClass)) return void(x.allowClick = !0);
                    if (!x.params.swipeHandler || n(a, x.params.swipeHandler)) {
                        var t = x.touches.currentX = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX,
                            s = x.touches.currentY = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY;
                        if (!(x.device.ios && x.params.iOSEdgeSwipeDetection && t <= x.params.iOSEdgeSwipeThreshold)) {
                            if (b = !0, C = !1, S = !0, M = void 0, X = void 0, x.touches.startX = t, x.touches.startY = s, z = Date.now(), x.allowClick = !0, x.updateContainerSize(), x.swipeDirection = void 0, x.params.threshold > 0 && (I = !1), "touchstart" !== a.type) {
                                var r = !0;
                                e(a.target).is(L) && (r = !1), document.activeElement && e(document.activeElement).is(L) && document.activeElement.blur(), r && a.preventDefault()
                            }
                            x.emit("onTouchStart", x, a)
                        }
                    }
                }
            }, x.onTouchMove = function(a) {
                if (a.originalEvent && (a = a.originalEvent), !G || "mousemove" !== a.type) {
                    if (a.preventedByNestedSwiper) return x.touches.startX = "touchmove" === a.type ? a.targetTouches[0].pageX : a.pageX, void(x.touches.startY = "touchmove" === a.type ? a.targetTouches[0].pageY : a.pageY);
                    if (x.params.onlyExternal) return x.allowClick = !1, void(b && (x.touches.startX = x.touches.currentX = "touchmove" === a.type ? a.targetTouches[0].pageX : a.pageX, x.touches.startY = x.touches.currentY = "touchmove" === a.type ? a.targetTouches[0].pageY : a.pageY, z = Date.now()));
                    if (G && x.params.touchReleaseOnEdges && !x.params.loop)
                        if (x.isHorizontal()) { if (x.touches.currentX < x.touches.startX && x.translate <= x.maxTranslate() || x.touches.currentX > x.touches.startX && x.translate >= x.minTranslate()) return } else if (x.touches.currentY < x.touches.startY && x.translate <= x.maxTranslate() || x.touches.currentY > x.touches.startY && x.translate >= x.minTranslate()) return;
                    if (G && document.activeElement && a.target === document.activeElement && e(a.target).is(L)) return C = !0, void(x.allowClick = !1);
                    if (S && x.emit("onTouchMove", x, a), !(a.targetTouches && a.targetTouches.length > 1)) {
                        if (x.touches.currentX = "touchmove" === a.type ? a.targetTouches[0].pageX : a.pageX, x.touches.currentY = "touchmove" === a.type ? a.targetTouches[0].pageY : a.pageY, void 0 === M) {
                            var t;
                            x.isHorizontal() && x.touches.currentY === x.touches.startY || !x.isHorizontal() && x.touches.currentX === x.touches.startX ? M = !1 : (t = 180 * Math.atan2(Math.abs(x.touches.currentY - x.touches.startY), Math.abs(x.touches.currentX - x.touches.startX)) / Math.PI, M = x.isHorizontal() ? t > x.params.touchAngle : 90 - t > x.params.touchAngle)
                        }
                        if (M && x.emit("onTouchMoveOpposite", x, a), void 0 === X && (x.touches.currentX === x.touches.startX && x.touches.currentY === x.touches.startY || (X = !0)), b) {
                            if (M) return void(b = !1);
                            if (X) {
                                x.allowClick = !1, x.emit("onSliderMove", x, a), a.preventDefault(), x.params.touchMoveStopPropagation && !x.params.nested && a.stopPropagation(), C || (s.loop && x.fixLoop(), E = x.getWrapperTranslate(), x.setWrapperTransition(0), x.animating && x.wrapper.trigger("webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd"), x.params.autoplay && x.autoplaying && (x.params.autoplayDisableOnInteraction ? x.stopAutoplay() : x.pauseAutoplay()), D = !1, !x.params.grabCursor || x.params.allowSwipeToNext !== !0 && x.params.allowSwipeToPrev !== !0 || x.setGrabCursor(!0)), C = !0;
                                var r = x.touches.diff = x.isHorizontal() ? x.touches.currentX - x.touches.startX : x.touches.currentY - x.touches.startY;
                                r *= x.params.touchRatio, x.rtl && (r = -r), x.swipeDirection = r > 0 ? "prev" : "next", P = r + E;
                                var i = !0;
                                if (r > 0 && P > x.minTranslate() ? (i = !1, x.params.resistance && (P = x.minTranslate() - 1 + Math.pow(-x.minTranslate() + E + r, x.params.resistanceRatio))) : r < 0 && P < x.maxTranslate() && (i = !1, x.params.resistance && (P = x.maxTranslate() + 1 - Math.pow(x.maxTranslate() - E - r, x.params.resistanceRatio))), i && (a.preventedByNestedSwiper = !0), !x.params.allowSwipeToNext && "next" === x.swipeDirection && P < E && (P = E), !x.params.allowSwipeToPrev && "prev" === x.swipeDirection && P > E && (P = E), x.params.threshold > 0) { if (!(Math.abs(r) > x.params.threshold || I)) return void(P = E); if (!I) return I = !0, x.touches.startX = x.touches.currentX, x.touches.startY = x.touches.currentY, P = E, void(x.touches.diff = x.isHorizontal() ? x.touches.currentX - x.touches.startX : x.touches.currentY - x.touches.startY) }
                                x.params.followFinger && ((x.params.freeMode || x.params.watchSlidesProgress) && x.updateActiveIndex(), x.params.freeMode && (0 === H.length && H.push({ position: x.touches[x.isHorizontal() ? "startX" : "startY"], time: z }), H.push({ position: x.touches[x.isHorizontal() ? "currentX" : "currentY"], time: (new window.Date).getTime() })), x.updateProgress(P), x.setWrapperTranslate(P))
                            }
                        }
                    }
                }
            }, x.onTouchEnd = function(a) {
                if (a.originalEvent && (a = a.originalEvent), S && x.emit("onTouchEnd", x, a), S = !1, b) {
                    x.params.grabCursor && C && b && (x.params.allowSwipeToNext === !0 || x.params.allowSwipeToPrev === !0) && x.setGrabCursor(!1);
                    var t = Date.now(),
                        s = t - z;
                    if (x.allowClick && (x.updateClickedSlide(a), x.emit("onTap", x, a), s < 300 && t - B > 300 && (k && clearTimeout(k), k = setTimeout(function() { x && (x.params.paginationHide && x.paginationContainer.length > 0 && !e(a.target).hasClass(x.params.bulletClass) && x.paginationContainer.toggleClass(x.params.paginationHiddenClass), x.emit("onClick", x, a)) }, 300)), s < 300 && t - B < 300 && (k && clearTimeout(k), x.emit("onDoubleTap", x, a))), B = Date.now(), setTimeout(function() { x && (x.allowClick = !0) }, 0), !b || !C || !x.swipeDirection || 0 === x.touches.diff || P === E) return void(b = C = !1);
                    b = C = !1;
                    var r;
                    if (r = x.params.followFinger ? x.rtl ? x.translate : -x.translate : -P, x.params.freeMode) {
                        if (r < -x.minTranslate()) return void x.slideTo(x.activeIndex);
                        if (r > -x.maxTranslate()) return void(x.slides.length < x.snapGrid.length ? x.slideTo(x.snapGrid.length - 1) : x.slideTo(x.slides.length - 1));
                        if (x.params.freeModeMomentum) {
                            if (H.length > 1) {
                                var i = H.pop(),
                                    n = H.pop(),
                                    o = i.position - n.position,
                                    l = i.time - n.time;
                                x.velocity = o / l, x.velocity = x.velocity / 2, Math.abs(x.velocity) < x.params.freeModeMinimumVelocity && (x.velocity = 0), (l > 150 || (new window.Date).getTime() - i.time > 300) && (x.velocity = 0)
                            } else x.velocity = 0;
                            x.velocity = x.velocity * x.params.freeModeMomentumVelocityRatio, H.length = 0;
                            var p = 1e3 * x.params.freeModeMomentumRatio,
                                d = x.velocity * p,
                                m = x.translate + d;
                            x.rtl && (m = -m);
                            var u, c = !1,
                                g = 20 * Math.abs(x.velocity) * x.params.freeModeMomentumBounceRatio;
                            if (m < x.maxTranslate()) x.params.freeModeMomentumBounce ? (m + x.maxTranslate() < -g && (m = x.maxTranslate() - g), u = x.maxTranslate(), c = !0, D = !0) : m = x.maxTranslate();
                            else if (m > x.minTranslate()) x.params.freeModeMomentumBounce ? (m - x.minTranslate() > g && (m = x.minTranslate() + g), u = x.minTranslate(), c = !0, D = !0) : m = x.minTranslate();
                            else if (x.params.freeModeSticky) {
                                var h, v = 0;
                                for (v = 0; v < x.snapGrid.length; v += 1)
                                    if (x.snapGrid[v] > -m) { h = v; break }
                                m = Math.abs(x.snapGrid[h] - m) < Math.abs(x.snapGrid[h - 1] - m) || "next" === x.swipeDirection ? x.snapGrid[h] : x.snapGrid[h - 1], x.rtl || (m = -m)
                            }
                            if (0 !== x.velocity) p = x.rtl ? Math.abs((-m - x.translate) / x.velocity) : Math.abs((m - x.translate) / x.velocity);
                            else if (x.params.freeModeSticky) return void x.slideReset();
                            x.params.freeModeMomentumBounce && c ? (x.updateProgress(u), x.setWrapperTransition(p), x.setWrapperTranslate(m), x.onTransitionStart(), x.animating = !0, x.wrapper.transitionEnd(function() { x && D && (x.emit("onMomentumBounce", x), x.setWrapperTransition(x.params.speed), x.setWrapperTranslate(u), x.wrapper.transitionEnd(function() { x && x.onTransitionEnd() })) })) : x.velocity ? (x.updateProgress(m), x.setWrapperTransition(p), x.setWrapperTranslate(m), x.onTransitionStart(), x.animating || (x.animating = !0, x.wrapper.transitionEnd(function() { x && x.onTransitionEnd() }))) : x.updateProgress(m), x.updateActiveIndex()
                        }
                        return void((!x.params.freeModeMomentum || s >= x.params.longSwipesMs) && (x.updateProgress(), x.updateActiveIndex()))
                    }
                    var f, w = 0,
                        y = x.slidesSizesGrid[0];
                    for (f = 0; f < x.slidesGrid.length; f += x.params.slidesPerGroup) void 0 !== x.slidesGrid[f + x.params.slidesPerGroup] ? r >= x.slidesGrid[f] && r < x.slidesGrid[f + x.params.slidesPerGroup] && (w = f, y = x.slidesGrid[f + x.params.slidesPerGroup] - x.slidesGrid[f]) : r >= x.slidesGrid[f] && (w = f, y = x.slidesGrid[x.slidesGrid.length - 1] - x.slidesGrid[x.slidesGrid.length - 2]);
                    var T = (r - x.slidesGrid[w]) / y;
                    if (s > x.params.longSwipesMs) { if (!x.params.longSwipes) return void x.slideTo(x.activeIndex); "next" === x.swipeDirection && (T >= x.params.longSwipesRatio ? x.slideTo(w + x.params.slidesPerGroup) : x.slideTo(w)), "prev" === x.swipeDirection && (T > 1 - x.params.longSwipesRatio ? x.slideTo(w + x.params.slidesPerGroup) : x.slideTo(w)) } else { if (!x.params.shortSwipes) return void x.slideTo(x.activeIndex); "next" === x.swipeDirection && x.slideTo(w + x.params.slidesPerGroup), "prev" === x.swipeDirection && x.slideTo(w) }
                }
            }, x._slideTo = function(e, a) { return x.slideTo(e, a, !0, !0) }, x.slideTo = function(e, a, t, s) {
                void 0 === t && (t = !0), void 0 === e && (e = 0), e < 0 && (e = 0), x.snapIndex = Math.floor(e / x.params.slidesPerGroup), x.snapIndex >= x.snapGrid.length && (x.snapIndex = x.snapGrid.length - 1);
                var r = -x.snapGrid[x.snapIndex];
                if (x.params.autoplay && x.autoplaying && (s || !x.params.autoplayDisableOnInteraction ? x.pauseAutoplay(a) : x.stopAutoplay()), x.updateProgress(r), x.params.normalizeSlideIndex)
                    for (var i = 0; i < x.slidesGrid.length; i++) - Math.floor(100 * r) >= Math.floor(100 * x.slidesGrid[i]) && (e = i);
                return !(!x.params.allowSwipeToNext && r < x.translate && r < x.minTranslate()) && (!(!x.params.allowSwipeToPrev && r > x.translate && r > x.maxTranslate() && (x.activeIndex || 0) !== e) && (void 0 === a && (a = x.params.speed), x.previousIndex = x.activeIndex || 0, x.activeIndex = e, x.updateRealIndex(), x.rtl && -r === x.translate || !x.rtl && r === x.translate ? (x.params.autoHeight && x.updateAutoHeight(), x.updateClasses(), "slide" !== x.params.effect && x.setWrapperTranslate(r), !1) : (x.updateClasses(), x.onTransitionStart(t), 0 === a || x.browser.lteIE9 ? (x.setWrapperTranslate(r), x.setWrapperTransition(0), x.onTransitionEnd(t)) : (x.setWrapperTranslate(r), x.setWrapperTransition(a), x.animating || (x.animating = !0, x.wrapper.transitionEnd(function() { x && x.onTransitionEnd(t) }))), !0)))
            }, x.onTransitionStart = function(e) { void 0 === e && (e = !0), x.params.autoHeight && x.updateAutoHeight(), x.lazy && x.lazy.onTransitionStart(), e && (x.emit("onTransitionStart", x), x.activeIndex !== x.previousIndex && (x.emit("onSlideChangeStart", x), x.activeIndex > x.previousIndex ? x.emit("onSlideNextStart", x) : x.emit("onSlidePrevStart", x))) }, x.onTransitionEnd = function(e) { x.animating = !1, x.setWrapperTransition(0), void 0 === e && (e = !0), x.lazy && x.lazy.onTransitionEnd(), e && (x.emit("onTransitionEnd", x), x.activeIndex !== x.previousIndex && (x.emit("onSlideChangeEnd", x), x.activeIndex > x.previousIndex ? x.emit("onSlideNextEnd", x) : x.emit("onSlidePrevEnd", x))), x.params.history && x.history && x.history.setHistory(x.params.history, x.activeIndex), x.params.hashnav && x.hashnav && x.hashnav.setHash() }, x.slideNext = function(e, a, t) {
                if (x.params.loop) {
                    if (x.animating) return !1;
                    x.fixLoop();
                    x.container[0].clientLeft;
                    return x.slideTo(x.activeIndex + x.params.slidesPerGroup, a, e, t)
                }
                return x.slideTo(x.activeIndex + x.params.slidesPerGroup, a, e, t)
            }, x._slideNext = function(e) { return x.slideNext(!0, e, !0) }, x.slidePrev = function(e, a, t) {
                if (x.params.loop) {
                    if (x.animating) return !1;
                    x.fixLoop();
                    x.container[0].clientLeft;
                    return x.slideTo(x.activeIndex - 1, a, e, t)
                }
                return x.slideTo(x.activeIndex - 1, a, e, t)
            }, x._slidePrev = function(e) { return x.slidePrev(!0, e, !0) }, x.slideReset = function(e, a, t) { return x.slideTo(x.activeIndex, a, e) }, x.disableTouchControl = function() { return x.params.onlyExternal = !0, !0 }, x.enableTouchControl = function() { return x.params.onlyExternal = !1, !0 }, x.setWrapperTransition = function(e, a) { x.wrapper.transition(e), "slide" !== x.params.effect && x.effects[x.params.effect] && x.effects[x.params.effect].setTransition(e), x.params.parallax && x.parallax && x.parallax.setTransition(e), x.params.scrollbar && x.scrollbar && x.scrollbar.setTransition(e), x.params.control && x.controller && x.controller.setTransition(e, a), x.emit("onSetTransition", x, e) }, x.setWrapperTranslate = function(e, a, t) {
                var s = 0,
                    i = 0;
                x.isHorizontal() ? s = x.rtl ? -e : e : i = e, x.params.roundLengths && (s = r(s), i = r(i)), x.params.virtualTranslate || (x.support.transforms3d ? x.wrapper.transform("translate3d(" + s + "px, " + i + "px, 0px)") : x.wrapper.transform("translate(" + s + "px, " + i + "px)")), x.translate = x.isHorizontal() ? s : i;
                var n, o = x.maxTranslate() - x.minTranslate();
                n = 0 === o ? 0 : (e - x.minTranslate()) / o, n !== x.progress && x.updateProgress(e), a && x.updateActiveIndex(), "slide" !== x.params.effect && x.effects[x.params.effect] && x.effects[x.params.effect].setTranslate(x.translate), x.params.parallax && x.parallax && x.parallax.setTranslate(x.translate), x.params.scrollbar && x.scrollbar && x.scrollbar.setTranslate(x.translate), x.params.control && x.controller && x.controller.setTranslate(x.translate, t), x.emit("onSetTranslate", x, x.translate)
            }, x.getTranslate = function(e, a) { var t, s, r, i; return void 0 === a && (a = "x"), x.params.virtualTranslate ? x.rtl ? -x.translate : x.translate : (r = window.getComputedStyle(e, null), window.WebKitCSSMatrix ? (s = r.transform || r.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(function(e) { return e.replace(",", ".") }).join(", ")), i = new window.WebKitCSSMatrix("none" === s ? "" : s)) : (i = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), t = i.toString().split(",")), "x" === a && (s = window.WebKitCSSMatrix ? i.m41 : 16 === t.length ? parseFloat(t[12]) : parseFloat(t[4])), "y" === a && (s = window.WebKitCSSMatrix ? i.m42 : 16 === t.length ? parseFloat(t[13]) : parseFloat(t[5])), x.rtl && s && (s = -s), s || 0) }, x.getWrapperTranslate = function(e) { return void 0 === e && (e = x.isHorizontal() ? "x" : "y"), x.getTranslate(x.wrapper[0], e) }, x.observers = [], x.initObservers = function() {
                if (x.params.observeParents)
                    for (var e = x.container.parents(), a = 0; a < e.length; a++) o(e[a]);
                o(x.container[0], { childList: !1 }), o(x.wrapper[0], { attributes: !1 })
            }, x.disconnectObservers = function() {
                for (var e = 0; e < x.observers.length; e++) x.observers[e].disconnect();
                x.observers = []
            }, x.createLoop = function() {
                x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass).remove();
                var a = x.wrapper.children("." + x.params.slideClass);
                "auto" !== x.params.slidesPerView || x.params.loopedSlides || (x.params.loopedSlides = a.length), x.loopedSlides = parseInt(x.params.loopedSlides || x.params.slidesPerView, 10), x.loopedSlides = x.loopedSlides + x.params.loopAdditionalSlides, x.loopedSlides > a.length && (x.loopedSlides = a.length);
                var t, s = [],
                    r = [];
                for (a.each(function(t, i) {
                        var n = e(this);
                        t < x.loopedSlides && r.push(i), t < a.length && t >= a.length - x.loopedSlides && s.push(i), n.attr("data-swiper-slide-index", t)
                    }), t = 0; t < r.length; t++) x.wrapper.append(e(r[t].cloneNode(!0)).addClass(x.params.slideDuplicateClass));
                for (t = s.length - 1; t >= 0; t--) x.wrapper.prepend(e(s[t].cloneNode(!0)).addClass(x.params.slideDuplicateClass))
            }, x.destroyLoop = function() { x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass).remove(), x.slides.removeAttr("data-swiper-slide-index") }, x.reLoop = function(e) {
                var a = x.activeIndex - x.loopedSlides;
                x.destroyLoop(), x.createLoop(), x.updateSlidesSize(), e && x.slideTo(a + x.loopedSlides, 0, !1)
            }, x.fixLoop = function() {
                var e;
                x.activeIndex < x.loopedSlides ? (e = x.slides.length - 3 * x.loopedSlides + x.activeIndex, e += x.loopedSlides, x.slideTo(e, 0, !1, !0)) : ("auto" === x.params.slidesPerView && x.activeIndex >= 2 * x.loopedSlides || x.activeIndex > x.slides.length - 2 * x.params.slidesPerView) && (e = -x.slides.length + x.activeIndex + x.loopedSlides, e += x.loopedSlides, x.slideTo(e, 0, !1, !0))
            }, x.appendSlide = function(e) {
                if (x.params.loop && x.destroyLoop(), "object" == typeof e && e.length)
                    for (var a = 0; a < e.length; a++) e[a] && x.wrapper.append(e[a]);
                else x.wrapper.append(e);
                x.params.loop && x.createLoop(), x.params.observer && x.support.observer || x.update(!0)
            }, x.prependSlide = function(e) {
                x.params.loop && x.destroyLoop();
                var a = x.activeIndex + 1;
                if ("object" == typeof e && e.length) {
                    for (var t = 0; t < e.length; t++) e[t] && x.wrapper.prepend(e[t]);
                    a = x.activeIndex + e.length
                } else x.wrapper.prepend(e);
                x.params.loop && x.createLoop(), x.params.observer && x.support.observer || x.update(!0), x.slideTo(a, 0, !1)
            }, x.removeSlide = function(e) {
                x.params.loop && (x.destroyLoop(), x.slides = x.wrapper.children("." + x.params.slideClass));
                var a, t = x.activeIndex;
                if ("object" == typeof e && e.length) {
                    for (var s = 0; s < e.length; s++) a = e[s], x.slides[a] && x.slides.eq(a).remove(), a < t && t--;
                    t = Math.max(t, 0)
                } else a = e, x.slides[a] && x.slides.eq(a).remove(), a < t && t--, t = Math.max(t, 0);
                x.params.loop && x.createLoop(), x.params.observer && x.support.observer || x.update(!0), x.params.loop ? x.slideTo(t + x.loopedSlides, 0, !1) : x.slideTo(t, 0, !1)
            }, x.removeAllSlides = function() {
                for (var e = [], a = 0; a < x.slides.length; a++) e.push(a);
                x.removeSlide(e)
            }, x.effects = {
                fade: {
                    setTranslate: function() {
                        for (var e = 0; e < x.slides.length; e++) {
                            var a = x.slides.eq(e),
                                t = a[0].swiperSlideOffset,
                                s = -t;
                            x.params.virtualTranslate || (s -= x.translate);
                            var r = 0;
                            x.isHorizontal() || (r = s, s = 0);
                            var i = x.params.fade.crossFade ? Math.max(1 - Math.abs(a[0].progress), 0) : 1 + Math.min(Math.max(a[0].progress, -1), 0);
                            a.css({ opacity: i }).transform("translate3d(" + s + "px, " + r + "px, 0px)")
                        }
                    },
                    setTransition: function(e) {
                        if (x.slides.transition(e), x.params.virtualTranslate && 0 !== e) {
                            var a = !1;
                            x.slides.transitionEnd(function() { if (!a && x) { a = !0, x.animating = !1; for (var e = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"], t = 0; t < e.length; t++) x.wrapper.trigger(e[t]) } })
                        }
                    }
                },
                flip: {
                    setTranslate: function() {
                        for (var a = 0; a < x.slides.length; a++) {
                            var t = x.slides.eq(a),
                                s = t[0].progress;
                            x.params.flip.limitRotation && (s = Math.max(Math.min(t[0].progress, 1), -1));
                            var r = t[0].swiperSlideOffset,
                                i = -180 * s,
                                n = i,
                                o = 0,
                                l = -r,
                                p = 0;
                            if (x.isHorizontal() ? x.rtl && (n = -n) : (p = l, l = 0, o = -n, n = 0), t[0].style.zIndex = -Math.abs(Math.round(s)) + x.slides.length, x.params.flip.slideShadows) {
                                var d = x.isHorizontal() ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                                    m = x.isHorizontal() ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                                0 === d.length && (d = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "left" : "top") + '"></div>'), t.append(d)), 0 === m.length && (m = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "right" : "bottom") + '"></div>'), t.append(m)), d.length && (d[0].style.opacity = Math.max(-s, 0)), m.length && (m[0].style.opacity = Math.max(s, 0))
                            }
                            t.transform("translate3d(" + l + "px, " + p + "px, 0px) rotateX(" + o + "deg) rotateY(" + n + "deg)")
                        }
                    },
                    setTransition: function(a) {
                        if (x.slides.transition(a).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(a), x.params.virtualTranslate && 0 !== a) {
                            var t = !1;
                            x.slides.eq(x.activeIndex).transitionEnd(function() { if (!t && x && e(this).hasClass(x.params.slideActiveClass)) { t = !0, x.animating = !1; for (var a = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"], s = 0; s < a.length; s++) x.wrapper.trigger(a[s]) } })
                        }
                    }
                },
                cube: {
                    setTranslate: function() {
                        var a, t = 0;
                        x.params.cube.shadow && (x.isHorizontal() ? (a = x.wrapper.find(".swiper-cube-shadow"), 0 === a.length && (a = e('<div class="swiper-cube-shadow"></div>'), x.wrapper.append(a)), a.css({ height: x.width + "px" })) : (a = x.container.find(".swiper-cube-shadow"), 0 === a.length && (a = e('<div class="swiper-cube-shadow"></div>'), x.container.append(a))));
                        for (var s = 0; s < x.slides.length; s++) {
                            var r = x.slides.eq(s),
                                i = 90 * s,
                                n = Math.floor(i / 360);
                            x.rtl && (i = -i, n = Math.floor(-i / 360));
                            var o = Math.max(Math.min(r[0].progress, 1), -1),
                                l = 0,
                                p = 0,
                                d = 0;
                            s % 4 == 0 ? (l = 4 * -n * x.size, d = 0) : (s - 1) % 4 == 0 ? (l = 0, d = 4 * -n * x.size) : (s - 2) % 4 == 0 ? (l = x.size + 4 * n * x.size, d = x.size) : (s - 3) % 4 == 0 && (l = -x.size, d = 3 * x.size + 4 * x.size * n), x.rtl && (l = -l), x.isHorizontal() || (p = l, l = 0);
                            var m = "rotateX(" + (x.isHorizontal() ? 0 : -i) + "deg) rotateY(" + (x.isHorizontal() ? i : 0) + "deg) translate3d(" + l + "px, " + p + "px, " + d + "px)";
                            if (o <= 1 && o > -1 && (t = 90 * s + 90 * o, x.rtl && (t = 90 * -s - 90 * o)), r.transform(m), x.params.cube.slideShadows) {
                                var u = x.isHorizontal() ? r.find(".swiper-slide-shadow-left") : r.find(".swiper-slide-shadow-top"),
                                    c = x.isHorizontal() ? r.find(".swiper-slide-shadow-right") : r.find(".swiper-slide-shadow-bottom");
                                0 === u.length && (u = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "left" : "top") + '"></div>'), r.append(u)), 0 === c.length && (c = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "right" : "bottom") + '"></div>'), r.append(c)), u.length && (u[0].style.opacity = Math.max(-o, 0)), c.length && (c[0].style.opacity = Math.max(o, 0))
                            }
                        }
                        if (x.wrapper.css({ "-webkit-transform-origin": "50% 50% -" + x.size / 2 + "px", "-moz-transform-origin": "50% 50% -" + x.size / 2 + "px", "-ms-transform-origin": "50% 50% -" + x.size / 2 + "px", "transform-origin": "50% 50% -" + x.size / 2 + "px" }), x.params.cube.shadow)
                            if (x.isHorizontal()) a.transform("translate3d(0px, " + (x.width / 2 + x.params.cube.shadowOffset) + "px, " + -x.width / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + x.params.cube.shadowScale + ")");
                            else {
                                var g = Math.abs(t) - 90 * Math.floor(Math.abs(t) / 90),
                                    h = 1.5 - (Math.sin(2 * g * Math.PI / 360) / 2 + Math.cos(2 * g * Math.PI / 360) / 2),
                                    v = x.params.cube.shadowScale,
                                    f = x.params.cube.shadowScale / h,
                                    w = x.params.cube.shadowOffset;
                                a.transform("scale3d(" + v + ", 1, " + f + ") translate3d(0px, " + (x.height / 2 + w) + "px, " + -x.height / 2 / f + "px) rotateX(-90deg)")
                            }
                        var y = x.isSafari || x.isUiWebView ? -x.size / 2 : 0;
                        x.wrapper.transform("translate3d(0px,0," + y + "px) rotateX(" + (x.isHorizontal() ? 0 : t) + "deg) rotateY(" + (x.isHorizontal() ? -t : 0) + "deg)")
                    },
                    setTransition: function(e) { x.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), x.params.cube.shadow && !x.isHorizontal() && x.container.find(".swiper-cube-shadow").transition(e) }
                },
                coverflow: {
                    setTranslate: function() {
                        for (var a = x.translate, t = x.isHorizontal() ? -a + x.width / 2 : -a + x.height / 2, s = x.isHorizontal() ? x.params.coverflow.rotate : -x.params.coverflow.rotate, r = x.params.coverflow.depth, i = 0, n = x.slides.length; i < n; i++) {
                            var o = x.slides.eq(i),
                                l = x.slidesSizesGrid[i],
                                p = o[0].swiperSlideOffset,
                                d = (t - p - l / 2) / l * x.params.coverflow.modifier,
                                m = x.isHorizontal() ? s * d : 0,
                                u = x.isHorizontal() ? 0 : s * d,
                                c = -r * Math.abs(d),
                                g = x.isHorizontal() ? 0 : x.params.coverflow.stretch * d,
                                h = x.isHorizontal() ? x.params.coverflow.stretch * d : 0;
                            Math.abs(h) < .001 && (h = 0), Math.abs(g) < .001 && (g = 0), Math.abs(c) < .001 && (c = 0), Math.abs(m) < .001 && (m = 0), Math.abs(u) < .001 && (u = 0);
                            var v = "translate3d(" + h + "px," + g + "px," + c + "px)  rotateX(" + u + "deg) rotateY(" + m + "deg)";
                            if (o.transform(v), o[0].style.zIndex = 1 - Math.abs(Math.round(d)), x.params.coverflow.slideShadows) {
                                var f = x.isHorizontal() ? o.find(".swiper-slide-shadow-left") : o.find(".swiper-slide-shadow-top"),
                                    w = x.isHorizontal() ? o.find(".swiper-slide-shadow-right") : o.find(".swiper-slide-shadow-bottom");
                                0 === f.length && (f = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "left" : "top") + '"></div>'), o.append(f)), 0 === w.length && (w = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "right" : "bottom") + '"></div>'), o.append(w)), f.length && (f[0].style.opacity = d > 0 ? d : 0), w.length && (w[0].style.opacity = -d > 0 ? -d : 0)
                            }
                        }
                        if (x.browser.ie) { x.wrapper[0].style.perspectiveOrigin = t + "px 50%" }
                    },
                    setTransition: function(e) { x.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e) }
                }
            }, x.lazy = {
                initialImageLoaded: !1,
                loadImageInSlide: function(a, t) {
                    if (void 0 !== a && (void 0 === t && (t = !0), 0 !== x.slides.length)) {
                        var s = x.slides.eq(a),
                            r = s.find("." + x.params.lazyLoadingClass + ":not(." + x.params.lazyStatusLoadedClass + "):not(." + x.params.lazyStatusLoadingClass + ")");
                        !s.hasClass(x.params.lazyLoadingClass) || s.hasClass(x.params.lazyStatusLoadedClass) || s.hasClass(x.params.lazyStatusLoadingClass) || (r = r.add(s[0])), 0 !== r.length && r.each(function() {
                            var a = e(this);
                            a.addClass(x.params.lazyStatusLoadingClass);
                            var r = a.attr("data-background"),
                                i = a.attr("data-src"),
                                n = a.attr("data-srcset"),
                                o = a.attr("data-sizes");
                            x.loadImage(a[0], i || r, n, o, !1, function() {
                                if (void 0 !== x && null !== x && x) {
                                    if (r ? (a.css("background-image", 'url("' + r + '")'), a.removeAttr("data-background")) : (n && (a.attr("srcset", n), a.removeAttr("data-srcset")), o && (a.attr("sizes", o), a.removeAttr("data-sizes")), i && (a.attr("src", i), a.removeAttr("data-src"))), a.addClass(x.params.lazyStatusLoadedClass).removeClass(x.params.lazyStatusLoadingClass), s.find("." + x.params.lazyPreloaderClass + ", ." + x.params.preloaderClass).remove(), x.params.loop && t) {
                                        var e = s.attr("data-swiper-slide-index");
                                        if (s.hasClass(x.params.slideDuplicateClass)) {
                                            var l = x.wrapper.children('[data-swiper-slide-index="' + e + '"]:not(.' + x.params.slideDuplicateClass + ")");
                                            x.lazy.loadImageInSlide(l.index(), !1)
                                        } else {
                                            var p = x.wrapper.children("." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + e + '"]');
                                            x.lazy.loadImageInSlide(p.index(), !1)
                                        }
                                    }
                                    x.emit("onLazyImageReady", x, s[0], a[0])
                                }
                            }), x.emit("onLazyImageLoad", x, s[0], a[0])
                        })
                    }
                },
                load: function() {
                    var a, t = x.params.slidesPerView;
                    if ("auto" === t && (t = 0), x.lazy.initialImageLoaded || (x.lazy.initialImageLoaded = !0), x.params.watchSlidesVisibility) x.wrapper.children("." + x.params.slideVisibleClass).each(function() { x.lazy.loadImageInSlide(e(this).index()) });
                    else if (t > 1)
                        for (a = x.activeIndex; a < x.activeIndex + t; a++) x.slides[a] && x.lazy.loadImageInSlide(a);
                    else x.lazy.loadImageInSlide(x.activeIndex);
                    if (x.params.lazyLoadingInPrevNext)
                        if (t > 1 || x.params.lazyLoadingInPrevNextAmount && x.params.lazyLoadingInPrevNextAmount > 1) {
                            var s = x.params.lazyLoadingInPrevNextAmount,
                                r = t,
                                i = Math.min(x.activeIndex + r + Math.max(s, r), x.slides.length),
                                n = Math.max(x.activeIndex - Math.max(r, s), 0);
                            for (a = x.activeIndex + t; a < i; a++) x.slides[a] && x.lazy.loadImageInSlide(a);
                            for (a = n; a < x.activeIndex; a++) x.slides[a] && x.lazy.loadImageInSlide(a)
                        } else {
                            var o = x.wrapper.children("." + x.params.slideNextClass);
                            o.length > 0 && x.lazy.loadImageInSlide(o.index());
                            var l = x.wrapper.children("." + x.params.slidePrevClass);
                            l.length > 0 && x.lazy.loadImageInSlide(l.index())
                        }
                },
                onTransitionStart: function() { x.params.lazyLoading && (x.params.lazyLoadingOnTransitionStart || !x.params.lazyLoadingOnTransitionStart && !x.lazy.initialImageLoaded) && x.lazy.load() },
                onTransitionEnd: function() { x.params.lazyLoading && !x.params.lazyLoadingOnTransitionStart && x.lazy.load() }
            }, x.scrollbar = {
                isTouched: !1,
                setDragPosition: function(e) {
                    var a = x.scrollbar,
                        t = x.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX || e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY || e.clientY,
                        s = t - a.track.offset()[x.isHorizontal() ? "left" : "top"] - a.dragSize / 2,
                        r = -x.minTranslate() * a.moveDivider,
                        i = -x.maxTranslate() * a.moveDivider;
                    s < r ? s = r : s > i && (s = i), s = -s / a.moveDivider, x.updateProgress(s), x.setWrapperTranslate(s, !0)
                },
                dragStart: function(e) {
                    var a = x.scrollbar;
                    a.isTouched = !0, e.preventDefault(), e.stopPropagation(), a.setDragPosition(e), clearTimeout(a.dragTimeout), a.track.transition(0), x.params.scrollbarHide && a.track.css("opacity", 1), x.wrapper.transition(100), a.drag.transition(100), x.emit("onScrollbarDragStart", x)
                },
                dragMove: function(e) {
                    var a = x.scrollbar;
                    a.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, a.setDragPosition(e), x.wrapper.transition(0), a.track.transition(0), a.drag.transition(0), x.emit("onScrollbarDragMove", x))
                },
                dragEnd: function(e) {
                    var a = x.scrollbar;
                    a.isTouched && (a.isTouched = !1, x.params.scrollbarHide && (clearTimeout(a.dragTimeout), a.dragTimeout = setTimeout(function() { a.track.css("opacity", 0), a.track.transition(400) }, 1e3)), x.emit("onScrollbarDragEnd", x), x.params.scrollbarSnapOnRelease && x.slideReset())
                },
                draggableEvents: function() { return x.params.simulateTouch !== !1 || x.support.touch ? x.touchEvents : x.touchEventsDesktop }(),
                enableDraggable: function() {
                    var a = x.scrollbar,
                        t = x.support.touch ? a.track : document;
                    e(a.track).on(a.draggableEvents.start, a.dragStart), e(t).on(a.draggableEvents.move, a.dragMove), e(t).on(a.draggableEvents.end, a.dragEnd)
                },
                disableDraggable: function() {
                    var a = x.scrollbar,
                        t = x.support.touch ? a.track : document;
                    e(a.track).off(a.draggableEvents.start, a.dragStart), e(t).off(a.draggableEvents.move, a.dragMove), e(t).off(a.draggableEvents.end, a.dragEnd)
                },
                set: function() {
                    if (x.params.scrollbar) {
                        var a = x.scrollbar;
                        a.track = e(x.params.scrollbar), x.params.uniqueNavElements && "string" == typeof x.params.scrollbar && a.track.length > 1 && 1 === x.container.find(x.params.scrollbar).length && (a.track = x.container.find(x.params.scrollbar)), a.drag = a.track.find(".swiper-scrollbar-drag"), 0 === a.drag.length && (a.drag = e('<div class="swiper-scrollbar-drag"></div>'), a.track.append(a.drag)), a.drag[0].style.width = "", a.drag[0].style.height = "", a.trackSize = x.isHorizontal() ? a.track[0].offsetWidth : a.track[0].offsetHeight, a.divider = x.size / x.virtualSize, a.moveDivider = a.divider * (a.trackSize / x.size), a.dragSize = a.trackSize * a.divider, x.isHorizontal() ? a.drag[0].style.width = a.dragSize + "px" : a.drag[0].style.height = a.dragSize + "px", a.divider >= 1 ? a.track[0].style.display = "none" : a.track[0].style.display = "", x.params.scrollbarHide && (a.track[0].style.opacity = 0)
                    }
                },
                setTranslate: function() {
                    if (x.params.scrollbar) {
                        var e, a = x.scrollbar,
                            t = (x.translate, a.dragSize);
                        e = (a.trackSize - a.dragSize) * x.progress, x.rtl && x.isHorizontal() ? (e = -e, e > 0 ? (t = a.dragSize - e, e = 0) : -e + a.dragSize > a.trackSize && (t = a.trackSize + e)) : e < 0 ? (t = a.dragSize + e, e = 0) : e + a.dragSize > a.trackSize && (t = a.trackSize - e), x.isHorizontal() ? (x.support.transforms3d ? a.drag.transform("translate3d(" + e + "px, 0, 0)") : a.drag.transform("translateX(" + e + "px)"), a.drag[0].style.width = t + "px") : (x.support.transforms3d ? a.drag.transform("translate3d(0px, " + e + "px, 0)") : a.drag.transform("translateY(" + e + "px)"), a.drag[0].style.height = t + "px"), x.params.scrollbarHide && (clearTimeout(a.timeout), a.track[0].style.opacity = 1, a.timeout = setTimeout(function() { a.track[0].style.opacity = 0, a.track.transition(400) }, 1e3))
                    }
                },
                setTransition: function(e) { x.params.scrollbar && x.scrollbar.drag.transition(e) }
            }, x.controller = {
                LinearSpline: function(e, a) {
                    var t = function() { var e, a, t; return function(s, r) { for (a = -1, e = s.length; e - a > 1;) s[t = e + a >> 1] <= r ? a = t : e = t; return e } }();
                    this.x = e, this.y = a, this.lastIndex = e.length - 1;
                    var s, r;
                    this.x.length;
                    this.interpolate = function(e) { return e ? (r = t(this.x, e), s = r - 1, (e - this.x[s]) * (this.y[r] - this.y[s]) / (this.x[r] - this.x[s]) + this.y[s]) : 0 }
                },
                getInterpolateFunction: function(e) { x.controller.spline || (x.controller.spline = x.params.loop ? new x.controller.LinearSpline(x.slidesGrid, e.slidesGrid) : new x.controller.LinearSpline(x.snapGrid, e.snapGrid)) },
                setTranslate: function(e, t) {
                    function s(a) { e = a.rtl && "horizontal" === a.params.direction ? -x.translate : x.translate, "slide" === x.params.controlBy && (x.controller.getInterpolateFunction(a), i = -x.controller.spline.interpolate(-e)), i && "container" !== x.params.controlBy || (r = (a.maxTranslate() - a.minTranslate()) / (x.maxTranslate() - x.minTranslate()), i = (e - x.minTranslate()) * r + a.minTranslate()), x.params.controlInverse && (i = a.maxTranslate() - i), a.updateProgress(i), a.setWrapperTranslate(i, !1, x), a.updateActiveIndex() }
                    var r, i, n = x.params.control;
                    if (Array.isArray(n))
                        for (var o = 0; o < n.length; o++) n[o] !== t && n[o] instanceof a && s(n[o]);
                    else n instanceof a && t !== n && s(n)
                },
                setTransition: function(e, t) {
                    function s(a) { a.setWrapperTransition(e, x), 0 !== e && (a.onTransitionStart(), a.wrapper.transitionEnd(function() { i && (a.params.loop && "slide" === x.params.controlBy && a.fixLoop(), a.onTransitionEnd()) })) }
                    var r, i = x.params.control;
                    if (Array.isArray(i))
                        for (r = 0; r < i.length; r++) i[r] !== t && i[r] instanceof a && s(i[r]);
                    else i instanceof a && t !== i && s(i)
                }
            }, x.hashnav = {
                onHashCange: function(e, a) {
                    var t = document.location.hash.replace("#", "");
                    t !== x.slides.eq(x.activeIndex).attr("data-hash") && x.slideTo(x.wrapper.children("." + x.params.slideClass + '[data-hash="' + t + '"]').index())
                },
                attachEvents: function(a) {
                    var t = a ? "off" : "on";
                    e(window)[t]("hashchange", x.hashnav.onHashCange)
                },
                setHash: function() {
                    if (x.hashnav.initialized && x.params.hashnav)
                        if (x.params.replaceState && window.history && window.history.replaceState) window.history.replaceState(null, null, "#" + x.slides.eq(x.activeIndex).attr("data-hash") || "");
                        else {
                            var e = x.slides.eq(x.activeIndex),
                                a = e.attr("data-hash") || e.attr("data-history");
                            document.location.hash = a || ""
                        }
                },
                init: function() {
                    if (x.params.hashnav && !x.params.history) {
                        x.hashnav.initialized = !0;
                        var e = document.location.hash.replace("#", "");
                        if (e)
                            for (var a = 0, t = x.slides.length; a < t; a++) {
                                var s = x.slides.eq(a),
                                    r = s.attr("data-hash") || s.attr("data-history");
                                if (r === e && !s.hasClass(x.params.slideDuplicateClass)) {
                                    var i = s.index();
                                    x.slideTo(i, 0, x.params.runCallbacksOnInit, !0)
                                }
                            }
                        x.params.hashnavWatchState && x.hashnav.attachEvents()
                    }
                },
                destroy: function() { x.params.hashnavWatchState && x.hashnav.attachEvents(!0) }
            }, x.history = {
                init: function() {
                    if (x.params.history) {
                        if (!window.history || !window.history.pushState) return x.params.history = !1, void(x.params.hashnav = !0);
                        x.history.initialized = !0, this.paths = this.getPathValues(), (this.paths.key || this.paths.value) && (this.scrollToSlide(0, this.paths.value, x.params.runCallbacksOnInit), x.params.replaceState || window.addEventListener("popstate", this.setHistoryPopState))
                    }
                },
                setHistoryPopState: function() { x.history.paths = x.history.getPathValues(), x.history.scrollToSlide(x.params.speed, x.history.paths.value, !1) },
                getPathValues: function() {
                    var e = window.location.pathname.slice(1).split("/"),
                        a = e.length;
                    return { key: e[a - 2], value: e[a - 1] }
                },
                setHistory: function(e, a) {
                    if (x.history.initialized && x.params.history) {
                        var t = x.slides.eq(a),
                            s = this.slugify(t.attr("data-history"));
                        window.location.pathname.includes(e) || (s = e + "/" + s), x.params.replaceState ? window.history.replaceState(null, null, s) : window.history.pushState(null, null, s)
                    }
                },
                slugify: function(e) { return e.toString().toLowerCase().replace(/\s+/g, "-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "") },
                scrollToSlide: function(e, a, t) {
                    if (a)
                        for (var s = 0, r = x.slides.length; s < r; s++) {
                            var i = x.slides.eq(s),
                                n = this.slugify(i.attr("data-history"));
                            if (n === a && !i.hasClass(x.params.slideDuplicateClass)) {
                                var o = i.index();
                                x.slideTo(o, e, t)
                            }
                        } else x.slideTo(0, e, t)
                }
            }, x.disableKeyboardControl = function() { x.params.keyboardControl = !1, e(document).off("keydown", l) }, x.enableKeyboardControl = function() { x.params.keyboardControl = !0, e(document).on("keydown", l) }, x.mousewheel = { event: !1, lastScrollTime: (new window.Date).getTime() }, x.params.mousewheelControl && (x.mousewheel.event = navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : function() {
                var e = "onwheel" in document;
                if (!e) {
                    var a = document.createElement("div");
                    a.setAttribute("onwheel", "return;"), e = "function" == typeof a.onwheel
                }
                return !e && document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0 && (e = document.implementation.hasFeature("Events.wheel", "3.0")), e
            }() ? "wheel" : "mousewheel"), x.disableMousewheelControl = function() { if (!x.mousewheel.event) return !1; var a = x.container; return "container" !== x.params.mousewheelEventsTarged && (a = e(x.params.mousewheelEventsTarged)), a.off(x.mousewheel.event, d), x.params.mousewheelControl = !1, !0 }, x.enableMousewheelControl = function() { if (!x.mousewheel.event) return !1; var a = x.container; return "container" !== x.params.mousewheelEventsTarged && (a = e(x.params.mousewheelEventsTarged)), a.on(x.mousewheel.event, d), x.params.mousewheelControl = !0, !0 }, x.parallax = {
                setTranslate: function() {
                    x.container.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() { m(this, x.progress) }), x.slides.each(function() {
                        var a = e(this);
                        a.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() { m(this, Math.min(Math.max(a[0].progress, -1), 1)) })
                    })
                },
                setTransition: function(a) {
                    void 0 === a && (a = x.params.speed), x.container.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() {
                        var t = e(this),
                            s = parseInt(t.attr("data-swiper-parallax-duration"), 10) || a;
                        0 === a && (s = 0), t.transition(s)
                    })
                }
            }, x.zoom = {
                scale: 1,
                currentScale: 1,
                isScaling: !1,
                gesture: { slide: void 0, slideWidth: void 0, slideHeight: void 0, image: void 0, imageWrap: void 0, zoomMax: x.params.zoomMax },
                image: { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} },
                velocity: { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 },
                getDistanceBetweenTouches: function(e) {
                    if (e.targetTouches.length < 2) return 1;
                    var a = e.targetTouches[0].pageX,
                        t = e.targetTouches[0].pageY,
                        s = e.targetTouches[1].pageX,
                        r = e.targetTouches[1].pageY;
                    return Math.sqrt(Math.pow(s - a, 2) + Math.pow(r - t, 2))
                },
                onGestureStart: function(a) {
                    var t = x.zoom;
                    if (!x.support.gestures) {
                        if ("touchstart" !== a.type || "touchstart" === a.type && a.targetTouches.length < 2) return;
                        t.gesture.scaleStart = t.getDistanceBetweenTouches(a)
                    }
                    if (!(t.gesture.slide && t.gesture.slide.length || (t.gesture.slide = e(this), 0 === t.gesture.slide.length && (t.gesture.slide = x.slides.eq(x.activeIndex)), t.gesture.image = t.gesture.slide.find("img, svg, canvas"), t.gesture.imageWrap = t.gesture.image.parent("." + x.params.zoomContainerClass), t.gesture.zoomMax = t.gesture.imageWrap.attr("data-swiper-zoom") || x.params.zoomMax, 0 !== t.gesture.imageWrap.length))) return void(t.gesture.image = void 0);
                    t.gesture.image.transition(0), t.isScaling = !0
                },
                onGestureChange: function(e) {
                    var a = x.zoom;
                    if (!x.support.gestures) {
                        if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
                        a.gesture.scaleMove = a.getDistanceBetweenTouches(e)
                    }
                    a.gesture.image && 0 !== a.gesture.image.length && (x.support.gestures ? a.scale = e.scale * a.currentScale : a.scale = a.gesture.scaleMove / a.gesture.scaleStart * a.currentScale, a.scale > a.gesture.zoomMax && (a.scale = a.gesture.zoomMax - 1 + Math.pow(a.scale - a.gesture.zoomMax + 1, .5)), a.scale < x.params.zoomMin && (a.scale = x.params.zoomMin + 1 - Math.pow(x.params.zoomMin - a.scale + 1, .5)), a.gesture.image.transform("translate3d(0,0,0) scale(" + a.scale + ")"))
                },
                onGestureEnd: function(e) { var a = x.zoom;!x.support.gestures && ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2) || a.gesture.image && 0 !== a.gesture.image.length && (a.scale = Math.max(Math.min(a.scale, a.gesture.zoomMax), x.params.zoomMin), a.gesture.image.transition(x.params.speed).transform("translate3d(0,0,0) scale(" + a.scale + ")"), a.currentScale = a.scale, a.isScaling = !1, 1 === a.scale && (a.gesture.slide = void 0)) },
                onTouchStart: function(e, a) {
                    var t = e.zoom;
                    t.gesture.image && 0 !== t.gesture.image.length && (t.image.isTouched || ("android" === e.device.os && a.preventDefault(), t.image.isTouched = !0, t.image.touchesStart.x = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX, t.image.touchesStart.y = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY))
                },
                onTouchMove: function(e) {
                    var a = x.zoom;
                    if (a.gesture.image && 0 !== a.gesture.image.length && (x.allowClick = !1, a.image.isTouched && a.gesture.slide)) {
                        a.image.isMoved || (a.image.width = a.gesture.image[0].offsetWidth, a.image.height = a.gesture.image[0].offsetHeight, a.image.startX = x.getTranslate(a.gesture.imageWrap[0], "x") || 0, a.image.startY = x.getTranslate(a.gesture.imageWrap[0], "y") || 0, a.gesture.slideWidth = a.gesture.slide[0].offsetWidth, a.gesture.slideHeight = a.gesture.slide[0].offsetHeight, a.gesture.imageWrap.transition(0), x.rtl && (a.image.startX = -a.image.startX), x.rtl && (a.image.startY = -a.image.startY));
                        var t = a.image.width * a.scale,
                            s = a.image.height * a.scale;
                        if (!(t < a.gesture.slideWidth && s < a.gesture.slideHeight)) {
                            if (a.image.minX = Math.min(a.gesture.slideWidth / 2 - t / 2, 0), a.image.maxX = -a.image.minX, a.image.minY = Math.min(a.gesture.slideHeight / 2 - s / 2, 0), a.image.maxY = -a.image.minY, a.image.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, a.image.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !a.image.isMoved && !a.isScaling) { if (x.isHorizontal() && Math.floor(a.image.minX) === Math.floor(a.image.startX) && a.image.touchesCurrent.x < a.image.touchesStart.x || Math.floor(a.image.maxX) === Math.floor(a.image.startX) && a.image.touchesCurrent.x > a.image.touchesStart.x) return void(a.image.isTouched = !1); if (!x.isHorizontal() && Math.floor(a.image.minY) === Math.floor(a.image.startY) && a.image.touchesCurrent.y < a.image.touchesStart.y || Math.floor(a.image.maxY) === Math.floor(a.image.startY) && a.image.touchesCurrent.y > a.image.touchesStart.y) return void(a.image.isTouched = !1) }
                            e.preventDefault(), e.stopPropagation(), a.image.isMoved = !0, a.image.currentX = a.image.touchesCurrent.x - a.image.touchesStart.x + a.image.startX, a.image.currentY = a.image.touchesCurrent.y - a.image.touchesStart.y + a.image.startY, a.image.currentX < a.image.minX && (a.image.currentX = a.image.minX + 1 - Math.pow(a.image.minX - a.image.currentX + 1, .8)), a.image.currentX > a.image.maxX && (a.image.currentX = a.image.maxX - 1 + Math.pow(a.image.currentX - a.image.maxX + 1, .8)), a.image.currentY < a.image.minY && (a.image.currentY = a.image.minY + 1 - Math.pow(a.image.minY - a.image.currentY + 1, .8)), a.image.currentY > a.image.maxY && (a.image.currentY = a.image.maxY - 1 + Math.pow(a.image.currentY - a.image.maxY + 1, .8)), a.velocity.prevPositionX || (a.velocity.prevPositionX = a.image.touchesCurrent.x), a.velocity.prevPositionY || (a.velocity.prevPositionY = a.image.touchesCurrent.y), a.velocity.prevTime || (a.velocity.prevTime = Date.now()), a.velocity.x = (a.image.touchesCurrent.x - a.velocity.prevPositionX) / (Date.now() - a.velocity.prevTime) / 2, a.velocity.y = (a.image.touchesCurrent.y - a.velocity.prevPositionY) / (Date.now() - a.velocity.prevTime) / 2, Math.abs(a.image.touchesCurrent.x - a.velocity.prevPositionX) < 2 && (a.velocity.x = 0), Math.abs(a.image.touchesCurrent.y - a.velocity.prevPositionY) < 2 && (a.velocity.y = 0), a.velocity.prevPositionX = a.image.touchesCurrent.x, a.velocity.prevPositionY = a.image.touchesCurrent.y, a.velocity.prevTime = Date.now(), a.gesture.imageWrap.transform("translate3d(" + a.image.currentX + "px, " + a.image.currentY + "px,0)")
                        }
                    }
                },
                onTouchEnd: function(e, a) {
                    var t = e.zoom;
                    if (t.gesture.image && 0 !== t.gesture.image.length) {
                        if (!t.image.isTouched || !t.image.isMoved) return t.image.isTouched = !1, void(t.image.isMoved = !1);
                        t.image.isTouched = !1, t.image.isMoved = !1;
                        var s = 300,
                            r = 300,
                            i = t.velocity.x * s,
                            n = t.image.currentX + i,
                            o = t.velocity.y * r,
                            l = t.image.currentY + o;
                        0 !== t.velocity.x && (s = Math.abs((n - t.image.currentX) / t.velocity.x)), 0 !== t.velocity.y && (r = Math.abs((l - t.image.currentY) / t.velocity.y));
                        var p = Math.max(s, r);
                        t.image.currentX = n, t.image.currentY = l;
                        var d = t.image.width * t.scale,
                            m = t.image.height * t.scale;
                        t.image.minX = Math.min(t.gesture.slideWidth / 2 - d / 2, 0), t.image.maxX = -t.image.minX, t.image.minY = Math.min(t.gesture.slideHeight / 2 - m / 2, 0), t.image.maxY = -t.image.minY, t.image.currentX = Math.max(Math.min(t.image.currentX, t.image.maxX), t.image.minX), t.image.currentY = Math.max(Math.min(t.image.currentY, t.image.maxY), t.image.minY), t.gesture.imageWrap.transition(p).transform("translate3d(" + t.image.currentX + "px, " + t.image.currentY + "px,0)")
                    }
                },
                onTransitionEnd: function(e) {
                    var a = e.zoom;
                    a.gesture.slide && e.previousIndex !== e.activeIndex && (a.gesture.image.transform("translate3d(0,0,0) scale(1)"), a.gesture.imageWrap.transform("translate3d(0,0,0)"), a.gesture.slide = a.gesture.image = a.gesture.imageWrap = void 0, a.scale = a.currentScale = 1)
                },
                toggleZoom: function(a, t) {
                    var s = a.zoom;
                    if (s.gesture.slide || (s.gesture.slide = a.clickedSlide ? e(a.clickedSlide) : a.slides.eq(a.activeIndex), s.gesture.image = s.gesture.slide.find("img, svg, canvas"), s.gesture.imageWrap = s.gesture.image.parent("." + a.params.zoomContainerClass)), s.gesture.image && 0 !== s.gesture.image.length) {
                        var r, i, n, o, l, p, d, m, u, c, g, h, v, f, w, y, x, T;
                        void 0 === s.image.touchesStart.x && t ? (r = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, i = "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (r = s.image.touchesStart.x, i = s.image.touchesStart.y), s.scale && 1 !== s.scale ? (s.scale = s.currentScale = 1, s.gesture.imageWrap.transition(300).transform("translate3d(0,0,0)"), s.gesture.image.transition(300).transform("translate3d(0,0,0) scale(1)"), s.gesture.slide = void 0) : (s.scale = s.currentScale = s.gesture.imageWrap.attr("data-swiper-zoom") || a.params.zoomMax, t ? (x = s.gesture.slide[0].offsetWidth, T = s.gesture.slide[0].offsetHeight, n = s.gesture.slide.offset().left, o = s.gesture.slide.offset().top, l = n + x / 2 - r, p = o + T / 2 - i, u = s.gesture.image[0].offsetWidth, c = s.gesture.image[0].offsetHeight, g = u * s.scale, h = c * s.scale, v = Math.min(x / 2 - g / 2, 0), f = Math.min(T / 2 - h / 2, 0), w = -v, y = -f, d = l * s.scale, m = p * s.scale, d < v && (d = v), d > w && (d = w), m < f && (m = f), m > y && (m = y)) : (d = 0, m = 0), s.gesture.imageWrap.transition(300).transform("translate3d(" + d + "px, " + m + "px,0)"), s.gesture.image.transition(300).transform("translate3d(0,0,0) scale(" + s.scale + ")"))
                    }
                },
                attachEvents: function(a) {
                    var t = a ? "off" : "on";
                    if (x.params.zoom) {
                        var s = (x.slides, !("touchstart" !== x.touchEvents.start || !x.support.passiveListener || !x.params.passiveListeners) && { passive: !0, capture: !1 });
                        x.support.gestures ? (x.slides[t]("gesturestart", x.zoom.onGestureStart, s), x.slides[t]("gesturechange", x.zoom.onGestureChange, s), x.slides[t]("gestureend", x.zoom.onGestureEnd, s)) : "touchstart" === x.touchEvents.start && (x.slides[t](x.touchEvents.start, x.zoom.onGestureStart, s), x.slides[t](x.touchEvents.move, x.zoom.onGestureChange, s), x.slides[t](x.touchEvents.end, x.zoom.onGestureEnd, s)), x[t]("touchStart", x.zoom.onTouchStart), x.slides.each(function(a, s) { e(s).find("." + x.params.zoomContainerClass).length > 0 && e(s)[t](x.touchEvents.move, x.zoom.onTouchMove) }), x[t]("touchEnd", x.zoom.onTouchEnd), x[t]("transitionEnd", x.zoom.onTransitionEnd), x.params.zoomToggle && x.on("doubleTap", x.zoom.toggleZoom)
                    }
                },
                init: function() { x.zoom.attachEvents() },
                destroy: function() { x.zoom.attachEvents(!0) }
            }, x._plugins = [];
            for (var Y in x.plugins) {
                var A = x.plugins[Y](x, x.params[Y]);
                A && x._plugins.push(A)
            }
            return x.callPlugins = function(e) { for (var a = 0; a < x._plugins.length; a++) e in x._plugins[a] && x._plugins[a][e](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]) }, x.emitterEventListeners = {}, x.emit = function(e) {
                x.params[e] && x.params[e](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                var a;
                if (x.emitterEventListeners[e])
                    for (a = 0; a < x.emitterEventListeners[e].length; a++) x.emitterEventListeners[e][a](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                x.callPlugins && x.callPlugins(e, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5])
            }, x.on = function(e, a) { return e = u(e), x.emitterEventListeners[e] || (x.emitterEventListeners[e] = []), x.emitterEventListeners[e].push(a), x }, x.off = function(e, a) { var t; if (e = u(e), void 0 === a) return x.emitterEventListeners[e] = [], x; if (x.emitterEventListeners[e] && 0 !== x.emitterEventListeners[e].length) { for (t = 0; t < x.emitterEventListeners[e].length; t++) x.emitterEventListeners[e][t] === a && x.emitterEventListeners[e].splice(t, 1); return x } }, x.once = function(e, a) { e = u(e); var t = function() { a(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]), x.off(e, t) }; return x.on(e, t), x }, x.a11y = {
                makeFocusable: function(e) { return e.attr("tabIndex", "0"), e },
                addRole: function(e, a) { return e.attr("role", a), e },
                addLabel: function(e, a) { return e.attr("aria-label", a), e },
                disable: function(e) { return e.attr("aria-disabled", !0), e },
                enable: function(e) { return e.attr("aria-disabled", !1), e },
                onEnterKey: function(a) { 13 === a.keyCode && (e(a.target).is(x.params.nextButton) ? (x.onClickNext(a), x.isEnd ? x.a11y.notify(x.params.lastSlideMessage) : x.a11y.notify(x.params.nextSlideMessage)) : e(a.target).is(x.params.prevButton) && (x.onClickPrev(a), x.isBeginning ? x.a11y.notify(x.params.firstSlideMessage) : x.a11y.notify(x.params.prevSlideMessage)), e(a.target).is("." + x.params.bulletClass) && e(a.target)[0].click()) },
                liveRegion: e('<span class="' + x.params.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>'),
                notify: function(e) {
                    var a = x.a11y.liveRegion;
                    0 !== a.length && (a.html(""), a.html(e))
                },
                init: function() { x.params.nextButton && x.nextButton && x.nextButton.length > 0 && (x.a11y.makeFocusable(x.nextButton), x.a11y.addRole(x.nextButton, "button"), x.a11y.addLabel(x.nextButton, x.params.nextSlideMessage)), x.params.prevButton && x.prevButton && x.prevButton.length > 0 && (x.a11y.makeFocusable(x.prevButton), x.a11y.addRole(x.prevButton, "button"), x.a11y.addLabel(x.prevButton, x.params.prevSlideMessage)), e(x.container).append(x.a11y.liveRegion) },
                initPagination: function() {
                    x.params.pagination && x.params.paginationClickable && x.bullets && x.bullets.length && x.bullets.each(function() {
                        var a = e(this);
                        x.a11y.makeFocusable(a), x.a11y.addRole(a, "button"), x.a11y.addLabel(a, x.params.paginationBulletMessage.replace(/{{index}}/, a.index() + 1))
                    })
                },
                destroy: function() { x.a11y.liveRegion && x.a11y.liveRegion.length > 0 && x.a11y.liveRegion.remove() }
            }, x.init = function() { x.params.loop && x.createLoop(), x.updateContainerSize(), x.updateSlidesSize(), x.updatePagination(), x.params.scrollbar && x.scrollbar && (x.scrollbar.set(), x.params.scrollbarDraggable && x.scrollbar.enableDraggable()), "slide" !== x.params.effect && x.effects[x.params.effect] && (x.params.loop || x.updateProgress(), x.effects[x.params.effect].setTranslate()), x.params.loop ? x.slideTo(x.params.initialSlide + x.loopedSlides, 0, x.params.runCallbacksOnInit) : (x.slideTo(x.params.initialSlide, 0, x.params.runCallbacksOnInit), 0 === x.params.initialSlide && (x.parallax && x.params.parallax && x.parallax.setTranslate(), x.lazy && x.params.lazyLoading && (x.lazy.load(), x.lazy.initialImageLoaded = !0))), x.attachEvents(), x.params.observer && x.support.observer && x.initObservers(), x.params.preloadImages && !x.params.lazyLoading && x.preloadImages(), x.params.zoom && x.zoom && x.zoom.init(), x.params.autoplay && x.startAutoplay(), x.params.keyboardControl && x.enableKeyboardControl && x.enableKeyboardControl(), x.params.mousewheelControl && x.enableMousewheelControl && x.enableMousewheelControl(), x.params.hashnavReplaceState && (x.params.replaceState = x.params.hashnavReplaceState), x.params.history && x.history && x.history.init(), x.params.hashnav && x.hashnav && x.hashnav.init(), x.params.a11y && x.a11y && x.a11y.init(), x.emit("onInit", x) }, x.cleanupStyles = function() { x.container.removeClass(x.classNames.join(" ")).removeAttr("style"), x.wrapper.removeAttr("style"), x.slides && x.slides.length && x.slides.removeClass([x.params.slideVisibleClass, x.params.slideActiveClass, x.params.slideNextClass, x.params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-column").removeAttr("data-swiper-row"), x.paginationContainer && x.paginationContainer.length && x.paginationContainer.removeClass(x.params.paginationHiddenClass), x.bullets && x.bullets.length && x.bullets.removeClass(x.params.bulletActiveClass), x.params.prevButton && e(x.params.prevButton).removeClass(x.params.buttonDisabledClass), x.params.nextButton && e(x.params.nextButton).removeClass(x.params.buttonDisabledClass), x.params.scrollbar && x.scrollbar && (x.scrollbar.track && x.scrollbar.track.length && x.scrollbar.track.removeAttr("style"), x.scrollbar.drag && x.scrollbar.drag.length && x.scrollbar.drag.removeAttr("style")) }, x.destroy = function(e, a) { x.detachEvents(), x.stopAutoplay(), x.params.scrollbar && x.scrollbar && x.params.scrollbarDraggable && x.scrollbar.disableDraggable(), x.params.loop && x.destroyLoop(), a && x.cleanupStyles(), x.disconnectObservers(), x.params.zoom && x.zoom && x.zoom.destroy(), x.params.keyboardControl && x.disableKeyboardControl && x.disableKeyboardControl(), x.params.mousewheelControl && x.disableMousewheelControl && x.disableMousewheelControl(), x.params.a11y && x.a11y && x.a11y.destroy(), x.params.history && !x.params.replaceState && window.removeEventListener("popstate", x.history.setHistoryPopState), x.params.hashnav && x.hashnav && x.hashnav.destroy(), x.emit("onDestroy"), e !== !1 && (x = null) }, x.init(), x
        }
    };
    a.prototype = {
        isSafari: function() { var e = window.navigator.userAgent.toLowerCase(); return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0 }(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
        isArray: function(e) { return "[object Array]" === Object.prototype.toString.apply(e) },
        browser: { ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled, ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1, lteIE9: function() { var e = document.createElement("div"); return e.innerHTML = "<!--[if lte IE 9]><i></i><![endif]-->", 1 === e.getElementsByTagName("i").length }() },
        device: function() {
            var e = window.navigator.userAgent,
                a = e.match(/(Android);?[\s\/]+([\d.]+)?/),
                t = e.match(/(iPad).*OS\s([\d_]+)/),
                s = e.match(/(iPod)(.*OS\s([\d_]+))?/),
                r = !t && e.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            return { ios: t || r || s, android: a }
        }(),
        support: {
            touch: window.Modernizr && Modernizr.touch === !0 || function() { return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) }(),
            transforms3d: window.Modernizr && Modernizr.csstransforms3d === !0 || function() { var e = document.createElement("div").style; return "webkitPerspective" in e || "MozPerspective" in e || "OPerspective" in e || "MsPerspective" in e || "perspective" in e }(),
            flexbox: function() {
                for (var e = document.createElement("div").style, a = "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" "), t = 0; t < a.length; t++)
                    if (a[t] in e) return !0
            }(),
            observer: function() { return "MutationObserver" in window || "WebkitMutationObserver" in window }(),
            passiveListener: function() {
                var e = !1;
                try {
                    var a = Object.defineProperty({}, "passive", { get: function() { e = !0 } });
                    window.addEventListener("testPassiveListener", null, a)
                } catch (e) {}
                return e
            }(),
            gestures: function() { return "ongesturestart" in window }()
        },
        plugins: {}
    };
    for (var t = ["jQuery", "Zepto", "Dom7"], s = 0; s < t.length; s++) window[t[s]] && function(e) {
        e.fn.swiper = function(t) {
            var s;
            return e(this).each(function() {
                var e = new a(this, t);
                s || (s = e)
            }), s
        }
    }(window[t[s]]);
    var r;
    r = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7, r && ("transitionEnd" in r.fn || (r.fn.transitionEnd = function(e) {
        function a(i) {
            if (i.target === this)
                for (e.call(this, i), t = 0; t < s.length; t++) r.off(s[t], a)
        }
        var t, s = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"],
            r = this;
        if (e)
            for (t = 0; t < s.length; t++) r.on(s[t], a);
        return this
    }), "transform" in r.fn || (r.fn.transform = function(e) {
        for (var a = 0; a < this.length; a++) {
            var t = this[a].style;
            t.webkitTransform = t.MsTransform = t.msTransform = t.MozTransform = t.OTransform = t.transform = e
        }
        return this
    }), "transition" in r.fn || (r.fn.transition = function(e) {
        "string" != typeof e && (e += "ms");
        for (var a = 0; a < this.length; a++) {
            var t = this[a].style;
            t.webkitTransitionDuration = t.MsTransitionDuration = t.msTransitionDuration = t.MozTransitionDuration = t.OTransitionDuration = t.transitionDuration = e
        }
        return this
    }), "outerWidth" in r.fn || (r.fn.outerWidth = function(e) { return this.length > 0 ? e ? this[0].offsetWidth + parseFloat(this.css("margin-right")) + parseFloat(this.css("margin-left")) : this[0].offsetWidth : null })), window.Swiper = a
}(), "undefined" != typeof module ? module.exports = window.Swiper : "function" == typeof define && define.amd && define([], function() { "use strict"; return window.Swiper });
//# sourceMappingURL=maps/swiper.jquery.min.js.map
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyI7XHJcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gJCgnLm1haW5Db250ZW50JykuY3NzKCdtaW4taGVpZ2h0JywgKCQod2luZG93KS5vdXRlckhlaWdodCgpIC0gJChcIi5mb290ZXJcIikub3V0ZXJIZWlnaHQoKSkgLSAkKFwiLmhlYWRlclwiKS5vdXRlckhlaWdodCgpKTtcclxuICAgIGNhdGFsb2dGaWx0ZXJzKCk7XHJcbiAgICBoZWFkZXJNZW51SXRlbUhvdmVyKCk7XHJcbiAgICBjYXRhbG9nQ2hlY2tCb3goKTtcclxuICAgIGNhdGFsb2dBY2NvcmRpb24oKTtcclxuICAgIGNhdGFsb2dTb3J0aW5nKCk7XHJcbiAgICBwcm9kdWN0UGhvdG9HYWxlcnkoKTtcclxuICAgIHByb2R1Y3RNb3JlVGFibGVSb3dDb2xvcigpO1xyXG4gICAgcHJvZHVjdE1vcmVUYWIoKTtcclxuICAgIG9yZGVyRm9ybSgpO1xyXG4gICAgZm9vdGVyTWVudSgpO1xyXG4gICAgJCgnaW1nJykub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9KTtcclxuICAgIGhTY3JvbGwoJCgnLmhlYWRlcl9fY2F0YWxvZ0l0ZW0nKSwgJCgnLmhlYWRlcl9fY2F0YWxvZycpKTtcclxuICAgIGhTY3JvbGwoJCgnLnBvcnRmb2xpb19faXRlbScpLCAkKCcucG9ydGZvbGlvX19pdGVtQm94JykpO1xyXG4gICAgaFNjcm9sbCgkKCcucHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVPdGhlckNhc2UgJyksICQoJy5wcm9kdWN0TW9yZV9fZ2FsZXJ5UGljdHVyZU90aGVyQm94JykpO1xyXG5cclxuICAgIG1lZGlhQ2VudGVyKDUsICQoJy53aHlXZV9fYmVsaWVmJyksICQoJy53aHlXZV9fYmVsaWVmcycpLCAkKCcudG90YWxXaWR0aCcpKTtcclxuICAgIG1lZGlhQ2VudGVyKDMsICQoJy5jYXRhbG9nX19pdGVtJyksICQoJy5jYXRhbG9nX19pdGVtcycpLCAkKCcuY2F0YWxvZ19fbWFpblNlY3Rpb24nKSk7XHJcbiAgICBtZWRpYUNlbnRlcig0LCAkKCcuY2F0YWxvZ19faXRlbScpLCAkKCcuY2F0YWxvZ19faXRlbXMnKSwgJCgnLmNhdGFsb2dfX21haW5TZWN0aW9uLS1mdWxsJykpO1xyXG5cclxuICAgIGlmICgkKHdpbmRvdykub3V0ZXJXaWR0aCgpIDw9IDEwMjMpIHtcclxuICAgICAgICBtZWRpYUNlbnRlcig4LCAkKCcuZm9vdGVyX19wYXltZW50TGluaycpLCAkKCcuZm9vdGVyX19wYXltZW50TGlua3MnKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgbXlTd2lwZXIgPSBuZXcgU3dpcGVyKCcuc3dpcGVyMicsIHtcclxuICAgICAgICBwYWdpbmF0aW9uOiAnLnN3aXBlci1wYWdpbmF0aW9uJyxcclxuICAgICAgICBwYWdpbmF0aW9uQ2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgIHBhZ2luYXRpb25FbGVtZW50OiAnbGknXHJcbiAgICB9KTtcclxuICAgIC8vIGNhdGFsb2dGaWx0ZXJCb3goKTtcclxufSk7XHJcblxyXG4kKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCkge1xyXG4gICAgbWVkaWFDZW50ZXIoNSwgJCgnLndoeVdlX19iZWxpZWYnKSwgJCgnLndoeVdlX19iZWxpZWZzJyksICQoJy50b3RhbFdpZHRoJykpO1xyXG4gICAgbWVkaWFDZW50ZXIoMywgJCgnLmNhdGFsb2dfX2l0ZW0nKSwgJCgnLmNhdGFsb2dfX2l0ZW1zJyksICQoJy5jYXRhbG9nX19tYWluU2VjdGlvbicpKTtcclxuICAgIG1lZGlhQ2VudGVyKDQsICQoJy5jYXRhbG9nX19pdGVtJyksICQoJy5jYXRhbG9nX19pdGVtcycpLCAkKCcuY2F0YWxvZ19fbWFpblNlY3Rpb24tLWZ1bGwnKSk7XHJcbiAgICBpZiAoJCh3aW5kb3cpLm91dGVyV2lkdGgoKSA8PSAxMDIzKSB7XHJcbiAgICAgICAgbWVkaWFDZW50ZXIoOCwgJCgnLmZvb3Rlcl9fcGF5bWVudExpbmsnKSwgJCgnLmZvb3Rlcl9fcGF5bWVudExpbmtzJykpO1xyXG4gICAgfVxyXG4gICAgcHJvZHVjdE1vcmVUYWJsZVJvd0NvbG9yKCk7XHJcbn0pO1xyXG5cclxuLy8gdmFyIGNhdGFsb2dGaWx0ZXJCb3ggPSBmdW5jdGlvbigpIHtcclxuLy8gICAgICQoJy5jYXRhbG9nX19vcHRpb25zSXRlbScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4vLyAgICAgICAgIHZhciB0b3AgPSAkKHRoaXMpLm9mZnNldCgpLnRvcCAtICQoJy5jYXRhbG9nX19vcHRpb25JdGVtcycpLm9mZnNldCgpLnRvcDtcclxuLy8gICAgICAgICAkKCcuY2F0YWxvZ19fb3B0aW9uRmluZFByb2R1Y3RCb3gnKS5hZGRDbGFzcygnY2F0YWxvZ19fb3B0aW9uRmluZFByb2R1Y3RCb3gtLWFjdGl2ZScpLmNzcygndG9wJywgdG9wKTtcclxuLy8gICAgIH0pO1xyXG4vLyB9O1xyXG5cclxudmFyIG1lZGlhQ2VudGVyID0gZnVuY3Rpb24oY291bnQsIGVsZW0sIGJveCwgYm94Q29udHJvbFNpemUpIHtcclxuICAgIHZhciBzaXplO1xyXG4gICAgaWYgKGVsZW0ubGVuZ3RoIDwgY291bnQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBlbGVtLmxlbmd0aCArIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYm94Q29udHJvbFNpemUpIHtcclxuICAgICAgICAgICAgICAgIHNpemUgPSBib3hDb250cm9sU2l6ZS53aWR0aCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IGJveC53aWR0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpID09IGVsZW0ubGVuZ3RoICsgMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJveC5jc3MoJ21heC13aWR0aCcsIGVsZW0ub3V0ZXJXaWR0aCh0cnVlKSAqIGkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBib3guY3NzKCdtYXgtd2lkdGgnLCBlbGVtLm91dGVyV2lkdGgodHJ1ZSkgKiAoaSAtIDEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpemUgPCBlbGVtLm91dGVyV2lkdGgodHJ1ZSkgKiBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94LmNzcygnbWF4LXdpZHRoJywgZWxlbS5vdXRlcldpZHRoKHRydWUpICogaSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJveC5jc3MoJ21heC13aWR0aCcsIGVsZW0ub3V0ZXJXaWR0aCh0cnVlKSAqIChpIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY291bnQgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGJveENvbnRyb2xTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplID0gYm94Q29udHJvbFNpemUud2lkdGgoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNpemUgPSBib3gud2lkdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2l6ZSA8IGVsZW0ub3V0ZXJXaWR0aCh0cnVlKSAqIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBib3guY3NzKCdtYXgtd2lkdGgnLCBlbGVtLm91dGVyV2lkdGgodHJ1ZSkgKiBpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94LmNzcygnbWF4LXdpZHRoJywgZWxlbS5vdXRlcldpZHRoKHRydWUpICogKGkgLSAxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGhTY3JvbGwgPSBmdW5jdGlvbihlbCwgZWxCKSB7XHJcbiAgICBlbC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB2YXIgeCA9IGUucGFnZVggLSAkKHRoaXMpLm9mZnNldCgpLmxlZnQ7XHJcbiAgICAgICAgJCh0aGlzKS5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciB4eCA9IGUucGFnZVggLSAkKHRoaXMpLm9mZnNldCgpLmxlZnQ7XHJcbiAgICAgICAgICAgIGlmICh4eCA8IHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJUciA9IGVsQi5zY3JvbGxMZWZ0KCkgKyAoeCAtIHh4KTtcclxuICAgICAgICAgICAgICAgIGVsQi5zY3JvbGxMZWZ0KGN1clRyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeHggPiB4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyVHIgPSBlbEIuc2Nyb2xsTGVmdCgpIC0gKHh4IC0geCk7XHJcbiAgICAgICAgICAgICAgICBlbEIuc2Nyb2xsTGVmdChjdXJUcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBlbEIub24oJ21vdXNldXAnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZWwudW5iaW5kKCdtb3VzZW1vdmUnKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGVsLnVuYmluZCgnY2xpY2snKTtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWxCLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGVsLnVuYmluZCgnbW91c2Vtb3ZlJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBwcm9kdWN0UGhvdG9HYWxlcnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBmaXJzdFNyYyA9ICQoJy5wcm9kdWN0TW9yZV9fZ2FsZXJ5UGljdHVyZU90aGVyJykuZXEoMCkuYXR0cignc3JjJyk7XHJcbiAgICAkKCcucHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVNYWluJykuYXR0cignc3JjJywgZmlyc3RTcmMpO1xyXG4gICAgJCgnLnByb2R1Y3RNb3JlX19nYWxlcnlQaWN0dXJlT3RoZXJDYXNlJykuZXEoMCkuYWRkQ2xhc3MoJ3Byb2R1Y3RNb3JlX19nYWxlcnlQaWN0dXJlT3RoZXJDYXNlLS1hY3RpdmUnKTtcclxuICAgICQoJy5wcm9kdWN0TW9yZV9fZ2FsZXJ5UGljdHVyZU90aGVyJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBuZWVkU3JjID0gJCh0aGlzKS5hdHRyKCdzcmMnKTtcclxuICAgICAgICAkKCcucHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVNYWluJykuYXR0cignc3JjJywgbmVlZFNyYyk7XHJcblxyXG4gICAgICAgICQoJy5wcm9kdWN0TW9yZV9fZ2FsZXJ5UGljdHVyZU90aGVyQ2FzZS0tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ3Byb2R1Y3RNb3JlX19nYWxlcnlQaWN0dXJlT3RoZXJDYXNlLS1hY3RpdmUnKTtcclxuXHJcbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcucHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVPdGhlckNhc2UnKS5hZGRDbGFzcygncHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVPdGhlckNhc2UtLWFjdGl2ZScpO1xyXG5cclxuICAgIH0pO1xyXG59O1xyXG5cclxudmFyIHByb2R1Y3RNb3JlVGFibGVSb3dDb2xvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJvd3MgPSAkKCcucHJvZHVjdE1vcmVfX2luZm9DaGFyYWN0ZXJpc3RpY3NUYWJsZVJvdycpO1xyXG4gICAgdmFyIGZpcnN0Q29sb3IgPSAnI2Y0ZjRmNCc7XHJcbiAgICB2YXIgc2Vjb25kQ29sb3IgPSAnI2ZmZmZmZic7XHJcbiAgICB2YXIgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xyXG4gICAgaWYgKCQod2luZG93KS5vdXRlcldpZHRoKCkgPj0gNjAwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpICUgMiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByb3dzLmVxKGkpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGZpcnN0Q29sb3IpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm93cy5lcShpKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzZWNvbmRDb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvd3MuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgdHJhbnNwYXJlbnQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcm93cy5lcShpKS5maW5kKCcucHJvZHVjdE1vcmVfX2luZm9DaGFyYWN0ZXJpc3RpY3NUYWJsZUNvbGwnKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBmaXJzdENvbG9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvd3MuZXEoaSkuZmluZCgnLnByb2R1Y3RNb3JlX19pbmZvQ2hhcmFjdGVyaXN0aWNzVGFibGVDb2xsJykuZXEoMCkuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgc2Vjb25kQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgcm93cy5lcShpKS5maW5kKCcucHJvZHVjdE1vcmVfX2luZm9DaGFyYWN0ZXJpc3RpY3NUYWJsZUNvbGwnKS5lcSgxKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBmaXJzdENvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBwcm9kdWN0TW9yZVRhYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRhYnMgPSAkKCcucHJvZHVjdE1vcmVfX2luZm9UYWInKTtcclxuICAgIHZhciBsaW5rcyA9ICQoJy5wcm9kdWN0TW9yZV9faW5mb01lbnVMaW5rJyk7XHJcblxyXG4gICAgbGlua3Mub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAkKCcucHJvZHVjdE1vcmVfX2luZm9NZW51TGluay0tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ3Byb2R1Y3RNb3JlX19pbmZvTWVudUxpbmstLWFjdGl2ZScpXHJcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygncHJvZHVjdE1vcmVfX2luZm9NZW51TGluay0tYWN0aXZlJyk7XHJcbiAgICAgICAgdmFyIHBhdGggPSAkKHRoaXMpLmF0dHIoJ2hyZWYnKTtcclxuICAgICAgICB0YWJzLmVhY2goZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKHRhYnMuZXEoaW5kZXgpLmF0dHIoJ2lkJykgPT09IHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHRhYnMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgICAgICAgICAgICAgICQodGhpcykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRhYnMuZXEoMCkuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICB2YXIgdGFiSWQwID0gdGFicy5lcSgwKS5hdHRyKCdpZCcpO1xyXG5cclxuICAgICQoJy5wcm9kdWN0TW9yZV9faW5mb01lbnVMaW5rJykuZWFjaChmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgIGlmIChsaW5rcy5lcShpbmRleCkuYXR0cignaHJlZicpID09PSB0YWJJZDApIHtcclxuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygncHJvZHVjdE1vcmVfX2luZm9NZW51TGluay0tYWN0aXZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG52YXIgY2F0YWxvZ0NoZWNrQm94ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAkKCcuY2F0YWxvZ19fb3B0aW9uc0l0ZW0nKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoJCh0aGlzKS5maW5kKCdpbnB1dCcpLnByb3AoJ2NoZWNrZWQnKSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2NhdGFsb2dfX29wdGlvbnNJdGVtLS1jaGVja2VkJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnY2F0YWxvZ19fb3B0aW9uc0l0ZW0tLWNoZWNrZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBjYXRhbG9nQWNjb3JkaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAkKCcuY2F0YWxvZ19fb3B0aW9uJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCh0aGlzKS5maW5kKCcuYWNjb3JkaW9uSWNvbicpLnRvZ2dsZUNsYXNzKCdhY2NvcmRpb25JY29uLS1hY3RpdmUnKTtcclxuICAgICAgICAkKHRoaXMpLmZpbmQoJy5jYXRhbG9nX19vcHRpb25zSXRlbUxpc3QnKS50b2dnbGVDbGFzcygnY2F0YWxvZ19fb3B0aW9uc0l0ZW1MaXN0LS1hY3RpdmUnKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxudmFyIGNhdGFsb2dTb3J0aW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAkKCcuY2F0YWxvZ19fc29ydGluZ1RpdGxlQm94Jykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCh0aGlzKS5maW5kKCcuYWNjb3JkaW9uSWNvbicpLnRvZ2dsZUNsYXNzKCdhY2NvcmRpb25JY29uLS1hY3RpdmUnKTtcclxuICAgICAgICAkKHRoaXMpLm5leHQoKS50b2dnbGVDbGFzcygnY2F0YWxvZ19fc29ydGluZ0xpc3QtLWFjdGl2ZScpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG52YXIgb3JkZXJGb3JtID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcGhvbmUgPSAkKCcub3JkZXJzX19mb3JtJykuZmluZCgnaW5wdXRbbmFtZT1cInBob25lXCJdJyk7XHJcbiAgICBwaG9uZS5tYXNrKFwiKzcoOTk5KSA5OTktOTktOTlcIik7XHJcblxyXG4gICAgdmFyIGZvcm0gPSAkKCcub3JkZXJzX19mb3JtJyk7XHJcbiAgICB2YXIgdGl0bGVFcnJvciA9ICQoJy5vcmRlcnNfX2Zvcm1FcnJvclRpdGxlJyk7XHJcbiAgICB2YXIgdmlzaW9uVGl0bGVFcnJvciA9IHRpdGxlRXJyb3IuY3NzKCdkaXNwbGF5Jyk7XHJcblxyXG4gICAgaWYgKHZpc2lvblRpdGxlRXJyb3IgPT09ICdibG9jaycpIHtcclxuICAgICAgICBmb3JtLmNzcygnbWFyZ2luLXRvcCcsICc1NXB4Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlucHV0UmVxdWlyZSA9ICQoJy5vcmRlcnNfX2Zvcm1JdGVtLS1yZXF1aXJlID4gaW5wdXQnKTtcclxuXHJcbn07XHJcblxyXG52YXIgaGVhZGVyTWVudUl0ZW1Ib3ZlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gJCgnYm9keScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gICAgIGlmICgkKCcuaGVhZGVyX19tZW51TGlzdCcpLmhhc0NsYXNzKCdoZWFkZXJfX21lbnVMaXN0LS1mdWxsJykpIHtcclxuICAgIC8vICAgICAgICAgJCgnLmhlYWRlcl9fbWVudUxpc3QnKS5yZW1vdmVDbGFzcygnaGVhZGVyX19tZW51TGlzdC0tZnVsbCcpO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH0pO1xyXG4gICAgJCgnLmhlYWRlcl9fY2F0YWxvZ0J0bicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICgkKCcuaGVhZGVyX19jYXRhbG9nQnRuVGV4dCcpLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgJCgnLmhlYWRlcl9fbWVudUxpc3QnKS50b2dnbGVDbGFzcygnaGVhZGVyX19tZW51TGlzdC0tZnVsbCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQoJy5oZWFkZXJfX21lbnVMaXN0JykudG9nZ2xlQ2xhc3MoJ2hlYWRlcl9fbWVudUxpc3QtLWFjdGl2ZScpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgJCgnLmhlYWRlcl9fbWVudUl0ZW0nKS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCQoJy5oZWFkZXJfX21lbnVMaXN0JykuaGFzQ2xhc3MoJ2hlYWRlcl9fbWVudUxpc3QtLWFjdGl2ZScpKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuZmluZCgnLmhlYWRlcl9fbWVudUl0ZW1BZnRlcicpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAkKHRoaXMpLmluZGV4KCk7XHJcbiAgICAgICAgICAgIHZhciB0b3A7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3AgPSAoLTUwICogaW5kZXgpICsgNDk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b3AgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkKHRoaXMpLmZpbmQoJy5oZWFkZXJfX3N1Yk1lbnUnKS5jc3Moe1xyXG4gICAgICAgICAgICAgICAgJ2Rpc3BsYXknOiAnZmxleCcsXHJcbiAgICAgICAgICAgICAgICAndG9wJzogdG9wXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgJCgnLmhlYWRlcl9fbWVudUl0ZW0nKS5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAkKHRoaXMpLmZpbmQoJy5oZWFkZXJfX21lbnVJdGVtQWZ0ZXInKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgICQodGhpcykuZmluZCgnLmhlYWRlcl9fc3ViTWVudScpLmNzcygnZGlzcGxheScsICdub25lJyk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBjYXRhbG9nRmlsdGVycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJCgnLmZpbHRlcnNCdG4nKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAkKCcuY2F0YWxvZ19fb3B0aW9ucycpLnRvZ2dsZUNsYXNzKCdjYXRhbG9nX19vcHRpb25zLS1hY3RpdmUnKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxudmFyIGZvb3Rlck1lbnUgPSBmdW5jdGlvbigpIHtcclxuICAgICQoJy5mb290ZXJfX21lbnVUaXRsZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpID0gJCgnLmZvb3Rlcl9fbWVudS0tYWN0aXZlJykuaW5kZXgoKTtcclxuICAgICAgICB2YXIgaiA9ICQodGhpcykuY2xvc2VzdCgnLmZvb3Rlcl9fbWVudScpLmluZGV4KCk7XHJcbiAgICAgICAgaWYgKGogPT09IGkpIHtcclxuICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuZm9vdGVyX19tZW51JykudG9nZ2xlQ2xhc3MoJ2Zvb3Rlcl9fbWVudS0tYWN0aXZlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCgnLmZvb3Rlcl9fbWVudS0tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2Zvb3Rlcl9fbWVudS0tYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnLmZvb3Rlcl9fbWVudScpLnRvZ2dsZUNsYXNzKCdmb290ZXJfX21lbnUtLWFjdGl2ZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTd2lwZXIgMy40LjJcclxuICogTW9zdCBtb2Rlcm4gbW9iaWxlIHRvdWNoIHNsaWRlciBhbmQgZnJhbWV3b3JrIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnNcclxuICogXHJcbiAqIGh0dHA6Ly93d3cuaWRhbmdlcm8udXMvc3dpcGVyL1xyXG4gKiBcclxuICogQ29weXJpZ2h0IDIwMTcsIFZsYWRpbWlyIEtoYXJsYW1waWRpXHJcbiAqIFRoZSBpRGFuZ2Vyby51c1xyXG4gKiBodHRwOi8vd3d3LmlkYW5nZXJvLnVzL1xyXG4gKiBcclxuICogTGljZW5zZWQgdW5kZXIgTUlUXHJcbiAqIFxyXG4gKiBSZWxlYXNlZCBvbjogTWFyY2ggMTAsIDIwMTdcclxuICovXHJcbiEgZnVuY3Rpb24oKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIHZhciBlLCBhID0gZnVuY3Rpb24odCwgcykge1xyXG4gICAgICAgIGZ1bmN0aW9uIHIoZSkgeyByZXR1cm4gTWF0aC5mbG9vcihlKSB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGkoKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0geC5wYXJhbXMuYXV0b3BsYXksXHJcbiAgICAgICAgICAgICAgICBhID0geC5zbGlkZXMuZXEoeC5hY3RpdmVJbmRleCk7XHJcbiAgICAgICAgICAgIGEuYXR0cihcImRhdGEtc3dpcGVyLWF1dG9wbGF5XCIpICYmIChlID0gYS5hdHRyKFwiZGF0YS1zd2lwZXItYXV0b3BsYXlcIikgfHwgeC5wYXJhbXMuYXV0b3BsYXkpLCB4LmF1dG9wbGF5VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgeC5wYXJhbXMubG9vcCA/ICh4LmZpeExvb3AoKSwgeC5fc2xpZGVOZXh0KCksIHguZW1pdChcIm9uQXV0b3BsYXlcIiwgeCkpIDogeC5pc0VuZCA/IHMuYXV0b3BsYXlTdG9wT25MYXN0ID8geC5zdG9wQXV0b3BsYXkoKSA6ICh4Ll9zbGlkZVRvKDApLCB4LmVtaXQoXCJvbkF1dG9wbGF5XCIsIHgpKSA6ICh4Ll9zbGlkZU5leHQoKSwgeC5lbWl0KFwib25BdXRvcGxheVwiLCB4KSkgfSwgZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG4oYSwgdCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IGUoYS50YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoIXMuaXModCkpXHJcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgcyA9IHMucGFyZW50cyh0KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQubm9kZVR5cGUpIHsgdmFyIHI7IHJldHVybiBzLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKGUsIGEpIHsgYSA9PT0gdCAmJiAociA9IHQpIH0pLCByID8gdCA6IHZvaWQgMCB9XHJcbiAgICAgICAgICAgIGlmICgwICE9PSBzLmxlbmd0aCkgcmV0dXJuIHNbMF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG8oZSwgYSkge1xyXG4gICAgICAgICAgICBhID0gYSB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIHQgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2Via2l0TXV0YXRpb25PYnNlcnZlcixcclxuICAgICAgICAgICAgICAgIHMgPSBuZXcgdChmdW5jdGlvbihlKSB7IGUuZm9yRWFjaChmdW5jdGlvbihlKSB7IHgub25SZXNpemUoITApLCB4LmVtaXQoXCJvbk9ic2VydmVyVXBkYXRlXCIsIHgsIGUpIH0pIH0pO1xyXG4gICAgICAgICAgICBzLm9ic2VydmUoZSwgeyBhdHRyaWJ1dGVzOiB2b2lkIDAgPT09IGEuYXR0cmlidXRlcyB8fCBhLmF0dHJpYnV0ZXMsIGNoaWxkTGlzdDogdm9pZCAwID09PSBhLmNoaWxkTGlzdCB8fCBhLmNoaWxkTGlzdCwgY2hhcmFjdGVyRGF0YTogdm9pZCAwID09PSBhLmNoYXJhY3RlckRhdGEgfHwgYS5jaGFyYWN0ZXJEYXRhIH0pLCB4Lm9ic2VydmVycy5wdXNoKHMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBsKGUpIHtcclxuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50ICYmIChlID0gZS5vcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgdmFyIGEgPSBlLmtleUNvZGUgfHwgZS5jaGFyQ29kZTtcclxuICAgICAgICAgICAgaWYgKCF4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ICYmICh4LmlzSG9yaXpvbnRhbCgpICYmIDM5ID09PSBhIHx8ICF4LmlzSG9yaXpvbnRhbCgpICYmIDQwID09PSBhKSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBpZiAoIXgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgJiYgKHguaXNIb3Jpem9udGFsKCkgJiYgMzcgPT09IGEgfHwgIXguaXNIb3Jpem9udGFsKCkgJiYgMzggPT09IGEpKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgIGlmICghKGUuc2hpZnRLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUgJiYgKFwiaW5wdXRcIiA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIHx8IFwidGV4dGFyZWFcIiA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICgzNyA9PT0gYSB8fCAzOSA9PT0gYSB8fCAzOCA9PT0gYSB8fCA0MCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguY29udGFpbmVyLnBhcmVudHMoXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzKS5sZW5ndGggPiAwICYmIDAgPT09IHguY29udGFpbmVyLnBhcmVudHMoXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKS5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHsgbGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0LCB0b3A6IHdpbmRvdy5wYWdlWU9mZnNldCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gd2luZG93LmlubmVyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB3aW5kb3cuaW5uZXJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB4LmNvbnRhaW5lci5vZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB4LnJ0bCAmJiAobi5sZWZ0ID0gbi5sZWZ0IC0geC5jb250YWluZXJbMF0uc2Nyb2xsTGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuLmxlZnQsIG4udG9wXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuLmxlZnQgKyB4LndpZHRoLCBuLnRvcF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbi5sZWZ0LCBuLnRvcCArIHguaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuLmxlZnQgKyB4LndpZHRoLCBuLnRvcCArIHguaGVpZ2h0XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCBsID0gMDsgbCA8IG8ubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBvW2xdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwWzBdID49IHMubGVmdCAmJiBwWzBdIDw9IHMubGVmdCArIHIgJiYgcFsxXSA+PSBzLnRvcCAmJiBwWzFdIDw9IHMudG9wICsgaSAmJiAodCA9ICEwKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXQpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeC5pc0hvcml6b250YWwoKSA/ICgzNyAhPT0gYSAmJiAzOSAhPT0gYSB8fCAoZS5wcmV2ZW50RGVmYXVsdCA/IGUucHJldmVudERlZmF1bHQoKSA6IGUucmV0dXJuVmFsdWUgPSAhMSksICgzOSA9PT0gYSAmJiAheC5ydGwgfHwgMzcgPT09IGEgJiYgeC5ydGwpICYmIHguc2xpZGVOZXh0KCksICgzNyA9PT0gYSAmJiAheC5ydGwgfHwgMzkgPT09IGEgJiYgeC5ydGwpICYmIHguc2xpZGVQcmV2KCkpIDogKDM4ICE9PSBhICYmIDQwICE9PSBhIHx8IChlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExKSwgNDAgPT09IGEgJiYgeC5zbGlkZU5leHQoKSwgMzggPT09IGEgJiYgeC5zbGlkZVByZXYoKSksIHguZW1pdChcIm9uS2V5UHJlc3NcIiwgeCwgYSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcChlKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gMCxcclxuICAgICAgICAgICAgICAgIHQgPSAwLFxyXG4gICAgICAgICAgICAgICAgcyA9IDAsXHJcbiAgICAgICAgICAgICAgICByID0gMDtcclxuICAgICAgICAgICAgcmV0dXJuIFwiZGV0YWlsXCIgaW4gZSAmJiAodCA9IGUuZGV0YWlsKSwgXCJ3aGVlbERlbHRhXCIgaW4gZSAmJiAodCA9IC1lLndoZWVsRGVsdGEgLyAxMjApLCBcIndoZWVsRGVsdGFZXCIgaW4gZSAmJiAodCA9IC1lLndoZWVsRGVsdGFZIC8gMTIwKSwgXCJ3aGVlbERlbHRhWFwiIGluIGUgJiYgKGEgPSAtZS53aGVlbERlbHRhWCAvIDEyMCksIFwiYXhpc1wiIGluIGUgJiYgZS5heGlzID09PSBlLkhPUklaT05UQUxfQVhJUyAmJiAoYSA9IHQsIHQgPSAwKSwgcyA9IDEwICogYSwgciA9IDEwICogdCwgXCJkZWx0YVlcIiBpbiBlICYmIChyID0gZS5kZWx0YVkpLCBcImRlbHRhWFwiIGluIGUgJiYgKHMgPSBlLmRlbHRhWCksIChzIHx8IHIpICYmIGUuZGVsdGFNb2RlICYmICgxID09PSBlLmRlbHRhTW9kZSA/IChzICo9IDQwLCByICo9IDQwKSA6IChzICo9IDgwMCwgciAqPSA4MDApKSwgcyAmJiAhYSAmJiAoYSA9IHMgPCAxID8gLTEgOiAxKSwgciAmJiAhdCAmJiAodCA9IHIgPCAxID8gLTEgOiAxKSwgeyBzcGluWDogYSwgc3Bpblk6IHQsIHBpeGVsWDogcywgcGl4ZWxZOiByIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGQoZSkge1xyXG4gICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQgJiYgKGUgPSBlLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IDAsXHJcbiAgICAgICAgICAgICAgICB0ID0geC5ydGwgPyAtMSA6IDEsXHJcbiAgICAgICAgICAgICAgICBzID0gcChlKTtcclxuICAgICAgICAgICAgaWYgKHgucGFyYW1zLm1vdXNld2hlZWxGb3JjZVRvQXhpcylcclxuICAgICAgICAgICAgICAgIGlmICh4LmlzSG9yaXpvbnRhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnMocy5waXhlbFgpID4gTWF0aC5hYnMocy5waXhlbFkpKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBzLnBpeGVsWCAqIHRcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnMocy5waXhlbFkpID4gTWF0aC5hYnMocy5waXhlbFgpKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBzLnBpeGVsWVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGEgPSBNYXRoLmFicyhzLnBpeGVsWCkgPiBNYXRoLmFicyhzLnBpeGVsWSkgPyAtcy5waXhlbFggKiB0IDogLXMucGl4ZWxZO1xyXG4gICAgICAgICAgICBpZiAoMCAhPT0gYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLm1vdXNld2hlZWxJbnZlcnQgJiYgKGEgPSAtYSksIHgucGFyYW1zLmZyZWVNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB4LmdldFdyYXBwZXJUcmFuc2xhdGUoKSArIGEgKiB4LnBhcmFtcy5tb3VzZXdoZWVsU2Vuc2l0aXZpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB4LmlzQmVnaW5uaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0geC5pc0VuZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAociA+PSB4Lm1pblRyYW5zbGF0ZSgpICYmIChyID0geC5taW5UcmFuc2xhdGUoKSksIHIgPD0geC5tYXhUcmFuc2xhdGUoKSAmJiAociA9IHgubWF4VHJhbnNsYXRlKCkpLCB4LnNldFdyYXBwZXJUcmFuc2l0aW9uKDApLCB4LnNldFdyYXBwZXJUcmFuc2xhdGUociksIHgudXBkYXRlUHJvZ3Jlc3MoKSwgeC51cGRhdGVBY3RpdmVJbmRleCgpLCAoIWkgJiYgeC5pc0JlZ2lubmluZyB8fCAhbiAmJiB4LmlzRW5kKSAmJiB4LnVwZGF0ZUNsYXNzZXMoKSwgeC5wYXJhbXMuZnJlZU1vZGVTdGlja3kgPyAoY2xlYXJUaW1lb3V0KHgubW91c2V3aGVlbC50aW1lb3V0KSwgeC5tb3VzZXdoZWVsLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB4LnNsaWRlUmVzZXQoKSB9LCAzMDApKSA6IHgucGFyYW1zLmxhenlMb2FkaW5nICYmIHgubGF6eSAmJiB4LmxhenkubG9hZCgpLCB4LmVtaXQoXCJvblNjcm9sbFwiLCB4LCBlKSwgeC5wYXJhbXMuYXV0b3BsYXkgJiYgeC5wYXJhbXMuYXV0b3BsYXlEaXNhYmxlT25JbnRlcmFjdGlvbiAmJiB4LnN0b3BBdXRvcGxheSgpLCAwID09PSByIHx8IHIgPT09IHgubWF4VHJhbnNsYXRlKCkpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG5ldyB3aW5kb3cuRGF0ZSkuZ2V0VGltZSgpIC0geC5tb3VzZXdoZWVsLmxhc3RTY3JvbGxUaW1lID4gNjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlzRW5kICYmICF4LnBhcmFtcy5sb29wIHx8IHguYW5pbWF0aW5nKSB7IGlmICh4LnBhcmFtcy5tb3VzZXdoZWVsUmVsZWFzZU9uRWRnZXMpIHJldHVybiAhMCB9IGVsc2UgeC5zbGlkZU5leHQoKSwgeC5lbWl0KFwib25TY3JvbGxcIiwgeCwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeC5pc0JlZ2lubmluZyAmJiAheC5wYXJhbXMubG9vcCB8fCB4LmFuaW1hdGluZykgeyBpZiAoeC5wYXJhbXMubW91c2V3aGVlbFJlbGVhc2VPbkVkZ2VzKSByZXR1cm4gITAgfSBlbHNlIHguc2xpZGVQcmV2KCksIHguZW1pdChcIm9uU2Nyb2xsXCIsIHgsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHgubW91c2V3aGVlbC5sYXN0U2Nyb2xsVGltZSA9IChuZXcgd2luZG93LkRhdGUpLmdldFRpbWUoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQgPyBlLnByZXZlbnREZWZhdWx0KCkgOiBlLnJldHVyblZhbHVlID0gITEsICExXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG0oYSwgdCkge1xyXG4gICAgICAgICAgICBhID0gZShhKTtcclxuICAgICAgICAgICAgdmFyIHMsIHIsIGksIG4gPSB4LnJ0bCA/IC0xIDogMTtcclxuICAgICAgICAgICAgcyA9IGEuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4XCIpIHx8IFwiMFwiLCByID0gYS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgteFwiKSwgaSA9IGEuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LXlcIiksIHIgfHwgaSA/IChyID0gciB8fCBcIjBcIiwgaSA9IGkgfHwgXCIwXCIpIDogeC5pc0hvcml6b250YWwoKSA/IChyID0gcywgaSA9IFwiMFwiKSA6IChpID0gcywgciA9IFwiMFwiKSwgciA9IHIuaW5kZXhPZihcIiVcIikgPj0gMCA/IHBhcnNlSW50KHIsIDEwKSAqIHQgKiBuICsgXCIlXCIgOiByICogdCAqIG4gKyBcInB4XCIsIGkgPSBpLmluZGV4T2YoXCIlXCIpID49IDAgPyBwYXJzZUludChpLCAxMCkgKiB0ICsgXCIlXCIgOiBpICogdCArIFwicHhcIiwgYS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIHIgKyBcIiwgXCIgKyBpICsgXCIsMHB4KVwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdShlKSB7IHJldHVybiAwICE9PSBlLmluZGV4T2YoXCJvblwiKSAmJiAoZSA9IGVbMF0gIT09IGVbMF0udG9VcHBlckNhc2UoKSA/IFwib25cIiArIGVbMF0udG9VcHBlckNhc2UoKSArIGUuc3Vic3RyaW5nKDEpIDogXCJvblwiICsgZSksIGUgfVxyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhKSkgcmV0dXJuIG5ldyBhKHQsIHMpO1xyXG4gICAgICAgIHZhciBjID0geyBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLCB0b3VjaEV2ZW50c1RhcmdldDogXCJjb250YWluZXJcIiwgaW5pdGlhbFNsaWRlOiAwLCBzcGVlZDogMzAwLCBhdXRvcGxheTogITEsIGF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb246ICEwLCBhdXRvcGxheVN0b3BPbkxhc3Q6ICExLCBpT1NFZGdlU3dpcGVEZXRlY3Rpb246ICExLCBpT1NFZGdlU3dpcGVUaHJlc2hvbGQ6IDIwLCBmcmVlTW9kZTogITEsIGZyZWVNb2RlTW9tZW50dW06ICEwLCBmcmVlTW9kZU1vbWVudHVtUmF0aW86IDEsIGZyZWVNb2RlTW9tZW50dW1Cb3VuY2U6ICEwLCBmcmVlTW9kZU1vbWVudHVtQm91bmNlUmF0aW86IDEsIGZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvOiAxLCBmcmVlTW9kZVN0aWNreTogITEsIGZyZWVNb2RlTWluaW11bVZlbG9jaXR5OiAuMDIsIGF1dG9IZWlnaHQ6ICExLCBzZXRXcmFwcGVyU2l6ZTogITEsIHZpcnR1YWxUcmFuc2xhdGU6ICExLCBlZmZlY3Q6IFwic2xpZGVcIiwgY292ZXJmbG93OiB7IHJvdGF0ZTogNTAsIHN0cmV0Y2g6IDAsIGRlcHRoOiAxMDAsIG1vZGlmaWVyOiAxLCBzbGlkZVNoYWRvd3M6ICEwIH0sIGZsaXA6IHsgc2xpZGVTaGFkb3dzOiAhMCwgbGltaXRSb3RhdGlvbjogITAgfSwgY3ViZTogeyBzbGlkZVNoYWRvd3M6ICEwLCBzaGFkb3c6ICEwLCBzaGFkb3dPZmZzZXQ6IDIwLCBzaGFkb3dTY2FsZTogLjk0IH0sIGZhZGU6IHsgY3Jvc3NGYWRlOiAhMSB9LCBwYXJhbGxheDogITEsIHpvb206ICExLCB6b29tTWF4OiAzLCB6b29tTWluOiAxLCB6b29tVG9nZ2xlOiAhMCwgc2Nyb2xsYmFyOiBudWxsLCBzY3JvbGxiYXJIaWRlOiAhMCwgc2Nyb2xsYmFyRHJhZ2dhYmxlOiAhMSwgc2Nyb2xsYmFyU25hcE9uUmVsZWFzZTogITEsIGtleWJvYXJkQ29udHJvbDogITEsIG1vdXNld2hlZWxDb250cm9sOiAhMSwgbW91c2V3aGVlbFJlbGVhc2VPbkVkZ2VzOiAhMSwgbW91c2V3aGVlbEludmVydDogITEsIG1vdXNld2hlZWxGb3JjZVRvQXhpczogITEsIG1vdXNld2hlZWxTZW5zaXRpdml0eTogMSwgbW91c2V3aGVlbEV2ZW50c1RhcmdlZDogXCJjb250YWluZXJcIiwgaGFzaG5hdjogITEsIGhhc2huYXZXYXRjaFN0YXRlOiAhMSwgaGlzdG9yeTogITEsIHJlcGxhY2VTdGF0ZTogITEsIGJyZWFrcG9pbnRzOiB2b2lkIDAsIHNwYWNlQmV0d2VlbjogMCwgc2xpZGVzUGVyVmlldzogMSwgc2xpZGVzUGVyQ29sdW1uOiAxLCBzbGlkZXNQZXJDb2x1bW5GaWxsOiBcImNvbHVtblwiLCBzbGlkZXNQZXJHcm91cDogMSwgY2VudGVyZWRTbGlkZXM6ICExLCBzbGlkZXNPZmZzZXRCZWZvcmU6IDAsIHNsaWRlc09mZnNldEFmdGVyOiAwLCByb3VuZExlbmd0aHM6ICExLCB0b3VjaFJhdGlvOiAxLCB0b3VjaEFuZ2xlOiA0NSwgc2ltdWxhdGVUb3VjaDogITAsIHNob3J0U3dpcGVzOiAhMCwgbG9uZ1N3aXBlczogITAsIGxvbmdTd2lwZXNSYXRpbzogLjUsIGxvbmdTd2lwZXNNczogMzAwLCBmb2xsb3dGaW5nZXI6ICEwLCBvbmx5RXh0ZXJuYWw6ICExLCB0aHJlc2hvbGQ6IDAsIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogITAsIHRvdWNoUmVsZWFzZU9uRWRnZXM6ICExLCB1bmlxdWVOYXZFbGVtZW50czogITAsIHBhZ2luYXRpb246IG51bGwsIHBhZ2luYXRpb25FbGVtZW50OiBcInNwYW5cIiwgcGFnaW5hdGlvbkNsaWNrYWJsZTogITEsIHBhZ2luYXRpb25IaWRlOiAhMSwgcGFnaW5hdGlvbkJ1bGxldFJlbmRlcjogbnVsbCwgcGFnaW5hdGlvblByb2dyZXNzUmVuZGVyOiBudWxsLCBwYWdpbmF0aW9uRnJhY3Rpb25SZW5kZXI6IG51bGwsIHBhZ2luYXRpb25DdXN0b21SZW5kZXI6IG51bGwsIHBhZ2luYXRpb25UeXBlOiBcImJ1bGxldHNcIiwgcmVzaXN0YW5jZTogITAsIHJlc2lzdGFuY2VSYXRpbzogLjg1LCBuZXh0QnV0dG9uOiBudWxsLCBwcmV2QnV0dG9uOiBudWxsLCB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMSwgd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OiAhMSwgZ3JhYkN1cnNvcjogITEsIHByZXZlbnRDbGlja3M6ICEwLCBwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb246ICEwLCBzbGlkZVRvQ2xpY2tlZFNsaWRlOiAhMSwgbGF6eUxvYWRpbmc6ICExLCBsYXp5TG9hZGluZ0luUHJldk5leHQ6ICExLCBsYXp5TG9hZGluZ0luUHJldk5leHRBbW91bnQ6IDEsIGxhenlMb2FkaW5nT25UcmFuc2l0aW9uU3RhcnQ6ICExLCBwcmVsb2FkSW1hZ2VzOiAhMCwgdXBkYXRlT25JbWFnZXNSZWFkeTogITAsIGxvb3A6ICExLCBsb29wQWRkaXRpb25hbFNsaWRlczogMCwgbG9vcGVkU2xpZGVzOiBudWxsLCBjb250cm9sOiB2b2lkIDAsIGNvbnRyb2xJbnZlcnNlOiAhMSwgY29udHJvbEJ5OiBcInNsaWRlXCIsIG5vcm1hbGl6ZVNsaWRlSW5kZXg6ICEwLCBhbGxvd1N3aXBlVG9QcmV2OiAhMCwgYWxsb3dTd2lwZVRvTmV4dDogITAsIHN3aXBlSGFuZGxlcjogbnVsbCwgbm9Td2lwaW5nOiAhMCwgbm9Td2lwaW5nQ2xhc3M6IFwic3dpcGVyLW5vLXN3aXBpbmdcIiwgcGFzc2l2ZUxpc3RlbmVyczogITAsIGNvbnRhaW5lck1vZGlmaWVyQ2xhc3M6IFwic3dpcGVyLWNvbnRhaW5lci1cIiwgc2xpZGVDbGFzczogXCJzd2lwZXItc2xpZGVcIiwgc2xpZGVBY3RpdmVDbGFzczogXCJzd2lwZXItc2xpZGUtYWN0aXZlXCIsIHNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3M6IFwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1hY3RpdmVcIiwgc2xpZGVWaXNpYmxlQ2xhc3M6IFwic3dpcGVyLXNsaWRlLXZpc2libGVcIiwgc2xpZGVEdXBsaWNhdGVDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlXCIsIHNsaWRlTmV4dENsYXNzOiBcInN3aXBlci1zbGlkZS1uZXh0XCIsIHNsaWRlRHVwbGljYXRlTmV4dENsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtbmV4dFwiLCBzbGlkZVByZXZDbGFzczogXCJzd2lwZXItc2xpZGUtcHJldlwiLCBzbGlkZUR1cGxpY2F0ZVByZXZDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlLXByZXZcIiwgd3JhcHBlckNsYXNzOiBcInN3aXBlci13cmFwcGVyXCIsIGJ1bGxldENsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldFwiLCBidWxsZXRBY3RpdmVDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlXCIsIGJ1dHRvbkRpc2FibGVkQ2xhc3M6IFwic3dpcGVyLWJ1dHRvbi1kaXNhYmxlZFwiLCBwYWdpbmF0aW9uQ3VycmVudENsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLWN1cnJlbnRcIiwgcGFnaW5hdGlvblRvdGFsQ2xhc3M6IFwic3dpcGVyLXBhZ2luYXRpb24tdG90YWxcIiwgcGFnaW5hdGlvbkhpZGRlbkNsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLWhpZGRlblwiLCBwYWdpbmF0aW9uUHJvZ3Jlc3NiYXJDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2JhclwiLCBwYWdpbmF0aW9uQ2xpY2thYmxlQ2xhc3M6IFwic3dpcGVyLXBhZ2luYXRpb24tY2xpY2thYmxlXCIsIHBhZ2luYXRpb25Nb2RpZmllckNsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLVwiLCBsYXp5TG9hZGluZ0NsYXNzOiBcInN3aXBlci1sYXp5XCIsIGxhenlTdGF0dXNMb2FkaW5nQ2xhc3M6IFwic3dpcGVyLWxhenktbG9hZGluZ1wiLCBsYXp5U3RhdHVzTG9hZGVkQ2xhc3M6IFwic3dpcGVyLWxhenktbG9hZGVkXCIsIGxhenlQcmVsb2FkZXJDbGFzczogXCJzd2lwZXItbGF6eS1wcmVsb2FkZXJcIiwgbm90aWZpY2F0aW9uQ2xhc3M6IFwic3dpcGVyLW5vdGlmaWNhdGlvblwiLCBwcmVsb2FkZXJDbGFzczogXCJwcmVsb2FkZXJcIiwgem9vbUNvbnRhaW5lckNsYXNzOiBcInN3aXBlci16b29tLWNvbnRhaW5lclwiLCBvYnNlcnZlcjogITEsIG9ic2VydmVQYXJlbnRzOiAhMSwgYTExeTogITEsIHByZXZTbGlkZU1lc3NhZ2U6IFwiUHJldmlvdXMgc2xpZGVcIiwgbmV4dFNsaWRlTWVzc2FnZTogXCJOZXh0IHNsaWRlXCIsIGZpcnN0U2xpZGVNZXNzYWdlOiBcIlRoaXMgaXMgdGhlIGZpcnN0IHNsaWRlXCIsIGxhc3RTbGlkZU1lc3NhZ2U6IFwiVGhpcyBpcyB0aGUgbGFzdCBzbGlkZVwiLCBwYWdpbmF0aW9uQnVsbGV0TWVzc2FnZTogXCJHbyB0byBzbGlkZSB7e2luZGV4fX1cIiwgcnVuQ2FsbGJhY2tzT25Jbml0OiAhMCB9LFxyXG4gICAgICAgICAgICBnID0gcyAmJiBzLnZpcnR1YWxUcmFuc2xhdGU7XHJcbiAgICAgICAgcyA9IHMgfHwge307XHJcbiAgICAgICAgdmFyIGggPSB7fTtcclxuICAgICAgICBmb3IgKHZhciB2IGluIHMpXHJcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBzW3ZdIHx8IG51bGwgPT09IHNbdl0gfHwgKHNbdl0ubm9kZVR5cGUgfHwgc1t2XSA9PT0gd2luZG93IHx8IHNbdl0gPT09IGRvY3VtZW50IHx8IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIERvbTcgJiYgc1t2XSBpbnN0YW5jZW9mIERvbTcgfHwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgalF1ZXJ5ICYmIHNbdl0gaW5zdGFuY2VvZiBqUXVlcnkpKSBoW3ZdID0gc1t2XTtcclxuICAgICAgICAgICAgZWxzZSB7IGhbdl0gPSB7fTsgZm9yICh2YXIgZiBpbiBzW3ZdKSBoW3ZdW2ZdID0gc1t2XVtmXSB9XHJcbiAgICAgICAgZm9yICh2YXIgdyBpbiBjKVxyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBzW3ddKSBzW3ddID0gY1t3XTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2Ygc1t3XSlcclxuICAgICAgICAgICAgZm9yICh2YXIgeSBpbiBjW3ddKSB2b2lkIDAgPT09IHNbd11beV0gJiYgKHNbd11beV0gPSBjW3ddW3ldKTtcclxuICAgICAgICB2YXIgeCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHgucGFyYW1zID0gcywgeC5vcmlnaW5hbFBhcmFtcyA9IGgsIHguY2xhc3NOYW1lcyA9IFtdLCB2b2lkIDAgIT09IGUgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgRG9tNyAmJiAoZSA9IERvbTcpLCAodm9pZCAwICE9PSBlIHx8IChlID0gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgRG9tNyA/IHdpbmRvdy5Eb203IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5IDogRG9tNykpICYmICh4LiQgPSBlLCB4LmN1cnJlbnRCcmVha3BvaW50ID0gdm9pZCAwLCB4LmdldEFjdGl2ZUJyZWFrcG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICgheC5wYXJhbXMuYnJlYWtwb2ludHMpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgIHZhciBlLCBhID0gITEsXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChlIGluIHgucGFyYW1zLmJyZWFrcG9pbnRzKSB4LnBhcmFtcy5icmVha3BvaW50cy5oYXNPd25Qcm9wZXJ0eShlKSAmJiB0LnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB0LnNvcnQoZnVuY3Rpb24oZSwgYSkgeyByZXR1cm4gcGFyc2VJbnQoZSwgMTApID4gcGFyc2VJbnQoYSwgMTApIH0pO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKShlID0gdFtzXSkgPj0gd2luZG93LmlubmVyV2lkdGggJiYgIWEgJiYgKGEgPSBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhIHx8IFwibWF4XCJcclxuICAgICAgICAgICAgfSwgeC5zZXRCcmVha3BvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHguZ2V0QWN0aXZlQnJlYWtwb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgeC5jdXJyZW50QnJlYWtwb2ludCAhPT0gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gZSBpbiB4LnBhcmFtcy5icmVha3BvaW50cyA/IHgucGFyYW1zLmJyZWFrcG9pbnRzW2VdIDogeC5vcmlnaW5hbFBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHgucGFyYW1zLmxvb3AgJiYgYS5zbGlkZXNQZXJWaWV3ICE9PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gYSkgeC5wYXJhbXNbc10gPSBhW3NdO1xyXG4gICAgICAgICAgICAgICAgICAgIHguY3VycmVudEJyZWFrcG9pbnQgPSBlLCB0ICYmIHguZGVzdHJveUxvb3AgJiYgeC5yZUxvb3AoITApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHgucGFyYW1zLmJyZWFrcG9pbnRzICYmIHguc2V0QnJlYWtwb2ludCgpLCB4LmNvbnRhaW5lciA9IGUodCksIDAgIT09IHguY29udGFpbmVyLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgaWYgKHguY29udGFpbmVyLmxlbmd0aCA+IDEpIHsgdmFyIFQgPSBbXTsgcmV0dXJuIHguY29udGFpbmVyLmVhY2goZnVuY3Rpb24oKSB7IFQucHVzaChuZXcgYSh0aGlzLCBzKSkgfSksIFQgfVxyXG4gICAgICAgICAgICB4LmNvbnRhaW5lclswXS5zd2lwZXIgPSB4LCB4LmNvbnRhaW5lci5kYXRhKFwic3dpcGVyXCIsIHgpLCB4LmNsYXNzTmFtZXMucHVzaCh4LnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgeC5wYXJhbXMuZGlyZWN0aW9uKSwgeC5wYXJhbXMuZnJlZU1vZGUgJiYgeC5jbGFzc05hbWVzLnB1c2goeC5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIFwiZnJlZS1tb2RlXCIpLCB4LnN1cHBvcnQuZmxleGJveCB8fCAoeC5jbGFzc05hbWVzLnB1c2goeC5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIFwibm8tZmxleGJveFwiKSwgeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID0gMSksIHgucGFyYW1zLmF1dG9IZWlnaHQgJiYgeC5jbGFzc05hbWVzLnB1c2goeC5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIFwiYXV0b2hlaWdodFwiKSwgKHgucGFyYW1zLnBhcmFsbGF4IHx8IHgucGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkgJiYgKHgucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSAhMCksIHgucGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgKHgucGFyYW1zLnJlc2lzdGFuY2VSYXRpbyA9IDApLCBbXCJjdWJlXCIsIFwiY292ZXJmbG93XCIsIFwiZmxpcFwiXS5pbmRleE9mKHgucGFyYW1zLmVmZmVjdCkgPj0gMCAmJiAoeC5zdXBwb3J0LnRyYW5zZm9ybXMzZCA/ICh4LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITAsIHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcIjNkXCIpKSA6IHgucGFyYW1zLmVmZmVjdCA9IFwic2xpZGVcIiksIFwic2xpZGVcIiAhPT0geC5wYXJhbXMuZWZmZWN0ICYmIHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyB4LnBhcmFtcy5lZmZlY3QpLCBcImN1YmVcIiA9PT0geC5wYXJhbXMuZWZmZWN0ICYmICh4LnBhcmFtcy5yZXNpc3RhbmNlUmF0aW8gPSAwLCB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID0gMSwgeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID0gMSwgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPSAxLCB4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA9ICExLCB4LnBhcmFtcy5zcGFjZUJldHdlZW4gPSAwLCB4LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlID0gITApLCBcImZhZGVcIiAhPT0geC5wYXJhbXMuZWZmZWN0ICYmIFwiZmxpcFwiICE9PSB4LnBhcmFtcy5lZmZlY3QgfHwgKHgucGFyYW1zLnNsaWRlc1BlclZpZXcgPSAxLCB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPSAxLCB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCA9IDEsIHgucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSAhMCwgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuID0gMCwgdm9pZCAwID09PSBnICYmICh4LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlID0gITApKSwgeC5wYXJhbXMuZ3JhYkN1cnNvciAmJiB4LnN1cHBvcnQudG91Y2ggJiYgKHgucGFyYW1zLmdyYWJDdXJzb3IgPSAhMSksIHgud3JhcHBlciA9IHguY29udGFpbmVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMud3JhcHBlckNsYXNzKSwgeC5wYXJhbXMucGFnaW5hdGlvbiAmJiAoeC5wYWdpbmF0aW9uQ29udGFpbmVyID0gZSh4LnBhcmFtcy5wYWdpbmF0aW9uKSwgeC5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgeC5wYXJhbXMucGFnaW5hdGlvbiAmJiB4LnBhZ2luYXRpb25Db250YWluZXIubGVuZ3RoID4gMSAmJiAxID09PSB4LmNvbnRhaW5lci5maW5kKHgucGFyYW1zLnBhZ2luYXRpb24pLmxlbmd0aCAmJiAoeC5wYWdpbmF0aW9uQ29udGFpbmVyID0geC5jb250YWluZXIuZmluZCh4LnBhcmFtcy5wYWdpbmF0aW9uKSksIFwiYnVsbGV0c1wiID09PSB4LnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAmJiB4LnBhcmFtcy5wYWdpbmF0aW9uQ2xpY2thYmxlID8geC5wYWdpbmF0aW9uQ29udGFpbmVyLmFkZENsYXNzKHgucGFyYW1zLnBhZ2luYXRpb25Nb2RpZmllckNsYXNzICsgXCJjbGlja2FibGVcIikgOiB4LnBhcmFtcy5wYWdpbmF0aW9uQ2xpY2thYmxlID0gITEsIHgucGFnaW5hdGlvbkNvbnRhaW5lci5hZGRDbGFzcyh4LnBhcmFtcy5wYWdpbmF0aW9uTW9kaWZpZXJDbGFzcyArIHgucGFyYW1zLnBhZ2luYXRpb25UeXBlKSksICh4LnBhcmFtcy5uZXh0QnV0dG9uIHx8IHgucGFyYW1zLnByZXZCdXR0b24pICYmICh4LnBhcmFtcy5uZXh0QnV0dG9uICYmICh4Lm5leHRCdXR0b24gPSBlKHgucGFyYW1zLm5leHRCdXR0b24pLCB4LnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB4LnBhcmFtcy5uZXh0QnV0dG9uICYmIHgubmV4dEJ1dHRvbi5sZW5ndGggPiAxICYmIDEgPT09IHguY29udGFpbmVyLmZpbmQoeC5wYXJhbXMubmV4dEJ1dHRvbikubGVuZ3RoICYmICh4Lm5leHRCdXR0b24gPSB4LmNvbnRhaW5lci5maW5kKHgucGFyYW1zLm5leHRCdXR0b24pKSksIHgucGFyYW1zLnByZXZCdXR0b24gJiYgKHgucHJldkJ1dHRvbiA9IGUoeC5wYXJhbXMucHJldkJ1dHRvbiksIHgucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHgucGFyYW1zLnByZXZCdXR0b24gJiYgeC5wcmV2QnV0dG9uLmxlbmd0aCA+IDEgJiYgMSA9PT0geC5jb250YWluZXIuZmluZCh4LnBhcmFtcy5wcmV2QnV0dG9uKS5sZW5ndGggJiYgKHgucHJldkJ1dHRvbiA9IHguY29udGFpbmVyLmZpbmQoeC5wYXJhbXMucHJldkJ1dHRvbikpKSksIHguaXNIb3Jpem9udGFsID0gZnVuY3Rpb24oKSB7IHJldHVybiBcImhvcml6b250YWxcIiA9PT0geC5wYXJhbXMuZGlyZWN0aW9uIH0sIHgucnRsID0geC5pc0hvcml6b250YWwoKSAmJiAoXCJydGxcIiA9PT0geC5jb250YWluZXJbMF0uZGlyLnRvTG93ZXJDYXNlKCkgfHwgXCJydGxcIiA9PT0geC5jb250YWluZXIuY3NzKFwiZGlyZWN0aW9uXCIpKSwgeC5ydGwgJiYgeC5jbGFzc05hbWVzLnB1c2goeC5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIFwicnRsXCIpLCB4LnJ0bCAmJiAoeC53cm9uZ1JUTCA9IFwiLXdlYmtpdC1ib3hcIiA9PT0geC53cmFwcGVyLmNzcyhcImRpc3BsYXlcIikpLCB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxICYmIHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcIm11bHRpcm93XCIpLCB4LmRldmljZS5hbmRyb2lkICYmIHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcImFuZHJvaWRcIiksIHguY29udGFpbmVyLmFkZENsYXNzKHguY2xhc3NOYW1lcy5qb2luKFwiIFwiKSksIHgudHJhbnNsYXRlID0gMCwgeC5wcm9ncmVzcyA9IDAsIHgudmVsb2NpdHkgPSAwLCB4LmxvY2tTd2lwZVRvTmV4dCA9IGZ1bmN0aW9uKCkgeyB4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ID0gITEsIHgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgPT09ICExICYmIHgucGFyYW1zLmdyYWJDdXJzb3IgJiYgeC51bnNldEdyYWJDdXJzb3IoKSB9LCB4LmxvY2tTd2lwZVRvUHJldiA9IGZ1bmN0aW9uKCkgeyB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ID0gITEsIHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgPT09ICExICYmIHgucGFyYW1zLmdyYWJDdXJzb3IgJiYgeC51bnNldEdyYWJDdXJzb3IoKSB9LCB4LmxvY2tTd2lwZXMgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMuYWxsb3dTd2lwZVRvTmV4dCA9IHgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgPSAhMSwgeC5wYXJhbXMuZ3JhYkN1cnNvciAmJiB4LnVuc2V0R3JhYkN1cnNvcigpIH0sIHgudW5sb2NrU3dpcGVUb05leHQgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMuYWxsb3dTd2lwZVRvTmV4dCA9ICEwLCB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ID09PSAhMCAmJiB4LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHguc2V0R3JhYkN1cnNvcigpIH0sIHgudW5sb2NrU3dpcGVUb1ByZXYgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiA9ICEwLCB4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ID09PSAhMCAmJiB4LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHguc2V0R3JhYkN1cnNvcigpIH0sIHgudW5sb2NrU3dpcGVzID0gZnVuY3Rpb24oKSB7IHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgPSB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ID0gITAsIHgucGFyYW1zLmdyYWJDdXJzb3IgJiYgeC5zZXRHcmFiQ3Vyc29yKCkgfSwgeC5zZXRHcmFiQ3Vyc29yID0gZnVuY3Rpb24oZSkgeyB4LmNvbnRhaW5lclswXS5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIiwgeC5jb250YWluZXJbMF0uc3R5bGUuY3Vyc29yID0gZSA/IFwiLXdlYmtpdC1ncmFiYmluZ1wiIDogXCItd2Via2l0LWdyYWJcIiwgeC5jb250YWluZXJbMF0uc3R5bGUuY3Vyc29yID0gZSA/IFwiLW1vei1ncmFiYmluXCIgOiBcIi1tb3otZ3JhYlwiLCB4LmNvbnRhaW5lclswXS5zdHlsZS5jdXJzb3IgPSBlID8gXCJncmFiYmluZ1wiIDogXCJncmFiXCIgfSwgeC51bnNldEdyYWJDdXJzb3IgPSBmdW5jdGlvbigpIHsgeC5jb250YWluZXJbMF0uc3R5bGUuY3Vyc29yID0gXCJcIiB9LCB4LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHguc2V0R3JhYkN1cnNvcigpLCB4LmltYWdlc1RvTG9hZCA9IFtdLCB4LmltYWdlc0xvYWRlZCA9IDAsIHgubG9hZEltYWdlID0gZnVuY3Rpb24oZSwgYSwgdCwgcywgciwgaSkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbigpIHsgaSAmJiBpKCkgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG87XHJcbiAgICAgICAgICAgICAgICBlLmNvbXBsZXRlICYmIHIgPyBuKCkgOiBhID8gKG8gPSBuZXcgd2luZG93LkltYWdlLCBvLm9ubG9hZCA9IG4sIG8ub25lcnJvciA9IG4sIHMgJiYgKG8uc2l6ZXMgPSBzKSwgdCAmJiAoby5zcmNzZXQgPSB0KSwgYSAmJiAoby5zcmMgPSBhKSkgOiBuKClcclxuICAgICAgICAgICAgfSwgeC5wcmVsb2FkSW1hZ2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlKCkgeyB2b2lkIDAgIT09IHggJiYgbnVsbCAhPT0geCAmJiB4ICYmICh2b2lkIDAgIT09IHguaW1hZ2VzTG9hZGVkICYmIHguaW1hZ2VzTG9hZGVkKyssIHguaW1hZ2VzTG9hZGVkID09PSB4LmltYWdlc1RvTG9hZC5sZW5ndGggJiYgKHgucGFyYW1zLnVwZGF0ZU9uSW1hZ2VzUmVhZHkgJiYgeC51cGRhdGUoKSwgeC5lbWl0KFwib25JbWFnZXNSZWFkeVwiLCB4KSkpIH1cclxuICAgICAgICAgICAgICAgIHguaW1hZ2VzVG9Mb2FkID0geC5jb250YWluZXIuZmluZChcImltZ1wiKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgeC5pbWFnZXNUb0xvYWQubGVuZ3RoOyBhKyspIHgubG9hZEltYWdlKHguaW1hZ2VzVG9Mb2FkW2FdLCB4LmltYWdlc1RvTG9hZFthXS5jdXJyZW50U3JjIHx8IHguaW1hZ2VzVG9Mb2FkW2FdLmdldEF0dHJpYnV0ZShcInNyY1wiKSwgeC5pbWFnZXNUb0xvYWRbYV0uc3Jjc2V0IHx8IHguaW1hZ2VzVG9Mb2FkW2FdLmdldEF0dHJpYnV0ZShcInNyY3NldFwiKSwgeC5pbWFnZXNUb0xvYWRbYV0uc2l6ZXMgfHwgeC5pbWFnZXNUb0xvYWRbYV0uZ2V0QXR0cmlidXRlKFwic2l6ZXNcIiksICEwLCBlKVxyXG4gICAgICAgICAgICB9LCB4LmF1dG9wbGF5VGltZW91dElkID0gdm9pZCAwLCB4LmF1dG9wbGF5aW5nID0gITEsIHguYXV0b3BsYXlQYXVzZWQgPSAhMSwgeC5zdGFydEF1dG9wbGF5ID0gZnVuY3Rpb24oKSB7IHJldHVybiB2b2lkIDAgPT09IHguYXV0b3BsYXlUaW1lb3V0SWQgJiYgKCEheC5wYXJhbXMuYXV0b3BsYXkgJiYgKCF4LmF1dG9wbGF5aW5nICYmICh4LmF1dG9wbGF5aW5nID0gITAsIHguZW1pdChcIm9uQXV0b3BsYXlTdGFydFwiLCB4KSwgdm9pZCBpKCkpKSkgfSwgeC5zdG9wQXV0b3BsYXkgPSBmdW5jdGlvbihlKSB7IHguYXV0b3BsYXlUaW1lb3V0SWQgJiYgKHguYXV0b3BsYXlUaW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHguYXV0b3BsYXlUaW1lb3V0SWQpLCB4LmF1dG9wbGF5aW5nID0gITEsIHguYXV0b3BsYXlUaW1lb3V0SWQgPSB2b2lkIDAsIHguZW1pdChcIm9uQXV0b3BsYXlTdG9wXCIsIHgpKSB9LCB4LnBhdXNlQXV0b3BsYXkgPSBmdW5jdGlvbihlKSB7IHguYXV0b3BsYXlQYXVzZWQgfHwgKHguYXV0b3BsYXlUaW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHguYXV0b3BsYXlUaW1lb3V0SWQpLCB4LmF1dG9wbGF5UGF1c2VkID0gITAsIDAgPT09IGUgPyAoeC5hdXRvcGxheVBhdXNlZCA9ICExLCBpKCkpIDogeC53cmFwcGVyLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24oKSB7IHggJiYgKHguYXV0b3BsYXlQYXVzZWQgPSAhMSwgeC5hdXRvcGxheWluZyA/IGkoKSA6IHguc3RvcEF1dG9wbGF5KCkpIH0pKSB9LCB4Lm1pblRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gLXguc25hcEdyaWRbMF0gfSwgeC5tYXhUcmFuc2xhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIC14LnNuYXBHcmlkW3guc25hcEdyaWQubGVuZ3RoIC0gMV0gfSwgeC51cGRhdGVBdXRvSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSwgYSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiYXV0b1wiICE9PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ICYmIHgucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCBNYXRoLmNlaWwoeC5wYXJhbXMuc2xpZGVzUGVyVmlldyk7IGUrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHguYWN0aXZlSW5kZXggKyBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA+IHguc2xpZGVzLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaCh4LnNsaWRlcy5lcShzKVswXSlcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgYS5wdXNoKHguc2xpZGVzLmVxKHguYWN0aXZlSW5kZXgpWzBdKTtcclxuICAgICAgICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCBhLmxlbmd0aDsgZSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGFbZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBhW2VdLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHIgPiB0ID8gciA6IHRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ICYmIHgud3JhcHBlci5jc3MoXCJoZWlnaHRcIiwgdCArIFwicHhcIilcclxuICAgICAgICAgICAgfSwgeC51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSwgYTtcclxuICAgICAgICAgICAgICAgIGUgPSB2b2lkIDAgIT09IHgucGFyYW1zLndpZHRoID8geC5wYXJhbXMud2lkdGggOiB4LmNvbnRhaW5lclswXS5jbGllbnRXaWR0aCwgYSA9IHZvaWQgMCAhPT0geC5wYXJhbXMuaGVpZ2h0ID8geC5wYXJhbXMuaGVpZ2h0IDogeC5jb250YWluZXJbMF0uY2xpZW50SGVpZ2h0LCAwID09PSBlICYmIHguaXNIb3Jpem9udGFsKCkgfHwgMCA9PT0gYSAmJiAheC5pc0hvcml6b250YWwoKSB8fCAoZSA9IGUgLSBwYXJzZUludCh4LmNvbnRhaW5lci5jc3MoXCJwYWRkaW5nLWxlZnRcIiksIDEwKSAtIHBhcnNlSW50KHguY29udGFpbmVyLmNzcyhcInBhZGRpbmctcmlnaHRcIiksIDEwKSwgYSA9IGEgLSBwYXJzZUludCh4LmNvbnRhaW5lci5jc3MoXCJwYWRkaW5nLXRvcFwiKSwgMTApIC0gcGFyc2VJbnQoeC5jb250YWluZXIuY3NzKFwicGFkZGluZy1ib3R0b21cIiksIDEwKSwgeC53aWR0aCA9IGUsIHguaGVpZ2h0ID0gYSwgeC5zaXplID0geC5pc0hvcml6b250YWwoKSA/IHgud2lkdGggOiB4LmhlaWdodClcclxuICAgICAgICAgICAgfSwgeC51cGRhdGVTbGlkZXNTaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB4LnNsaWRlcyA9IHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlQ2xhc3MpLCB4LnNuYXBHcmlkID0gW10sIHguc2xpZGVzR3JpZCA9IFtdLCB4LnNsaWRlc1NpemVzR3JpZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGUsIGEgPSB4LnBhcmFtcy5zcGFjZUJldHdlZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IC14LnBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB4LnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiBhICYmIGEuaW5kZXhPZihcIiVcIikgPj0gMCAmJiAoYSA9IHBhcnNlRmxvYXQoYS5yZXBsYWNlKFwiJVwiLCBcIlwiKSkgLyAxMDAgKiB4LnNpemUpLCB4LnZpcnR1YWxTaXplID0gLWEsIHgucnRsID8geC5zbGlkZXMuY3NzKHsgbWFyZ2luTGVmdDogXCJcIiwgbWFyZ2luVG9wOiBcIlwiIH0pIDogeC5zbGlkZXMuY3NzKHsgbWFyZ2luUmlnaHQ6IFwiXCIsIG1hcmdpbkJvdHRvbTogXCJcIiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxICYmIChuID0gTWF0aC5mbG9vcih4LnNsaWRlcy5sZW5ndGggLyB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pID09PSB4LnNsaWRlcy5sZW5ndGggLyB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPyB4LnNsaWRlcy5sZW5ndGggOiBNYXRoLmNlaWwoeC5zbGlkZXMubGVuZ3RoIC8geC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSAqIHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbiwgXCJhdXRvXCIgIT09IHgucGFyYW1zLnNsaWRlc1BlclZpZXcgJiYgXCJyb3dcIiA9PT0geC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uRmlsbCAmJiAobiA9IE1hdGgubWF4KG4sIHgucGFyYW1zLnNsaWRlc1BlclZpZXcgKiB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8sIGwgPSB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuIC8gbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHAgLSAoeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uICogcCAtIHguc2xpZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0gMDsgZSA8IHguc2xpZGVzLmxlbmd0aDsgZSsrKSB7IG8gPSAwOyB2YXIgbSA9IHguc2xpZGVzLmVxKGUpOyBpZiAoeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSkgeyB2YXIgdSwgYywgZzsgXCJjb2x1bW5cIiA9PT0geC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uRmlsbCA/IChjID0gTWF0aC5mbG9vcihlIC8gbCksIGcgPSBlIC0gYyAqIGwsIChjID4gZCB8fCBjID09PSBkICYmIGcgPT09IGwgLSAxKSAmJiArK2cgPj0gbCAmJiAoZyA9IDAsIGMrKyksIHUgPSBjICsgZyAqIG4gLyBsLCBtLmNzcyh7IFwiLXdlYmtpdC1ib3gtb3JkaW5hbC1ncm91cFwiOiB1LCBcIi1tb3otYm94LW9yZGluYWwtZ3JvdXBcIjogdSwgXCItbXMtZmxleC1vcmRlclwiOiB1LCBcIi13ZWJraXQtb3JkZXJcIjogdSwgb3JkZXI6IHUgfSkpIDogKGcgPSBNYXRoLmZsb29yKGUgLyBwKSwgYyA9IGUgLSBnICogcCksIG0uY3NzKFwibWFyZ2luLVwiICsgKHguaXNIb3Jpem9udGFsKCkgPyBcInRvcFwiIDogXCJsZWZ0XCIpLCAwICE9PSBnICYmIHgucGFyYW1zLnNwYWNlQmV0d2VlbiAmJiB4LnBhcmFtcy5zcGFjZUJldHdlZW4gKyBcInB4XCIpLmF0dHIoXCJkYXRhLXN3aXBlci1jb2x1bW5cIiwgYykuYXR0cihcImRhdGEtc3dpcGVyLXJvd1wiLCBnKSB9IFwibm9uZVwiICE9PSBtLmNzcyhcImRpc3BsYXlcIikgJiYgKFwiYXV0b1wiID09PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID8gKG8gPSB4LmlzSG9yaXpvbnRhbCgpID8gbS5vdXRlcldpZHRoKCEwKSA6IG0ub3V0ZXJIZWlnaHQoITApLCB4LnBhcmFtcy5yb3VuZExlbmd0aHMgJiYgKG8gPSByKG8pKSkgOiAobyA9ICh4LnNpemUgLSAoeC5wYXJhbXMuc2xpZGVzUGVyVmlldyAtIDEpICogYSkgLyB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3LCB4LnBhcmFtcy5yb3VuZExlbmd0aHMgJiYgKG8gPSByKG8pKSwgeC5pc0hvcml6b250YWwoKSA/IHguc2xpZGVzW2VdLnN0eWxlLndpZHRoID0gbyArIFwicHhcIiA6IHguc2xpZGVzW2VdLnN0eWxlLmhlaWdodCA9IG8gKyBcInB4XCIpLCB4LnNsaWRlc1tlXS5zd2lwZXJTbGlkZVNpemUgPSBvLCB4LnNsaWRlc1NpemVzR3JpZC5wdXNoKG8pLCB4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/ICh0ID0gdCArIG8gLyAyICsgcyAvIDIgKyBhLCAwID09PSBzICYmIDAgIT09IGUgJiYgKHQgPSB0IC0geC5zaXplIC8gMiAtIGEpLCAwID09PSBlICYmICh0ID0gdCAtIHguc2l6ZSAvIDIgLSBhKSwgTWF0aC5hYnModCkgPCAuMDAxICYmICh0ID0gMCksIGkgJSB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PSAwICYmIHguc25hcEdyaWQucHVzaCh0KSwgeC5zbGlkZXNHcmlkLnB1c2godCkpIDogKGkgJSB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PSAwICYmIHguc25hcEdyaWQucHVzaCh0KSwgeC5zbGlkZXNHcmlkLnB1c2godCksIHQgPSB0ICsgbyArIGEpLCB4LnZpcnR1YWxTaXplICs9IG8gKyBhLCBzID0gbywgaSsrKSB9XHJcbiAgICAgICAgICAgICAgICAgICAgeC52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHgudmlydHVhbFNpemUsIHguc2l6ZSkgKyB4LnBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5ydGwgJiYgeC53cm9uZ1JUTCAmJiAoXCJzbGlkZVwiID09PSB4LnBhcmFtcy5lZmZlY3QgfHwgXCJjb3ZlcmZsb3dcIiA9PT0geC5wYXJhbXMuZWZmZWN0KSAmJiB4LndyYXBwZXIuY3NzKHsgd2lkdGg6IHgudmlydHVhbFNpemUgKyB4LnBhcmFtcy5zcGFjZUJldHdlZW4gKyBcInB4XCIgfSksIHguc3VwcG9ydC5mbGV4Ym94ICYmICF4LnBhcmFtcy5zZXRXcmFwcGVyU2l6ZSB8fCAoeC5pc0hvcml6b250YWwoKSA/IHgud3JhcHBlci5jc3MoeyB3aWR0aDogeC52aXJ0dWFsU2l6ZSArIHgucGFyYW1zLnNwYWNlQmV0d2VlbiArIFwicHhcIiB9KSA6IHgud3JhcHBlci5jc3MoeyBoZWlnaHQ6IHgudmlydHVhbFNpemUgKyB4LnBhcmFtcy5zcGFjZUJldHdlZW4gKyBcInB4XCIgfSkpLCB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxICYmICh4LnZpcnR1YWxTaXplID0gKG8gKyB4LnBhcmFtcy5zcGFjZUJldHdlZW4pICogbiwgeC52aXJ0dWFsU2l6ZSA9IE1hdGguY2VpbCh4LnZpcnR1YWxTaXplIC8geC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSAtIHgucGFyYW1zLnNwYWNlQmV0d2VlbiwgeC5pc0hvcml6b250YWwoKSA/IHgud3JhcHBlci5jc3MoeyB3aWR0aDogeC52aXJ0dWFsU2l6ZSArIHgucGFyYW1zLnNwYWNlQmV0d2VlbiArIFwicHhcIiB9KSA6IHgud3JhcHBlci5jc3MoeyBoZWlnaHQ6IHgudmlydHVhbFNpemUgKyB4LnBhcmFtcy5zcGFjZUJldHdlZW4gKyBcInB4XCIgfSksIHgucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGggPSBbXSwgZSA9IDA7IGUgPCB4LnNuYXBHcmlkLmxlbmd0aDsgZSsrKSB4LnNuYXBHcmlkW2VdIDwgeC52aXJ0dWFsU2l6ZSArIHguc25hcEdyaWRbMF0gJiYgaC5wdXNoKHguc25hcEdyaWRbZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LnNuYXBHcmlkID0gaFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXgucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaCA9IFtdLCBlID0gMDsgZSA8IHguc25hcEdyaWQubGVuZ3RoOyBlKyspIHguc25hcEdyaWRbZV0gPD0geC52aXJ0dWFsU2l6ZSAtIHguc2l6ZSAmJiBoLnB1c2goeC5zbmFwR3JpZFtlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHguc25hcEdyaWQgPSBoLCBNYXRoLmZsb29yKHgudmlydHVhbFNpemUgLSB4LnNpemUpIC0gTWF0aC5mbG9vcih4LnNuYXBHcmlkW3guc25hcEdyaWQubGVuZ3RoIC0gMV0pID4gMSAmJiB4LnNuYXBHcmlkLnB1c2goeC52aXJ0dWFsU2l6ZSAtIHguc2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0geC5zbmFwR3JpZC5sZW5ndGggJiYgKHguc25hcEdyaWQgPSBbMF0pLCAwICE9PSB4LnBhcmFtcy5zcGFjZUJldHdlZW4gJiYgKHguaXNIb3Jpem9udGFsKCkgPyB4LnJ0bCA/IHguc2xpZGVzLmNzcyh7IG1hcmdpbkxlZnQ6IGEgKyBcInB4XCIgfSkgOiB4LnNsaWRlcy5jc3MoeyBtYXJnaW5SaWdodDogYSArIFwicHhcIiB9KSA6IHguc2xpZGVzLmNzcyh7IG1hcmdpbkJvdHRvbTogYSArIFwicHhcIiB9KSksIHgucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgJiYgeC51cGRhdGVTbGlkZXNPZmZzZXQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB4LnVwZGF0ZVNsaWRlc09mZnNldCA9IGZ1bmN0aW9uKCkgeyBmb3IgKHZhciBlID0gMDsgZSA8IHguc2xpZGVzLmxlbmd0aDsgZSsrKSB4LnNsaWRlc1tlXS5zd2lwZXJTbGlkZU9mZnNldCA9IHguaXNIb3Jpem9udGFsKCkgPyB4LnNsaWRlc1tlXS5vZmZzZXRMZWZ0IDogeC5zbGlkZXNbZV0ub2Zmc2V0VG9wIH0sIHguY3VycmVudFNsaWRlc1BlclZpZXcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlLCBhLCB0ID0gMTtcclxuICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcykgeyB2YXIgcywgciA9IHguc2xpZGVzW3guYWN0aXZlSW5kZXhdLnN3aXBlclNsaWRlU2l6ZTsgZm9yIChlID0geC5hY3RpdmVJbmRleCArIDE7IGUgPCB4LnNsaWRlcy5sZW5ndGg7IGUrKykgeC5zbGlkZXNbZV0gJiYgIXMgJiYgKHIgKz0geC5zbGlkZXNbZV0uc3dpcGVyU2xpZGVTaXplLCB0KyssIHIgPiB4LnNpemUgJiYgKHMgPSAhMCkpOyBmb3IgKGEgPSB4LmFjdGl2ZUluZGV4IC0gMTsgYSA+PSAwOyBhLS0pIHguc2xpZGVzW2FdICYmICFzICYmIChyICs9IHguc2xpZGVzW2FdLnN3aXBlclNsaWRlU2l6ZSwgdCsrLCByID4geC5zaXplICYmIChzID0gITApKSB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGUgPSB4LmFjdGl2ZUluZGV4ICsgMTsgZSA8IHguc2xpZGVzLmxlbmd0aDsgZSsrKSB4LnNsaWRlc0dyaWRbZV0gLSB4LnNsaWRlc0dyaWRbeC5hY3RpdmVJbmRleF0gPCB4LnNpemUgJiYgdCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRcclxuICAgICAgICAgICAgfSwgeC51cGRhdGVTbGlkZXNQcm9ncmVzcyA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUgJiYgKGUgPSB4LnRyYW5zbGF0ZSB8fCAwKSwgMCAhPT0geC5zbGlkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB4LnNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCAmJiB4LnVwZGF0ZVNsaWRlc09mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gLWU7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5ydGwgJiYgKGEgPSBlKSwgeC5zbGlkZXMucmVtb3ZlQ2xhc3MoeC5wYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgeC5zbGlkZXMubGVuZ3RoOyB0KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB4LnNsaWRlc1t0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAoYSArICh4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHgubWluVHJhbnNsYXRlKCkgOiAwKSAtIHMuc3dpcGVyU2xpZGVPZmZzZXQpIC8gKHMuc3dpcGVyU2xpZGVTaXplICsgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAtKGEgLSBzLnN3aXBlclNsaWRlT2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gaSArIHguc2xpZGVzU2l6ZXNHcmlkW3RdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgPj0gMCAmJiBpIDwgeC5zaXplIHx8IG4gPiAwICYmIG4gPD0geC5zaXplIHx8IGkgPD0gMCAmJiBuID49IHguc2l6ZSkgJiYgeC5zbGlkZXMuZXEodCkuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcy5wcm9ncmVzcyA9IHgucnRsID8gLXIgOiByXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB4LnVwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0geC50cmFuc2xhdGUgfHwgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHgubWF4VHJhbnNsYXRlKCkgLSB4Lm1pblRyYW5zbGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB4LmlzQmVnaW5uaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSB4LmlzRW5kO1xyXG4gICAgICAgICAgICAgICAgMCA9PT0gYSA/ICh4LnByb2dyZXNzID0gMCwgeC5pc0JlZ2lubmluZyA9IHguaXNFbmQgPSAhMCkgOiAoeC5wcm9ncmVzcyA9IChlIC0geC5taW5UcmFuc2xhdGUoKSkgLyBhLCB4LmlzQmVnaW5uaW5nID0geC5wcm9ncmVzcyA8PSAwLCB4LmlzRW5kID0geC5wcm9ncmVzcyA+PSAxKSwgeC5pc0JlZ2lubmluZyAmJiAhdCAmJiB4LmVtaXQoXCJvblJlYWNoQmVnaW5uaW5nXCIsIHgpLCB4LmlzRW5kICYmICFzICYmIHguZW1pdChcIm9uUmVhY2hFbmRcIiwgeCksIHgucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgJiYgeC51cGRhdGVTbGlkZXNQcm9ncmVzcyhlKSwgeC5lbWl0KFwib25Qcm9ncmVzc1wiLCB4LCB4LnByb2dyZXNzKVxyXG4gICAgICAgICAgICB9LCB4LnVwZGF0ZUFjdGl2ZUluZGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSwgYSwgdCwgcyA9IHgucnRsID8geC50cmFuc2xhdGUgOiAteC50cmFuc2xhdGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgeC5zbGlkZXNHcmlkLmxlbmd0aDsgYSsrKSB2b2lkIDAgIT09IHguc2xpZGVzR3JpZFthICsgMV0gPyBzID49IHguc2xpZGVzR3JpZFthXSAmJiBzIDwgeC5zbGlkZXNHcmlkW2EgKyAxXSAtICh4LnNsaWRlc0dyaWRbYSArIDFdIC0geC5zbGlkZXNHcmlkW2FdKSAvIDIgPyBlID0gYSA6IHMgPj0geC5zbGlkZXNHcmlkW2FdICYmIHMgPCB4LnNsaWRlc0dyaWRbYSArIDFdICYmIChlID0gYSArIDEpIDogcyA+PSB4LnNsaWRlc0dyaWRbYV0gJiYgKGUgPSBhKTtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLm5vcm1hbGl6ZVNsaWRlSW5kZXggJiYgKGUgPCAwIHx8IHZvaWQgMCA9PT0gZSkgJiYgKGUgPSAwKSwgdCA9IE1hdGguZmxvb3IoZSAvIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwKSwgdCA+PSB4LnNuYXBHcmlkLmxlbmd0aCAmJiAodCA9IHguc25hcEdyaWQubGVuZ3RoIC0gMSksIGUgIT09IHguYWN0aXZlSW5kZXggJiYgKHguc25hcEluZGV4ID0gdCwgeC5wcmV2aW91c0luZGV4ID0geC5hY3RpdmVJbmRleCwgeC5hY3RpdmVJbmRleCA9IGUsIHgudXBkYXRlQ2xhc3NlcygpLCB4LnVwZGF0ZVJlYWxJbmRleCgpKVxyXG4gICAgICAgICAgICB9LCB4LnVwZGF0ZVJlYWxJbmRleCA9IGZ1bmN0aW9uKCkgeyB4LnJlYWxJbmRleCA9IHBhcnNlSW50KHguc2xpZGVzLmVxKHguYWN0aXZlSW5kZXgpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSB8fCB4LmFjdGl2ZUluZGV4LCAxMCkgfSwgeC51cGRhdGVDbGFzc2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB4LnNsaWRlcy5yZW1vdmVDbGFzcyh4LnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzICsgXCIgXCIgKyB4LnBhcmFtcy5zbGlkZU5leHRDbGFzcyArIFwiIFwiICsgeC5wYXJhbXMuc2xpZGVQcmV2Q2xhc3MgKyBcIiBcIiArIHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MgKyBcIiBcIiArIHgucGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzICsgXCIgXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHguc2xpZGVzLmVxKHguYWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgYS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKSwgcy5sb29wICYmIChhLmhhc0NsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpID8geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArIFwiOm5vdCguXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgJylbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgeC5yZWFsSW5kZXggKyAnXCJdJykuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcykgOiB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyB4LnJlYWxJbmRleCArICdcIl0nKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGEubmV4dChcIi5cIiArIHgucGFyYW1zLnNsaWRlQ2xhc3MpLmFkZENsYXNzKHgucGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgJiYgMCA9PT0gdC5sZW5ndGggJiYgKHQgPSB4LnNsaWRlcy5lcSgwKSwgdC5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZU5leHRDbGFzcykpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBhLnByZXYoXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMubG9vcCAmJiAwID09PSByLmxlbmd0aCAmJiAociA9IHguc2xpZGVzLmVxKC0xKSwgci5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZVByZXZDbGFzcykpLCBzLmxvb3AgJiYgKHQuaGFzQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykgPyB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgXCI6bm90KC5cIiArIHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyAnKVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyB0LmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSArICdcIl0nKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcykgOiB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyB0LmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSArICdcIl0nKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyksIHIuaGFzQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykgPyB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgXCI6bm90KC5cIiArIHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyAnKVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyByLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSArICdcIl0nKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcykgOiB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyByLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSArICdcIl0nKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcykpLCB4LnBhZ2luYXRpb25Db250YWluZXIgJiYgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbiA9IHgucGFyYW1zLmxvb3AgPyBNYXRoLmNlaWwoKHguc2xpZGVzLmxlbmd0aCAtIDIgKiB4Lmxvb3BlZFNsaWRlcykgLyB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiB4LnNuYXBHcmlkLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMubG9vcCA/IChpID0gTWF0aC5jZWlsKCh4LmFjdGl2ZUluZGV4IC0geC5sb29wZWRTbGlkZXMpIC8geC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApLCBpID4geC5zbGlkZXMubGVuZ3RoIC0gMSAtIDIgKiB4Lmxvb3BlZFNsaWRlcyAmJiAoaSAtPSB4LnNsaWRlcy5sZW5ndGggLSAyICogeC5sb29wZWRTbGlkZXMpLCBpID4gbiAtIDEgJiYgKGkgLT0gbiksIGkgPCAwICYmIFwiYnVsbGV0c1wiICE9PSB4LnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAmJiAoaSA9IG4gKyBpKSkgOiBpID0gdm9pZCAwICE9PSB4LnNuYXBJbmRleCA/IHguc25hcEluZGV4IDogeC5hY3RpdmVJbmRleCB8fCAwLCBcImJ1bGxldHNcIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUgJiYgeC5idWxsZXRzICYmIHguYnVsbGV0cy5sZW5ndGggPiAwICYmICh4LmJ1bGxldHMucmVtb3ZlQ2xhc3MoeC5wYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpLCB4LnBhZ2luYXRpb25Db250YWluZXIubGVuZ3RoID4gMSA/IHguYnVsbGV0cy5lYWNoKGZ1bmN0aW9uKCkgeyBlKHRoaXMpLmluZGV4KCkgPT09IGkgJiYgZSh0aGlzKS5hZGRDbGFzcyh4LnBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcykgfSkgOiB4LmJ1bGxldHMuZXEoaSkuYWRkQ2xhc3MoeC5wYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpKSwgXCJmcmFjdGlvblwiID09PSB4LnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAmJiAoeC5wYWdpbmF0aW9uQ29udGFpbmVyLmZpbmQoXCIuXCIgKyB4LnBhcmFtcy5wYWdpbmF0aW9uQ3VycmVudENsYXNzKS50ZXh0KGkgKyAxKSwgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmZpbmQoXCIuXCIgKyB4LnBhcmFtcy5wYWdpbmF0aW9uVG90YWxDbGFzcykudGV4dChuKSksIFwicHJvZ3Jlc3NcIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSAoaSArIDEpIC8gbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHguaXNIb3Jpem9udGFsKCkgfHwgKHAgPSBvLCBsID0gMSksIHgucGFnaW5hdGlvbkNvbnRhaW5lci5maW5kKFwiLlwiICsgeC5wYXJhbXMucGFnaW5hdGlvblByb2dyZXNzYmFyQ2xhc3MpLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZVgoXCIgKyBsICsgXCIpIHNjYWxlWShcIiArIHAgKyBcIilcIikudHJhbnNpdGlvbih4LnBhcmFtcy5zcGVlZClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjdXN0b21cIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUgJiYgeC5wYXJhbXMucGFnaW5hdGlvbkN1c3RvbVJlbmRlciAmJiAoeC5wYWdpbmF0aW9uQ29udGFpbmVyLmh0bWwoeC5wYXJhbXMucGFnaW5hdGlvbkN1c3RvbVJlbmRlcih4LCBpICsgMSwgbikpLCB4LmVtaXQoXCJvblBhZ2luYXRpb25SZW5kZXJlZFwiLCB4LCB4LnBhZ2luYXRpb25Db250YWluZXJbMF0pKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeC5wYXJhbXMubG9vcCB8fCAoeC5wYXJhbXMucHJldkJ1dHRvbiAmJiB4LnByZXZCdXR0b24gJiYgeC5wcmV2QnV0dG9uLmxlbmd0aCA+IDAgJiYgKHguaXNCZWdpbm5pbmcgPyAoeC5wcmV2QnV0dG9uLmFkZENsYXNzKHgucGFyYW1zLmJ1dHRvbkRpc2FibGVkQ2xhc3MpLCB4LnBhcmFtcy5hMTF5ICYmIHguYTExeSAmJiB4LmExMXkuZGlzYWJsZSh4LnByZXZCdXR0b24pKSA6ICh4LnByZXZCdXR0b24ucmVtb3ZlQ2xhc3MoeC5wYXJhbXMuYnV0dG9uRGlzYWJsZWRDbGFzcyksIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHguYTExeS5lbmFibGUoeC5wcmV2QnV0dG9uKSkpLCB4LnBhcmFtcy5uZXh0QnV0dG9uICYmIHgubmV4dEJ1dHRvbiAmJiB4Lm5leHRCdXR0b24ubGVuZ3RoID4gMCAmJiAoeC5pc0VuZCA/ICh4Lm5leHRCdXR0b24uYWRkQ2xhc3MoeC5wYXJhbXMuYnV0dG9uRGlzYWJsZWRDbGFzcyksIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHguYTExeS5kaXNhYmxlKHgubmV4dEJ1dHRvbikpIDogKHgubmV4dEJ1dHRvbi5yZW1vdmVDbGFzcyh4LnBhcmFtcy5idXR0b25EaXNhYmxlZENsYXNzKSwgeC5wYXJhbXMuYTExeSAmJiB4LmExMXkgJiYgeC5hMTF5LmVuYWJsZSh4Lm5leHRCdXR0b24pKSkpXHJcbiAgICAgICAgICAgIH0sIHgudXBkYXRlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLnBhZ2luYXRpb24gJiYgeC5wYWdpbmF0aW9uQ29udGFpbmVyICYmIHgucGFnaW5hdGlvbkNvbnRhaW5lci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcImJ1bGxldHNcIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IHgucGFyYW1zLmxvb3AgPyBNYXRoLmNlaWwoKHguc2xpZGVzLmxlbmd0aCAtIDIgKiB4Lmxvb3BlZFNsaWRlcykgLyB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiB4LnNuYXBHcmlkLmxlbmd0aCwgdCA9IDA7IHQgPCBhOyB0KyspIGUgKz0geC5wYXJhbXMucGFnaW5hdGlvbkJ1bGxldFJlbmRlciA/IHgucGFyYW1zLnBhZ2luYXRpb25CdWxsZXRSZW5kZXIoeCwgdCwgeC5wYXJhbXMuYnVsbGV0Q2xhc3MpIDogXCI8XCIgKyB4LnBhcmFtcy5wYWdpbmF0aW9uRWxlbWVudCArICcgY2xhc3M9XCInICsgeC5wYXJhbXMuYnVsbGV0Q2xhc3MgKyAnXCI+PC8nICsgeC5wYXJhbXMucGFnaW5hdGlvbkVsZW1lbnQgKyBcIj5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmh0bWwoZSksIHguYnVsbGV0cyA9IHgucGFnaW5hdGlvbkNvbnRhaW5lci5maW5kKFwiLlwiICsgeC5wYXJhbXMuYnVsbGV0Q2xhc3MpLCB4LnBhcmFtcy5wYWdpbmF0aW9uQ2xpY2thYmxlICYmIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHguYTExeS5pbml0UGFnaW5hdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFwiZnJhY3Rpb25cIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUgJiYgKGUgPSB4LnBhcmFtcy5wYWdpbmF0aW9uRnJhY3Rpb25SZW5kZXIgPyB4LnBhcmFtcy5wYWdpbmF0aW9uRnJhY3Rpb25SZW5kZXIoeCwgeC5wYXJhbXMucGFnaW5hdGlvbkN1cnJlbnRDbGFzcywgeC5wYXJhbXMucGFnaW5hdGlvblRvdGFsQ2xhc3MpIDogJzxzcGFuIGNsYXNzPVwiJyArIHgucGFyYW1zLnBhZ2luYXRpb25DdXJyZW50Q2xhc3MgKyAnXCI+PC9zcGFuPiAvIDxzcGFuIGNsYXNzPVwiJyArIHgucGFyYW1zLnBhZ2luYXRpb25Ub3RhbENsYXNzICsgJ1wiPjwvc3Bhbj4nLCB4LnBhZ2luYXRpb25Db250YWluZXIuaHRtbChlKSksIFwicHJvZ3Jlc3NcIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUgJiYgKGUgPSB4LnBhcmFtcy5wYWdpbmF0aW9uUHJvZ3Jlc3NSZW5kZXIgPyB4LnBhcmFtcy5wYWdpbmF0aW9uUHJvZ3Jlc3NSZW5kZXIoeCwgeC5wYXJhbXMucGFnaW5hdGlvblByb2dyZXNzYmFyQ2xhc3MpIDogJzxzcGFuIGNsYXNzPVwiJyArIHgucGFyYW1zLnBhZ2luYXRpb25Qcm9ncmVzc2JhckNsYXNzICsgJ1wiPjwvc3Bhbj4nLCB4LnBhZ2luYXRpb25Db250YWluZXIuaHRtbChlKSksIFwiY3VzdG9tXCIgIT09IHgucGFyYW1zLnBhZ2luYXRpb25UeXBlICYmIHguZW1pdChcIm9uUGFnaW5hdGlvblJlbmRlcmVkXCIsIHgsIHgucGFnaW5hdGlvbkNvbnRhaW5lclswXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC51cGRhdGUgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucnRsLCB4LnRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gTWF0aC5taW4oTWF0aC5tYXgoeC50cmFuc2xhdGUsIHgubWF4VHJhbnNsYXRlKCkpLCB4Lm1pblRyYW5zbGF0ZSgpKSwgeC5zZXRXcmFwcGVyVHJhbnNsYXRlKHQpLCB4LnVwZGF0ZUFjdGl2ZUluZGV4KCksIHgudXBkYXRlQ2xhc3NlcygpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeCkgeyB4LnVwZGF0ZUNvbnRhaW5lclNpemUoKSwgeC51cGRhdGVTbGlkZXNTaXplKCksIHgudXBkYXRlUHJvZ3Jlc3MoKSwgeC51cGRhdGVQYWdpbmF0aW9uKCksIHgudXBkYXRlQ2xhc3NlcygpLCB4LnBhcmFtcy5zY3JvbGxiYXIgJiYgeC5zY3JvbGxiYXIgJiYgeC5zY3JvbGxiYXIuc2V0KCk7IHZhciB0OyBpZiAoZSkgeyB4LmNvbnRyb2xsZXIgJiYgeC5jb250cm9sbGVyLnNwbGluZSAmJiAoeC5jb250cm9sbGVyLnNwbGluZSA9IHZvaWQgMCksIHgucGFyYW1zLmZyZWVNb2RlID8gKGEoKSwgeC5wYXJhbXMuYXV0b0hlaWdodCAmJiB4LnVwZGF0ZUF1dG9IZWlnaHQoKSkgOiAoKFwiYXV0b1wiID09PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3IHx8IHgucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiB4LmlzRW5kICYmICF4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHguc2xpZGVUbyh4LnNsaWRlcy5sZW5ndGggLSAxLCAwLCAhMSwgITApIDogeC5zbGlkZVRvKHguYWN0aXZlSW5kZXgsIDAsICExLCAhMCkpIHx8IGEoKSB9IGVsc2UgeC5wYXJhbXMuYXV0b0hlaWdodCAmJiB4LnVwZGF0ZUF1dG9IZWlnaHQoKSB9XHJcbiAgICAgICAgICAgIH0sIHgub25SZXNpemUgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5vbkJlZm9yZVJlc2l6ZSAmJiB4LnBhcmFtcy5vbkJlZm9yZVJlc2l6ZSh4KSwgeC5wYXJhbXMuYnJlYWtwb2ludHMgJiYgeC5zZXRCcmVha3BvaW50KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYsXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQ7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ID0geC5wYXJhbXMuYWxsb3dTd2lwZVRvTmV4dCA9ICEwLCB4LnVwZGF0ZUNvbnRhaW5lclNpemUoKSwgeC51cGRhdGVTbGlkZXNTaXplKCksIChcImF1dG9cIiA9PT0geC5wYXJhbXMuc2xpZGVzUGVyVmlldyB8fCB4LnBhcmFtcy5mcmVlTW9kZSB8fCBlKSAmJiB4LnVwZGF0ZVBhZ2luYXRpb24oKSwgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyLnNldCgpLCB4LmNvbnRyb2xsZXIgJiYgeC5jb250cm9sbGVyLnNwbGluZSAmJiAoeC5jb250cm9sbGVyLnNwbGluZSA9IHZvaWQgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9ICExO1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmZyZWVNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1pbihNYXRoLm1heCh4LnRyYW5zbGF0ZSwgeC5tYXhUcmFuc2xhdGUoKSksIHgubWluVHJhbnNsYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHguc2V0V3JhcHBlclRyYW5zbGF0ZShyKSwgeC51cGRhdGVBY3RpdmVJbmRleCgpLCB4LnVwZGF0ZUNsYXNzZXMoKSwgeC5wYXJhbXMuYXV0b0hlaWdodCAmJiB4LnVwZGF0ZUF1dG9IZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHgudXBkYXRlQ2xhc3NlcygpLCBzID0gKFwiYXV0b1wiID09PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3IHx8IHgucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiB4LmlzRW5kICYmICF4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHguc2xpZGVUbyh4LnNsaWRlcy5sZW5ndGggLSAxLCAwLCAhMSwgITApIDogeC5zbGlkZVRvKHguYWN0aXZlSW5kZXgsIDAsICExLCAhMCk7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5sYXp5TG9hZGluZyAmJiAhcyAmJiB4LmxhenkgJiYgeC5sYXp5LmxvYWQoKSwgeC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiA9IGEsIHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgPSB0LCB4LnBhcmFtcy5vbkFmdGVyUmVzaXplICYmIHgucGFyYW1zLm9uQWZ0ZXJSZXNpemUoeClcclxuICAgICAgICAgICAgfSwgeC50b3VjaEV2ZW50c0Rlc2t0b3AgPSB7IHN0YXJ0OiBcIm1vdXNlZG93blwiLCBtb3ZlOiBcIm1vdXNlbW92ZVwiLCBlbmQ6IFwibW91c2V1cFwiIH0sIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgPyB4LnRvdWNoRXZlbnRzRGVza3RvcCA9IHsgc3RhcnQ6IFwicG9pbnRlcmRvd25cIiwgbW92ZTogXCJwb2ludGVybW92ZVwiLCBlbmQ6IFwicG9pbnRlcnVwXCIgfSA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCAmJiAoeC50b3VjaEV2ZW50c0Rlc2t0b3AgPSB7IHN0YXJ0OiBcIk1TUG9pbnRlckRvd25cIiwgbW92ZTogXCJNU1BvaW50ZXJNb3ZlXCIsIGVuZDogXCJNU1BvaW50ZXJVcFwiIH0pLCB4LnRvdWNoRXZlbnRzID0geyBzdGFydDogeC5zdXBwb3J0LnRvdWNoIHx8ICF4LnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiB4LnRvdWNoRXZlbnRzRGVza3RvcC5zdGFydCwgbW92ZTogeC5zdXBwb3J0LnRvdWNoIHx8ICF4LnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gXCJ0b3VjaG1vdmVcIiA6IHgudG91Y2hFdmVudHNEZXNrdG9wLm1vdmUsIGVuZDogeC5zdXBwb3J0LnRvdWNoIHx8ICF4LnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gXCJ0b3VjaGVuZFwiIDogeC50b3VjaEV2ZW50c0Rlc2t0b3AuZW5kIH0sICh3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkgJiYgKFwiY29udGFpbmVyXCIgPT09IHgucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID8geC5jb250YWluZXIgOiB4LndyYXBwZXIpLmFkZENsYXNzKFwic3dpcGVyLXdwOC1cIiArIHgucGFyYW1zLmRpcmVjdGlvbiksIHguaW5pdEV2ZW50cyA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gZSA/IFwib2ZmXCIgOiBcIm9uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IGUgPyBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiA6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBcImNvbnRhaW5lclwiID09PSB4LnBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA/IHguY29udGFpbmVyWzBdIDogeC53cmFwcGVyWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSB4LnN1cHBvcnQudG91Y2ggPyByIDogZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9ICEheC5wYXJhbXMubmVzdGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHguYnJvd3Nlci5pZSkgclt0XSh4LnRvdWNoRXZlbnRzLnN0YXJ0LCB4Lm9uVG91Y2hTdGFydCwgITEpLCBpW3RdKHgudG91Y2hFdmVudHMubW92ZSwgeC5vblRvdWNoTW92ZSwgbiksIGlbdF0oeC50b3VjaEV2ZW50cy5lbmQsIHgub25Ub3VjaEVuZCwgITEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguc3VwcG9ydC50b3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9ICEoXCJ0b3VjaHN0YXJ0XCIgIT09IHgudG91Y2hFdmVudHMuc3RhcnQgfHwgIXguc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgfHwgIXgucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHsgcGFzc2l2ZTogITAsIGNhcHR1cmU6ICExIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbdF0oeC50b3VjaEV2ZW50cy5zdGFydCwgeC5vblRvdWNoU3RhcnQsIG8pLCByW3RdKHgudG91Y2hFdmVudHMubW92ZSwgeC5vblRvdWNoTW92ZSwgbiksIHJbdF0oeC50b3VjaEV2ZW50cy5lbmQsIHgub25Ub3VjaEVuZCwgbylcclxuICAgICAgICAgICAgICAgICAgICB9KHMuc2ltdWxhdGVUb3VjaCAmJiAheC5kZXZpY2UuaW9zICYmICF4LmRldmljZS5hbmRyb2lkIHx8IHMuc2ltdWxhdGVUb3VjaCAmJiAheC5zdXBwb3J0LnRvdWNoICYmIHguZGV2aWNlLmlvcykgJiYgKHJbdF0oXCJtb3VzZWRvd25cIiwgeC5vblRvdWNoU3RhcnQsICExKSwgZG9jdW1lbnRbdF0oXCJtb3VzZW1vdmVcIiwgeC5vblRvdWNoTW92ZSwgbiksIGRvY3VtZW50W3RdKFwibW91c2V1cFwiLCB4Lm9uVG91Y2hFbmQsICExKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpbmRvd1t0XShcInJlc2l6ZVwiLCB4Lm9uUmVzaXplKSwgeC5wYXJhbXMubmV4dEJ1dHRvbiAmJiB4Lm5leHRCdXR0b24gJiYgeC5uZXh0QnV0dG9uLmxlbmd0aCA+IDAgJiYgKHgubmV4dEJ1dHRvblthXShcImNsaWNrXCIsIHgub25DbGlja05leHQpLCB4LnBhcmFtcy5hMTF5ICYmIHguYTExeSAmJiB4Lm5leHRCdXR0b25bYV0oXCJrZXlkb3duXCIsIHguYTExeS5vbkVudGVyS2V5KSksIHgucGFyYW1zLnByZXZCdXR0b24gJiYgeC5wcmV2QnV0dG9uICYmIHgucHJldkJ1dHRvbi5sZW5ndGggPiAwICYmICh4LnByZXZCdXR0b25bYV0oXCJjbGlja1wiLCB4Lm9uQ2xpY2tQcmV2KSwgeC5wYXJhbXMuYTExeSAmJiB4LmExMXkgJiYgeC5wcmV2QnV0dG9uW2FdKFwia2V5ZG93blwiLCB4LmExMXkub25FbnRlcktleSkpLCB4LnBhcmFtcy5wYWdpbmF0aW9uICYmIHgucGFyYW1zLnBhZ2luYXRpb25DbGlja2FibGUgJiYgKHgucGFnaW5hdGlvbkNvbnRhaW5lclthXShcImNsaWNrXCIsIFwiLlwiICsgeC5wYXJhbXMuYnVsbGV0Q2xhc3MsIHgub25DbGlja0luZGV4KSwgeC5wYXJhbXMuYTExeSAmJiB4LmExMXkgJiYgeC5wYWdpbmF0aW9uQ29udGFpbmVyW2FdKFwia2V5ZG93blwiLCBcIi5cIiArIHgucGFyYW1zLmJ1bGxldENsYXNzLCB4LmExMXkub25FbnRlcktleSkpLCAoeC5wYXJhbXMucHJldmVudENsaWNrcyB8fCB4LnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pICYmIHJbdF0oXCJjbGlja1wiLCB4LnByZXZlbnRDbGlja3MsICEwKVxyXG4gICAgICAgICAgICB9LCB4LmF0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uKCkgeyB4LmluaXRFdmVudHMoKSB9LCB4LmRldGFjaEV2ZW50cyA9IGZ1bmN0aW9uKCkgeyB4LmluaXRFdmVudHMoITApIH0sIHguYWxsb3dDbGljayA9ICEwLCB4LnByZXZlbnRDbGlja3MgPSBmdW5jdGlvbihlKSB7IHguYWxsb3dDbGljayB8fCAoeC5wYXJhbXMucHJldmVudENsaWNrcyAmJiBlLnByZXZlbnREZWZhdWx0KCksIHgucGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiAmJiB4LmFuaW1hdGluZyAmJiAoZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSkpIH0sIHgub25DbGlja05leHQgPSBmdW5jdGlvbihlKSB7IGUucHJldmVudERlZmF1bHQoKSwgeC5pc0VuZCAmJiAheC5wYXJhbXMubG9vcCB8fCB4LnNsaWRlTmV4dCgpIH0sIHgub25DbGlja1ByZXYgPSBmdW5jdGlvbihlKSB7IGUucHJldmVudERlZmF1bHQoKSwgeC5pc0JlZ2lubmluZyAmJiAheC5wYXJhbXMubG9vcCB8fCB4LnNsaWRlUHJldigpIH0sIHgub25DbGlja0luZGV4ID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgYS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlKHRoaXMpLmluZGV4KCkgKiB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgJiYgKHQgKz0geC5sb29wZWRTbGlkZXMpLCB4LnNsaWRlVG8odClcclxuICAgICAgICAgICAgfSwgeC51cGRhdGVDbGlja2VkU2xpZGUgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG4oYSwgXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzKSxcclxuICAgICAgICAgICAgICAgICAgICBzID0gITE7XHJcbiAgICAgICAgICAgICAgICBpZiAodClcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHguc2xpZGVzLmxlbmd0aDsgcisrKSB4LnNsaWRlc1tyXSA9PT0gdCAmJiAocyA9ICEwKTtcclxuICAgICAgICAgICAgICAgIGlmICghdCB8fCAhcykgcmV0dXJuIHguY2xpY2tlZFNsaWRlID0gdm9pZCAwLCB2b2lkKHguY2xpY2tlZEluZGV4ID0gdm9pZCAwKTtcclxuICAgICAgICAgICAgICAgIGlmICh4LmNsaWNrZWRTbGlkZSA9IHQsIHguY2xpY2tlZEluZGV4ID0gZSh0KS5pbmRleCgpLCB4LnBhcmFtcy5zbGlkZVRvQ2xpY2tlZFNsaWRlICYmIHZvaWQgMCAhPT0geC5jbGlja2VkSW5kZXggJiYgeC5jbGlja2VkSW5kZXggIT09IHguYWN0aXZlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbyA9IHguY2xpY2tlZEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gXCJhdXRvXCIgPT09IHgucGFyYW1zLnNsaWRlc1BlclZpZXcgPyB4LmN1cnJlbnRTbGlkZXNQZXJWaWV3KCkgOiB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5sb29wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmFuaW1hdGluZykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFyc2VJbnQoZSh4LmNsaWNrZWRTbGlkZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLCAxMCksIHgucGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gbyA8IHgubG9vcGVkU2xpZGVzIC0gbCAvIDIgfHwgbyA+IHguc2xpZGVzLmxlbmd0aCAtIHgubG9vcGVkU2xpZGVzICsgbCAvIDIgPyAoeC5maXhMb29wKCksIG8gPSB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyBpICsgJ1wiXTpub3QoLicgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgXCIpXCIpLmVxKDApLmluZGV4KCksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHguc2xpZGVUbyhvKSB9LCAwKSkgOiB4LnNsaWRlVG8obykgOiBvID4geC5zbGlkZXMubGVuZ3RoIC0gbCA/ICh4LmZpeExvb3AoKSwgbyA9IHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlQ2xhc3MgKyAnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArIGkgKyAnXCJdOm5vdCguJyArIHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyBcIilcIikuZXEoMCkuaW5kZXgoKSwgc2V0VGltZW91dChmdW5jdGlvbigpIHsgeC5zbGlkZVRvKG8pIH0sIDApKSA6IHguc2xpZGVUbyhvKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB4LnNsaWRlVG8obylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGIsIEMsIFMsIHosIE0sIFAsIEUsIEksIGssIEQsIEwgPSBcImlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBidXR0b24sIHZpZGVvXCIsXHJcbiAgICAgICAgICAgICAgICBCID0gRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgIEggPSBbXTtcclxuICAgICAgICAgICAgeC5hbmltYXRpbmcgPSAhMSwgeC50b3VjaGVzID0geyBzdGFydFg6IDAsIHN0YXJ0WTogMCwgY3VycmVudFg6IDAsIGN1cnJlbnRZOiAwLCBkaWZmOiAwIH07XHJcbiAgICAgICAgICAgIHZhciBHLCBYO1xyXG4gICAgICAgICAgICB4Lm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhLm9yaWdpbmFsRXZlbnQgJiYgKGEgPSBhLm9yaWdpbmFsRXZlbnQpLCAoRyA9IFwidG91Y2hzdGFydFwiID09PSBhLnR5cGUpIHx8ICEoXCJ3aGljaFwiIGluIGEpIHx8IDMgIT09IGEud2hpY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMubm9Td2lwaW5nICYmIG4oYSwgXCIuXCIgKyB4LnBhcmFtcy5ub1N3aXBpbmdDbGFzcykpIHJldHVybiB2b2lkKHguYWxsb3dDbGljayA9ICEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXgucGFyYW1zLnN3aXBlSGFuZGxlciB8fCBuKGEsIHgucGFyYW1zLnN3aXBlSGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB4LnRvdWNoZXMuY3VycmVudFggPSBcInRvdWNoc3RhcnRcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogYS5wYWdlWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB4LnRvdWNoZXMuY3VycmVudFkgPSBcInRvdWNoc3RhcnRcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogYS5wYWdlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoeC5kZXZpY2UuaW9zICYmIHgucGFyYW1zLmlPU0VkZ2VTd2lwZURldGVjdGlvbiAmJiB0IDw9IHgucGFyYW1zLmlPU0VkZ2VTd2lwZVRocmVzaG9sZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiID0gITAsIEMgPSAhMSwgUyA9ICEwLCBNID0gdm9pZCAwLCBYID0gdm9pZCAwLCB4LnRvdWNoZXMuc3RhcnRYID0gdCwgeC50b3VjaGVzLnN0YXJ0WSA9IHMsIHogPSBEYXRlLm5vdygpLCB4LmFsbG93Q2xpY2sgPSAhMCwgeC51cGRhdGVDb250YWluZXJTaXplKCksIHguc3dpcGVEaXJlY3Rpb24gPSB2b2lkIDAsIHgucGFyYW1zLnRocmVzaG9sZCA+IDAgJiYgKEkgPSAhMSksIFwidG91Y2hzdGFydFwiICE9PSBhLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9ICEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUoYS50YXJnZXQpLmlzKEwpICYmIChyID0gITEpLCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGUoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuaXMoTCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCksIHIgJiYgYS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmVtaXQoXCJvblRvdWNoU3RhcnRcIiwgeCwgYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhLm9yaWdpbmFsRXZlbnQgJiYgKGEgPSBhLm9yaWdpbmFsRXZlbnQpLCAhRyB8fCBcIm1vdXNlbW92ZVwiICE9PSBhLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikgcmV0dXJuIHgudG91Y2hlcy5zdGFydFggPSBcInRvdWNobW92ZVwiID09PSBhLnR5cGUgPyBhLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBhLnBhZ2VYLCB2b2lkKHgudG91Y2hlcy5zdGFydFkgPSBcInRvdWNobW92ZVwiID09PSBhLnR5cGUgPyBhLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBhLnBhZ2VZKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMub25seUV4dGVybmFsKSByZXR1cm4geC5hbGxvd0NsaWNrID0gITEsIHZvaWQoYiAmJiAoeC50b3VjaGVzLnN0YXJ0WCA9IHgudG91Y2hlcy5jdXJyZW50WCA9IFwidG91Y2htb3ZlXCIgPT09IGEudHlwZSA/IGEudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGEucGFnZVgsIHgudG91Y2hlcy5zdGFydFkgPSB4LnRvdWNoZXMuY3VycmVudFkgPSBcInRvdWNobW92ZVwiID09PSBhLnR5cGUgPyBhLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBhLnBhZ2VZLCB6ID0gRGF0ZS5ub3coKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChHICYmIHgucGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgIXgucGFyYW1zLmxvb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlzSG9yaXpvbnRhbCgpKSB7IGlmICh4LnRvdWNoZXMuY3VycmVudFggPCB4LnRvdWNoZXMuc3RhcnRYICYmIHgudHJhbnNsYXRlIDw9IHgubWF4VHJhbnNsYXRlKCkgfHwgeC50b3VjaGVzLmN1cnJlbnRYID4geC50b3VjaGVzLnN0YXJ0WCAmJiB4LnRyYW5zbGF0ZSA+PSB4Lm1pblRyYW5zbGF0ZSgpKSByZXR1cm4gfSBlbHNlIGlmICh4LnRvdWNoZXMuY3VycmVudFkgPCB4LnRvdWNoZXMuc3RhcnRZICYmIHgudHJhbnNsYXRlIDw9IHgubWF4VHJhbnNsYXRlKCkgfHwgeC50b3VjaGVzLmN1cnJlbnRZID4geC50b3VjaGVzLnN0YXJ0WSAmJiB4LnRyYW5zbGF0ZSA+PSB4Lm1pblRyYW5zbGF0ZSgpKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEcgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBhLnRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBlKGEudGFyZ2V0KS5pcyhMKSkgcmV0dXJuIEMgPSAhMCwgdm9pZCh4LmFsbG93Q2xpY2sgPSAhMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFMgJiYgeC5lbWl0KFwib25Ub3VjaE1vdmVcIiwgeCwgYSksICEoYS50YXJnZXRUb3VjaGVzICYmIGEudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC50b3VjaGVzLmN1cnJlbnRYID0gXCJ0b3VjaG1vdmVcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogYS5wYWdlWCwgeC50b3VjaGVzLmN1cnJlbnRZID0gXCJ0b3VjaG1vdmVcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogYS5wYWdlWSwgdm9pZCAwID09PSBNKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguaXNIb3Jpem9udGFsKCkgJiYgeC50b3VjaGVzLmN1cnJlbnRZID09PSB4LnRvdWNoZXMuc3RhcnRZIHx8ICF4LmlzSG9yaXpvbnRhbCgpICYmIHgudG91Y2hlcy5jdXJyZW50WCA9PT0geC50b3VjaGVzLnN0YXJ0WCA/IE0gPSAhMSA6ICh0ID0gMTgwICogTWF0aC5hdGFuMihNYXRoLmFicyh4LnRvdWNoZXMuY3VycmVudFkgLSB4LnRvdWNoZXMuc3RhcnRZKSwgTWF0aC5hYnMoeC50b3VjaGVzLmN1cnJlbnRYIC0geC50b3VjaGVzLnN0YXJ0WCkpIC8gTWF0aC5QSSwgTSA9IHguaXNIb3Jpem9udGFsKCkgPyB0ID4geC5wYXJhbXMudG91Y2hBbmdsZSA6IDkwIC0gdCA+IHgucGFyYW1zLnRvdWNoQW5nbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE0gJiYgeC5lbWl0KFwib25Ub3VjaE1vdmVPcHBvc2l0ZVwiLCB4LCBhKSwgdm9pZCAwID09PSBYICYmICh4LnRvdWNoZXMuY3VycmVudFggPT09IHgudG91Y2hlcy5zdGFydFggJiYgeC50b3VjaGVzLmN1cnJlbnRZID09PSB4LnRvdWNoZXMuc3RhcnRZIHx8IChYID0gITApKSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE0pIHJldHVybiB2b2lkKGIgPSAhMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguYWxsb3dDbGljayA9ICExLCB4LmVtaXQoXCJvblNsaWRlck1vdmVcIiwgeCwgYSksIGEucHJldmVudERlZmF1bHQoKSwgeC5wYXJhbXMudG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uICYmICF4LnBhcmFtcy5uZXN0ZWQgJiYgYS5zdG9wUHJvcGFnYXRpb24oKSwgQyB8fCAocy5sb29wICYmIHguZml4TG9vcCgpLCBFID0geC5nZXRXcmFwcGVyVHJhbnNsYXRlKCksIHguc2V0V3JhcHBlclRyYW5zaXRpb24oMCksIHguYW5pbWF0aW5nICYmIHgud3JhcHBlci50cmlnZ2VyKFwid2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kIG9UcmFuc2l0aW9uRW5kIE1TVHJhbnNpdGlvbkVuZCBtc1RyYW5zaXRpb25FbmRcIiksIHgucGFyYW1zLmF1dG9wbGF5ICYmIHguYXV0b3BsYXlpbmcgJiYgKHgucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24gPyB4LnN0b3BBdXRvcGxheSgpIDogeC5wYXVzZUF1dG9wbGF5KCkpLCBEID0gITEsICF4LnBhcmFtcy5ncmFiQ3Vyc29yIHx8IHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgIT09ICEwICYmIHgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgIT09ICEwIHx8IHguc2V0R3JhYkN1cnNvcighMCkpLCBDID0gITA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB4LnRvdWNoZXMuZGlmZiA9IHguaXNIb3Jpem9udGFsKCkgPyB4LnRvdWNoZXMuY3VycmVudFggLSB4LnRvdWNoZXMuc3RhcnRYIDogeC50b3VjaGVzLmN1cnJlbnRZIC0geC50b3VjaGVzLnN0YXJ0WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByICo9IHgucGFyYW1zLnRvdWNoUmF0aW8sIHgucnRsICYmIChyID0gLXIpLCB4LnN3aXBlRGlyZWN0aW9uID0gciA+IDAgPyBcInByZXZcIiA6IFwibmV4dFwiLCBQID0gciArIEU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAhMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+IDAgJiYgUCA+IHgubWluVHJhbnNsYXRlKCkgPyAoaSA9ICExLCB4LnBhcmFtcy5yZXNpc3RhbmNlICYmIChQID0geC5taW5UcmFuc2xhdGUoKSAtIDEgKyBNYXRoLnBvdygteC5taW5UcmFuc2xhdGUoKSArIEUgKyByLCB4LnBhcmFtcy5yZXNpc3RhbmNlUmF0aW8pKSkgOiByIDwgMCAmJiBQIDwgeC5tYXhUcmFuc2xhdGUoKSAmJiAoaSA9ICExLCB4LnBhcmFtcy5yZXNpc3RhbmNlICYmIChQID0geC5tYXhUcmFuc2xhdGUoKSArIDEgLSBNYXRoLnBvdyh4Lm1heFRyYW5zbGF0ZSgpIC0gRSAtIHIsIHgucGFyYW1zLnJlc2lzdGFuY2VSYXRpbykpKSwgaSAmJiAoYS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9ICEwKSwgIXgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgJiYgXCJuZXh0XCIgPT09IHguc3dpcGVEaXJlY3Rpb24gJiYgUCA8IEUgJiYgKFAgPSBFKSwgIXgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgJiYgXCJwcmV2XCIgPT09IHguc3dpcGVEaXJlY3Rpb24gJiYgUCA+IEUgJiYgKFAgPSBFKSwgeC5wYXJhbXMudGhyZXNob2xkID4gMCkgeyBpZiAoIShNYXRoLmFicyhyKSA+IHgucGFyYW1zLnRocmVzaG9sZCB8fCBJKSkgcmV0dXJuIHZvaWQoUCA9IEUpOyBpZiAoIUkpIHJldHVybiBJID0gITAsIHgudG91Y2hlcy5zdGFydFggPSB4LnRvdWNoZXMuY3VycmVudFgsIHgudG91Y2hlcy5zdGFydFkgPSB4LnRvdWNoZXMuY3VycmVudFksIFAgPSBFLCB2b2lkKHgudG91Y2hlcy5kaWZmID0geC5pc0hvcml6b250YWwoKSA/IHgudG91Y2hlcy5jdXJyZW50WCAtIHgudG91Y2hlcy5zdGFydFggOiB4LnRvdWNoZXMuY3VycmVudFkgLSB4LnRvdWNoZXMuc3RhcnRZKSB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5wYXJhbXMuZm9sbG93RmluZ2VyICYmICgoeC5wYXJhbXMuZnJlZU1vZGUgfHwgeC5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykgJiYgeC51cGRhdGVBY3RpdmVJbmRleCgpLCB4LnBhcmFtcy5mcmVlTW9kZSAmJiAoMCA9PT0gSC5sZW5ndGggJiYgSC5wdXNoKHsgcG9zaXRpb246IHgudG91Y2hlc1t4LmlzSG9yaXpvbnRhbCgpID8gXCJzdGFydFhcIiA6IFwic3RhcnRZXCJdLCB0aW1lOiB6IH0pLCBILnB1c2goeyBwb3NpdGlvbjogeC50b3VjaGVzW3guaXNIb3Jpem9udGFsKCkgPyBcImN1cnJlbnRYXCIgOiBcImN1cnJlbnRZXCJdLCB0aW1lOiAobmV3IHdpbmRvdy5EYXRlKS5nZXRUaW1lKCkgfSkpLCB4LnVwZGF0ZVByb2dyZXNzKFApLCB4LnNldFdyYXBwZXJUcmFuc2xhdGUoUCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHgub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhLm9yaWdpbmFsRXZlbnQgJiYgKGEgPSBhLm9yaWdpbmFsRXZlbnQpLCBTICYmIHguZW1pdChcIm9uVG91Y2hFbmRcIiwgeCwgYSksIFMgPSAhMSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyYW1zLmdyYWJDdXJzb3IgJiYgQyAmJiBiICYmICh4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ID09PSAhMCB8fCB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ID09PSAhMCkgJiYgeC5zZXRHcmFiQ3Vyc29yKCExKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0IC0gejtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5hbGxvd0NsaWNrICYmICh4LnVwZGF0ZUNsaWNrZWRTbGlkZShhKSwgeC5lbWl0KFwib25UYXBcIiwgeCwgYSksIHMgPCAzMDAgJiYgdCAtIEIgPiAzMDAgJiYgKGsgJiYgY2xlYXJUaW1lb3V0KGspLCBrID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgeCAmJiAoeC5wYXJhbXMucGFnaW5hdGlvbkhpZGUgJiYgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmxlbmd0aCA+IDAgJiYgIWUoYS50YXJnZXQpLmhhc0NsYXNzKHgucGFyYW1zLmJ1bGxldENsYXNzKSAmJiB4LnBhZ2luYXRpb25Db250YWluZXIudG9nZ2xlQ2xhc3MoeC5wYXJhbXMucGFnaW5hdGlvbkhpZGRlbkNsYXNzKSwgeC5lbWl0KFwib25DbGlja1wiLCB4LCBhKSkgfSwgMzAwKSksIHMgPCAzMDAgJiYgdCAtIEIgPCAzMDAgJiYgKGsgJiYgY2xlYXJUaW1lb3V0KGspLCB4LmVtaXQoXCJvbkRvdWJsZVRhcFwiLCB4LCBhKSkpLCBCID0gRGF0ZS5ub3coKSwgc2V0VGltZW91dChmdW5jdGlvbigpIHsgeCAmJiAoeC5hbGxvd0NsaWNrID0gITApIH0sIDApLCAhYiB8fCAhQyB8fCAheC5zd2lwZURpcmVjdGlvbiB8fCAwID09PSB4LnRvdWNoZXMuZGlmZiB8fCBQID09PSBFKSByZXR1cm4gdm9pZChiID0gQyA9ICExKTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gQyA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyID0geC5wYXJhbXMuZm9sbG93RmluZ2VyID8geC5ydGwgPyB4LnRyYW5zbGF0ZSA6IC14LnRyYW5zbGF0ZSA6IC1QLCB4LnBhcmFtcy5mcmVlTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA8IC14Lm1pblRyYW5zbGF0ZSgpKSByZXR1cm4gdm9pZCB4LnNsaWRlVG8oeC5hY3RpdmVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gLXgubWF4VHJhbnNsYXRlKCkpIHJldHVybiB2b2lkKHguc2xpZGVzLmxlbmd0aCA8IHguc25hcEdyaWQubGVuZ3RoID8geC5zbGlkZVRvKHguc25hcEdyaWQubGVuZ3RoIC0gMSkgOiB4LnNsaWRlVG8oeC5zbGlkZXMubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMuZnJlZU1vZGVNb21lbnR1bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEgubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gSC5wb3AoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IEgucG9wKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBpLnBvc2l0aW9uIC0gbi5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGkudGltZSAtIG4udGltZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnZlbG9jaXR5ID0gbyAvIGwsIHgudmVsb2NpdHkgPSB4LnZlbG9jaXR5IC8gMiwgTWF0aC5hYnMoeC52ZWxvY2l0eSkgPCB4LnBhcmFtcy5mcmVlTW9kZU1pbmltdW1WZWxvY2l0eSAmJiAoeC52ZWxvY2l0eSA9IDApLCAobCA+IDE1MCB8fCAobmV3IHdpbmRvdy5EYXRlKS5nZXRUaW1lKCkgLSBpLnRpbWUgPiAzMDApICYmICh4LnZlbG9jaXR5ID0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB4LnZlbG9jaXR5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgudmVsb2NpdHkgPSB4LnZlbG9jaXR5ICogeC5wYXJhbXMuZnJlZU1vZGVNb21lbnR1bVZlbG9jaXR5UmF0aW8sIEgubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gMWUzICogeC5wYXJhbXMuZnJlZU1vZGVNb21lbnR1bVJhdGlvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB4LnZlbG9jaXR5ICogcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0geC50cmFuc2xhdGUgKyBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5ydGwgJiYgKG0gPSAtbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSwgYyA9ICExLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSAyMCAqIE1hdGguYWJzKHgudmVsb2NpdHkpICogeC5wYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPCB4Lm1heFRyYW5zbGF0ZSgpKSB4LnBhcmFtcy5mcmVlTW9kZU1vbWVudHVtQm91bmNlID8gKG0gKyB4Lm1heFRyYW5zbGF0ZSgpIDwgLWcgJiYgKG0gPSB4Lm1heFRyYW5zbGF0ZSgpIC0gZyksIHUgPSB4Lm1heFRyYW5zbGF0ZSgpLCBjID0gITAsIEQgPSAhMCkgOiBtID0geC5tYXhUcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG0gPiB4Lm1pblRyYW5zbGF0ZSgpKSB4LnBhcmFtcy5mcmVlTW9kZU1vbWVudHVtQm91bmNlID8gKG0gLSB4Lm1pblRyYW5zbGF0ZSgpID4gZyAmJiAobSA9IHgubWluVHJhbnNsYXRlKCkgKyBnKSwgdSA9IHgubWluVHJhbnNsYXRlKCksIGMgPSAhMCwgRCA9ICEwKSA6IG0gPSB4Lm1pblRyYW5zbGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeC5wYXJhbXMuZnJlZU1vZGVTdGlja3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCwgdiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2ID0gMDsgdiA8IHguc25hcEdyaWQubGVuZ3RoOyB2ICs9IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LnNuYXBHcmlkW3ZdID4gLW0pIHsgaCA9IHY7IGJyZWFrIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gTWF0aC5hYnMoeC5zbmFwR3JpZFtoXSAtIG0pIDwgTWF0aC5hYnMoeC5zbmFwR3JpZFtoIC0gMV0gLSBtKSB8fCBcIm5leHRcIiA9PT0geC5zd2lwZURpcmVjdGlvbiA/IHguc25hcEdyaWRbaF0gOiB4LnNuYXBHcmlkW2ggLSAxXSwgeC5ydGwgfHwgKG0gPSAtbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwICE9PSB4LnZlbG9jaXR5KSBwID0geC5ydGwgPyBNYXRoLmFicygoLW0gLSB4LnRyYW5zbGF0ZSkgLyB4LnZlbG9jaXR5KSA6IE1hdGguYWJzKChtIC0geC50cmFuc2xhdGUpIC8geC52ZWxvY2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4LnBhcmFtcy5mcmVlTW9kZVN0aWNreSkgcmV0dXJuIHZvaWQgeC5zbGlkZVJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnBhcmFtcy5mcmVlTW9kZU1vbWVudHVtQm91bmNlICYmIGMgPyAoeC51cGRhdGVQcm9ncmVzcyh1KSwgeC5zZXRXcmFwcGVyVHJhbnNpdGlvbihwKSwgeC5zZXRXcmFwcGVyVHJhbnNsYXRlKG0pLCB4Lm9uVHJhbnNpdGlvblN0YXJ0KCksIHguYW5pbWF0aW5nID0gITAsIHgud3JhcHBlci50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uKCkgeyB4ICYmIEQgJiYgKHguZW1pdChcIm9uTW9tZW50dW1Cb3VuY2VcIiwgeCksIHguc2V0V3JhcHBlclRyYW5zaXRpb24oeC5wYXJhbXMuc3BlZWQpLCB4LnNldFdyYXBwZXJUcmFuc2xhdGUodSksIHgud3JhcHBlci50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uKCkgeyB4ICYmIHgub25UcmFuc2l0aW9uRW5kKCkgfSkpIH0pKSA6IHgudmVsb2NpdHkgPyAoeC51cGRhdGVQcm9ncmVzcyhtKSwgeC5zZXRXcmFwcGVyVHJhbnNpdGlvbihwKSwgeC5zZXRXcmFwcGVyVHJhbnNsYXRlKG0pLCB4Lm9uVHJhbnNpdGlvblN0YXJ0KCksIHguYW5pbWF0aW5nIHx8ICh4LmFuaW1hdGluZyA9ICEwLCB4LndyYXBwZXIudHJhbnNpdGlvbkVuZChmdW5jdGlvbigpIHsgeCAmJiB4Lm9uVHJhbnNpdGlvbkVuZCgpIH0pKSkgOiB4LnVwZGF0ZVByb2dyZXNzKG0pLCB4LnVwZGF0ZUFjdGl2ZUluZGV4KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCgoIXgucGFyYW1zLmZyZWVNb2RlTW9tZW50dW0gfHwgcyA+PSB4LnBhcmFtcy5sb25nU3dpcGVzTXMpICYmICh4LnVwZGF0ZVByb2dyZXNzKCksIHgudXBkYXRlQWN0aXZlSW5kZXgoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmLCB3ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHguc2xpZGVzU2l6ZXNHcmlkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZiA9IDA7IGYgPCB4LnNsaWRlc0dyaWQubGVuZ3RoOyBmICs9IHgucGFyYW1zLnNsaWRlc1Blckdyb3VwKSB2b2lkIDAgIT09IHguc2xpZGVzR3JpZFtmICsgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXBdID8gciA+PSB4LnNsaWRlc0dyaWRbZl0gJiYgciA8IHguc2xpZGVzR3JpZFtmICsgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXBdICYmICh3ID0gZiwgeSA9IHguc2xpZGVzR3JpZFtmICsgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXBdIC0geC5zbGlkZXNHcmlkW2ZdKSA6IHIgPj0geC5zbGlkZXNHcmlkW2ZdICYmICh3ID0gZiwgeSA9IHguc2xpZGVzR3JpZFt4LnNsaWRlc0dyaWQubGVuZ3RoIC0gMV0gLSB4LnNsaWRlc0dyaWRbeC5zbGlkZXNHcmlkLmxlbmd0aCAtIDJdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgVCA9IChyIC0geC5zbGlkZXNHcmlkW3ddKSAvIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPiB4LnBhcmFtcy5sb25nU3dpcGVzTXMpIHsgaWYgKCF4LnBhcmFtcy5sb25nU3dpcGVzKSByZXR1cm4gdm9pZCB4LnNsaWRlVG8oeC5hY3RpdmVJbmRleCk7IFwibmV4dFwiID09PSB4LnN3aXBlRGlyZWN0aW9uICYmIChUID49IHgucGFyYW1zLmxvbmdTd2lwZXNSYXRpbyA/IHguc2xpZGVUbyh3ICsgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogeC5zbGlkZVRvKHcpKSwgXCJwcmV2XCIgPT09IHguc3dpcGVEaXJlY3Rpb24gJiYgKFQgPiAxIC0geC5wYXJhbXMubG9uZ1N3aXBlc1JhdGlvID8geC5zbGlkZVRvKHcgKyB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiB4LnNsaWRlVG8odykpIH0gZWxzZSB7IGlmICgheC5wYXJhbXMuc2hvcnRTd2lwZXMpIHJldHVybiB2b2lkIHguc2xpZGVUbyh4LmFjdGl2ZUluZGV4KTsgXCJuZXh0XCIgPT09IHguc3dpcGVEaXJlY3Rpb24gJiYgeC5zbGlkZVRvKHcgKyB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCksIFwicHJldlwiID09PSB4LnN3aXBlRGlyZWN0aW9uICYmIHguc2xpZGVUbyh3KSB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHguX3NsaWRlVG8gPSBmdW5jdGlvbihlLCBhKSB7IHJldHVybiB4LnNsaWRlVG8oZSwgYSwgITAsICEwKSB9LCB4LnNsaWRlVG8gPSBmdW5jdGlvbihlLCBhLCB0LCBzKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCksIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLCBlIDwgMCAmJiAoZSA9IDApLCB4LnNuYXBJbmRleCA9IE1hdGguZmxvb3IoZSAvIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwKSwgeC5zbmFwSW5kZXggPj0geC5zbmFwR3JpZC5sZW5ndGggJiYgKHguc25hcEluZGV4ID0geC5zbmFwR3JpZC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIHZhciByID0gLXguc25hcEdyaWRbeC5zbmFwSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmF1dG9wbGF5ICYmIHguYXV0b3BsYXlpbmcgJiYgKHMgfHwgIXgucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24gPyB4LnBhdXNlQXV0b3BsYXkoYSkgOiB4LnN0b3BBdXRvcGxheSgpKSwgeC51cGRhdGVQcm9ncmVzcyhyKSwgeC5wYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleClcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHguc2xpZGVzR3JpZC5sZW5ndGg7IGkrKykgLSBNYXRoLmZsb29yKDEwMCAqIHIpID49IE1hdGguZmxvb3IoMTAwICogeC5zbGlkZXNHcmlkW2ldKSAmJiAoZSA9IGkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoIXgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgJiYgciA8IHgudHJhbnNsYXRlICYmIHIgPCB4Lm1pblRyYW5zbGF0ZSgpKSAmJiAoISgheC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiAmJiByID4geC50cmFuc2xhdGUgJiYgciA+IHgubWF4VHJhbnNsYXRlKCkgJiYgKHguYWN0aXZlSW5kZXggfHwgMCkgIT09IGUpICYmICh2b2lkIDAgPT09IGEgJiYgKGEgPSB4LnBhcmFtcy5zcGVlZCksIHgucHJldmlvdXNJbmRleCA9IHguYWN0aXZlSW5kZXggfHwgMCwgeC5hY3RpdmVJbmRleCA9IGUsIHgudXBkYXRlUmVhbEluZGV4KCksIHgucnRsICYmIC1yID09PSB4LnRyYW5zbGF0ZSB8fCAheC5ydGwgJiYgciA9PT0geC50cmFuc2xhdGUgPyAoeC5wYXJhbXMuYXV0b0hlaWdodCAmJiB4LnVwZGF0ZUF1dG9IZWlnaHQoKSwgeC51cGRhdGVDbGFzc2VzKCksIFwic2xpZGVcIiAhPT0geC5wYXJhbXMuZWZmZWN0ICYmIHguc2V0V3JhcHBlclRyYW5zbGF0ZShyKSwgITEpIDogKHgudXBkYXRlQ2xhc3NlcygpLCB4Lm9uVHJhbnNpdGlvblN0YXJ0KHQpLCAwID09PSBhIHx8IHguYnJvd3Nlci5sdGVJRTkgPyAoeC5zZXRXcmFwcGVyVHJhbnNsYXRlKHIpLCB4LnNldFdyYXBwZXJUcmFuc2l0aW9uKDApLCB4Lm9uVHJhbnNpdGlvbkVuZCh0KSkgOiAoeC5zZXRXcmFwcGVyVHJhbnNsYXRlKHIpLCB4LnNldFdyYXBwZXJUcmFuc2l0aW9uKGEpLCB4LmFuaW1hdGluZyB8fCAoeC5hbmltYXRpbmcgPSAhMCwgeC53cmFwcGVyLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24oKSB7IHggJiYgeC5vblRyYW5zaXRpb25FbmQodCkgfSkpKSwgITApKSlcclxuICAgICAgICAgICAgfSwgeC5vblRyYW5zaXRpb25TdGFydCA9IGZ1bmN0aW9uKGUpIHsgdm9pZCAwID09PSBlICYmIChlID0gITApLCB4LnBhcmFtcy5hdXRvSGVpZ2h0ICYmIHgudXBkYXRlQXV0b0hlaWdodCgpLCB4LmxhenkgJiYgeC5sYXp5Lm9uVHJhbnNpdGlvblN0YXJ0KCksIGUgJiYgKHguZW1pdChcIm9uVHJhbnNpdGlvblN0YXJ0XCIsIHgpLCB4LmFjdGl2ZUluZGV4ICE9PSB4LnByZXZpb3VzSW5kZXggJiYgKHguZW1pdChcIm9uU2xpZGVDaGFuZ2VTdGFydFwiLCB4KSwgeC5hY3RpdmVJbmRleCA+IHgucHJldmlvdXNJbmRleCA/IHguZW1pdChcIm9uU2xpZGVOZXh0U3RhcnRcIiwgeCkgOiB4LmVtaXQoXCJvblNsaWRlUHJldlN0YXJ0XCIsIHgpKSkgfSwgeC5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihlKSB7IHguYW5pbWF0aW5nID0gITEsIHguc2V0V3JhcHBlclRyYW5zaXRpb24oMCksIHZvaWQgMCA9PT0gZSAmJiAoZSA9ICEwKSwgeC5sYXp5ICYmIHgubGF6eS5vblRyYW5zaXRpb25FbmQoKSwgZSAmJiAoeC5lbWl0KFwib25UcmFuc2l0aW9uRW5kXCIsIHgpLCB4LmFjdGl2ZUluZGV4ICE9PSB4LnByZXZpb3VzSW5kZXggJiYgKHguZW1pdChcIm9uU2xpZGVDaGFuZ2VFbmRcIiwgeCksIHguYWN0aXZlSW5kZXggPiB4LnByZXZpb3VzSW5kZXggPyB4LmVtaXQoXCJvblNsaWRlTmV4dEVuZFwiLCB4KSA6IHguZW1pdChcIm9uU2xpZGVQcmV2RW5kXCIsIHgpKSksIHgucGFyYW1zLmhpc3RvcnkgJiYgeC5oaXN0b3J5ICYmIHguaGlzdG9yeS5zZXRIaXN0b3J5KHgucGFyYW1zLmhpc3RvcnksIHguYWN0aXZlSW5kZXgpLCB4LnBhcmFtcy5oYXNobmF2ICYmIHguaGFzaG5hdiAmJiB4Lmhhc2huYXYuc2V0SGFzaCgpIH0sIHguc2xpZGVOZXh0ID0gZnVuY3Rpb24oZSwgYSwgdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5hbmltYXRpbmcpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgICAgICB4LmZpeExvb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB4LmNvbnRhaW5lclswXS5jbGllbnRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnNsaWRlVG8oeC5hY3RpdmVJbmRleCArIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwLCBhLCBlLCB0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHguc2xpZGVUbyh4LmFjdGl2ZUluZGV4ICsgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXAsIGEsIGUsIHQpXHJcbiAgICAgICAgICAgIH0sIHguX3NsaWRlTmV4dCA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHguc2xpZGVOZXh0KCEwLCBlLCAhMCkgfSwgeC5zbGlkZVByZXYgPSBmdW5jdGlvbihlLCBhLCB0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMubG9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4LmFuaW1hdGluZykgcmV0dXJuICExO1xyXG4gICAgICAgICAgICAgICAgICAgIHguZml4TG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHguY29udGFpbmVyWzBdLmNsaWVudExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHguc2xpZGVUbyh4LmFjdGl2ZUluZGV4IC0gMSwgYSwgZSwgdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnNsaWRlVG8oeC5hY3RpdmVJbmRleCAtIDEsIGEsIGUsIHQpXHJcbiAgICAgICAgICAgIH0sIHguX3NsaWRlUHJldiA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHguc2xpZGVQcmV2KCEwLCBlLCAhMCkgfSwgeC5zbGlkZVJlc2V0ID0gZnVuY3Rpb24oZSwgYSwgdCkgeyByZXR1cm4geC5zbGlkZVRvKHguYWN0aXZlSW5kZXgsIGEsIGUpIH0sIHguZGlzYWJsZVRvdWNoQ29udHJvbCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4geC5wYXJhbXMub25seUV4dGVybmFsID0gITAsICEwIH0sIHguZW5hYmxlVG91Y2hDb250cm9sID0gZnVuY3Rpb24oKSB7IHJldHVybiB4LnBhcmFtcy5vbmx5RXh0ZXJuYWwgPSAhMSwgITAgfSwgeC5zZXRXcmFwcGVyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGUsIGEpIHsgeC53cmFwcGVyLnRyYW5zaXRpb24oZSksIFwic2xpZGVcIiAhPT0geC5wYXJhbXMuZWZmZWN0ICYmIHguZWZmZWN0c1t4LnBhcmFtcy5lZmZlY3RdICYmIHguZWZmZWN0c1t4LnBhcmFtcy5lZmZlY3RdLnNldFRyYW5zaXRpb24oZSksIHgucGFyYW1zLnBhcmFsbGF4ICYmIHgucGFyYWxsYXggJiYgeC5wYXJhbGxheC5zZXRUcmFuc2l0aW9uKGUpLCB4LnBhcmFtcy5zY3JvbGxiYXIgJiYgeC5zY3JvbGxiYXIgJiYgeC5zY3JvbGxiYXIuc2V0VHJhbnNpdGlvbihlKSwgeC5wYXJhbXMuY29udHJvbCAmJiB4LmNvbnRyb2xsZXIgJiYgeC5jb250cm9sbGVyLnNldFRyYW5zaXRpb24oZSwgYSksIHguZW1pdChcIm9uU2V0VHJhbnNpdGlvblwiLCB4LCBlKSB9LCB4LnNldFdyYXBwZXJUcmFuc2xhdGUgPSBmdW5jdGlvbihlLCBhLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICB4LmlzSG9yaXpvbnRhbCgpID8gcyA9IHgucnRsID8gLWUgOiBlIDogaSA9IGUsIHgucGFyYW1zLnJvdW5kTGVuZ3RocyAmJiAocyA9IHIocyksIGkgPSByKGkpKSwgeC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSB8fCAoeC5zdXBwb3J0LnRyYW5zZm9ybXMzZCA/IHgud3JhcHBlci50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIHMgKyBcInB4LCBcIiArIGkgKyBcInB4LCAwcHgpXCIpIDogeC53cmFwcGVyLnRyYW5zZm9ybShcInRyYW5zbGF0ZShcIiArIHMgKyBcInB4LCBcIiArIGkgKyBcInB4KVwiKSksIHgudHJhbnNsYXRlID0geC5pc0hvcml6b250YWwoKSA/IHMgOiBpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG4sIG8gPSB4Lm1heFRyYW5zbGF0ZSgpIC0geC5taW5UcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgICAgIG4gPSAwID09PSBvID8gMCA6IChlIC0geC5taW5UcmFuc2xhdGUoKSkgLyBvLCBuICE9PSB4LnByb2dyZXNzICYmIHgudXBkYXRlUHJvZ3Jlc3MoZSksIGEgJiYgeC51cGRhdGVBY3RpdmVJbmRleCgpLCBcInNsaWRlXCIgIT09IHgucGFyYW1zLmVmZmVjdCAmJiB4LmVmZmVjdHNbeC5wYXJhbXMuZWZmZWN0XSAmJiB4LmVmZmVjdHNbeC5wYXJhbXMuZWZmZWN0XS5zZXRUcmFuc2xhdGUoeC50cmFuc2xhdGUpLCB4LnBhcmFtcy5wYXJhbGxheCAmJiB4LnBhcmFsbGF4ICYmIHgucGFyYWxsYXguc2V0VHJhbnNsYXRlKHgudHJhbnNsYXRlKSwgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSh4LnRyYW5zbGF0ZSksIHgucGFyYW1zLmNvbnRyb2wgJiYgeC5jb250cm9sbGVyICYmIHguY29udHJvbGxlci5zZXRUcmFuc2xhdGUoeC50cmFuc2xhdGUsIHQpLCB4LmVtaXQoXCJvblNldFRyYW5zbGF0ZVwiLCB4LCB4LnRyYW5zbGF0ZSlcclxuICAgICAgICAgICAgfSwgeC5nZXRUcmFuc2xhdGUgPSBmdW5jdGlvbihlLCBhKSB7IHZhciB0LCBzLCByLCBpOyByZXR1cm4gdm9pZCAwID09PSBhICYmIChhID0gXCJ4XCIpLCB4LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlID8geC5ydGwgPyAteC50cmFuc2xhdGUgOiB4LnRyYW5zbGF0ZSA6IChyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSwgbnVsbCksIHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggPyAocyA9IHIudHJhbnNmb3JtIHx8IHIud2Via2l0VHJhbnNmb3JtLCBzLnNwbGl0KFwiLFwiKS5sZW5ndGggPiA2ICYmIChzID0gcy5zcGxpdChcIiwgXCIpLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSB9KS5qb2luKFwiLCBcIikpLCBpID0gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoXCJub25lXCIgPT09IHMgPyBcIlwiIDogcykpIDogKGkgPSByLk1velRyYW5zZm9ybSB8fCByLk9UcmFuc2Zvcm0gfHwgci5Nc1RyYW5zZm9ybSB8fCByLm1zVHJhbnNmb3JtIHx8IHIudHJhbnNmb3JtIHx8IHIuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKS5yZXBsYWNlKFwidHJhbnNsYXRlKFwiLCBcIm1hdHJpeCgxLCAwLCAwLCAxLFwiKSwgdCA9IGkudG9TdHJpbmcoKS5zcGxpdChcIixcIikpLCBcInhcIiA9PT0gYSAmJiAocyA9IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggPyBpLm00MSA6IDE2ID09PSB0Lmxlbmd0aCA/IHBhcnNlRmxvYXQodFsxMl0pIDogcGFyc2VGbG9hdCh0WzRdKSksIFwieVwiID09PSBhICYmIChzID0gd2luZG93LldlYktpdENTU01hdHJpeCA/IGkubTQyIDogMTYgPT09IHQubGVuZ3RoID8gcGFyc2VGbG9hdCh0WzEzXSkgOiBwYXJzZUZsb2F0KHRbNV0pKSwgeC5ydGwgJiYgcyAmJiAocyA9IC1zKSwgcyB8fCAwKSB9LCB4LmdldFdyYXBwZXJUcmFuc2xhdGUgPSBmdW5jdGlvbihlKSB7IHJldHVybiB2b2lkIDAgPT09IGUgJiYgKGUgPSB4LmlzSG9yaXpvbnRhbCgpID8gXCJ4XCIgOiBcInlcIiksIHguZ2V0VHJhbnNsYXRlKHgud3JhcHBlclswXSwgZSkgfSwgeC5vYnNlcnZlcnMgPSBbXSwgeC5pbml0T2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMub2JzZXJ2ZVBhcmVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IHguY29udGFpbmVyLnBhcmVudHMoKSwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSBvKGVbYV0pO1xyXG4gICAgICAgICAgICAgICAgbyh4LmNvbnRhaW5lclswXSwgeyBjaGlsZExpc3Q6ICExIH0pLCBvKHgud3JhcHBlclswXSwgeyBhdHRyaWJ1dGVzOiAhMSB9KVxyXG4gICAgICAgICAgICB9LCB4LmRpc2Nvbm5lY3RPYnNlcnZlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgeC5vYnNlcnZlcnMubGVuZ3RoOyBlKyspIHgub2JzZXJ2ZXJzW2VdLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIHgub2JzZXJ2ZXJzID0gW11cclxuICAgICAgICAgICAgfSwgeC5jcmVhdGVMb29wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBcImF1dG9cIiAhPT0geC5wYXJhbXMuc2xpZGVzUGVyVmlldyB8fCB4LnBhcmFtcy5sb29wZWRTbGlkZXMgfHwgKHgucGFyYW1zLmxvb3BlZFNsaWRlcyA9IGEubGVuZ3RoKSwgeC5sb29wZWRTbGlkZXMgPSBwYXJzZUludCh4LnBhcmFtcy5sb29wZWRTbGlkZXMgfHwgeC5wYXJhbXMuc2xpZGVzUGVyVmlldywgMTApLCB4Lmxvb3BlZFNsaWRlcyA9IHgubG9vcGVkU2xpZGVzICsgeC5wYXJhbXMubG9vcEFkZGl0aW9uYWxTbGlkZXMsIHgubG9vcGVkU2xpZGVzID4gYS5sZW5ndGggJiYgKHgubG9vcGVkU2xpZGVzID0gYS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQsIHMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICByID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGEuZWFjaChmdW5jdGlvbih0LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA8IHgubG9vcGVkU2xpZGVzICYmIHIucHVzaChpKSwgdCA8IGEubGVuZ3RoICYmIHQgPj0gYS5sZW5ndGggLSB4Lmxvb3BlZFNsaWRlcyAmJiBzLnB1c2goaSksIG4uYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIsIHQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSksIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeC53cmFwcGVyLmFwcGVuZChlKHJbdF0uY2xvbmVOb2RlKCEwKSkuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh0ID0gcy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkgeC53cmFwcGVyLnByZXBlbmQoZShzW3RdLmNsb25lTm9kZSghMCkpLmFkZENsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKVxyXG4gICAgICAgICAgICB9LCB4LmRlc3Ryb3lMb29wID0gZnVuY3Rpb24oKSB7IHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlQ2xhc3MgKyBcIi5cIiArIHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpLnJlbW92ZSgpLCB4LnNsaWRlcy5yZW1vdmVBdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgfSwgeC5yZUxvb3AgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHguYWN0aXZlSW5kZXggLSB4Lmxvb3BlZFNsaWRlcztcclxuICAgICAgICAgICAgICAgIHguZGVzdHJveUxvb3AoKSwgeC5jcmVhdGVMb29wKCksIHgudXBkYXRlU2xpZGVzU2l6ZSgpLCBlICYmIHguc2xpZGVUbyhhICsgeC5sb29wZWRTbGlkZXMsIDAsICExKVxyXG4gICAgICAgICAgICB9LCB4LmZpeExvb3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgeC5hY3RpdmVJbmRleCA8IHgubG9vcGVkU2xpZGVzID8gKGUgPSB4LnNsaWRlcy5sZW5ndGggLSAzICogeC5sb29wZWRTbGlkZXMgKyB4LmFjdGl2ZUluZGV4LCBlICs9IHgubG9vcGVkU2xpZGVzLCB4LnNsaWRlVG8oZSwgMCwgITEsICEwKSkgOiAoXCJhdXRvXCIgPT09IHgucGFyYW1zLnNsaWRlc1BlclZpZXcgJiYgeC5hY3RpdmVJbmRleCA+PSAyICogeC5sb29wZWRTbGlkZXMgfHwgeC5hY3RpdmVJbmRleCA+IHguc2xpZGVzLmxlbmd0aCAtIDIgKiB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3KSAmJiAoZSA9IC14LnNsaWRlcy5sZW5ndGggKyB4LmFjdGl2ZUluZGV4ICsgeC5sb29wZWRTbGlkZXMsIGUgKz0geC5sb29wZWRTbGlkZXMsIHguc2xpZGVUbyhlLCAwLCAhMSwgITApKVxyXG4gICAgICAgICAgICB9LCB4LmFwcGVuZFNsaWRlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmxvb3AgJiYgeC5kZXN0cm95TG9vcCgpLCBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIGUubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKykgZVthXSAmJiB4LndyYXBwZXIuYXBwZW5kKGVbYV0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB4LndyYXBwZXIuYXBwZW5kKGUpO1xyXG4gICAgICAgICAgICAgICAgeC5wYXJhbXMubG9vcCAmJiB4LmNyZWF0ZUxvb3AoKSwgeC5wYXJhbXMub2JzZXJ2ZXIgJiYgeC5zdXBwb3J0Lm9ic2VydmVyIHx8IHgudXBkYXRlKCEwKVxyXG4gICAgICAgICAgICB9LCB4LnByZXBlbmRTbGlkZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgJiYgeC5kZXN0cm95TG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB4LmFjdGl2ZUluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCsrKSBlW3RdICYmIHgud3JhcHBlci5wcmVwZW5kKGVbdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSB4LmFjdGl2ZUluZGV4ICsgZS5sZW5ndGhcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB4LndyYXBwZXIucHJlcGVuZChlKTtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgJiYgeC5jcmVhdGVMb29wKCksIHgucGFyYW1zLm9ic2VydmVyICYmIHguc3VwcG9ydC5vYnNlcnZlciB8fCB4LnVwZGF0ZSghMCksIHguc2xpZGVUbyhhLCAwLCAhMSlcclxuICAgICAgICAgICAgfSwgeC5yZW1vdmVTbGlkZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgJiYgKHguZGVzdHJveUxvb3AoKSwgeC5zbGlkZXMgPSB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgdCA9IHguYWN0aXZlSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgZS5sZW5ndGg7IHMrKykgYSA9IGVbc10sIHguc2xpZGVzW2FdICYmIHguc2xpZGVzLmVxKGEpLnJlbW92ZSgpLCBhIDwgdCAmJiB0LS07XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IE1hdGgubWF4KHQsIDApXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgYSA9IGUsIHguc2xpZGVzW2FdICYmIHguc2xpZGVzLmVxKGEpLnJlbW92ZSgpLCBhIDwgdCAmJiB0LS0sIHQgPSBNYXRoLm1heCh0LCAwKTtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgJiYgeC5jcmVhdGVMb29wKCksIHgucGFyYW1zLm9ic2VydmVyICYmIHguc3VwcG9ydC5vYnNlcnZlciB8fCB4LnVwZGF0ZSghMCksIHgucGFyYW1zLmxvb3AgPyB4LnNsaWRlVG8odCArIHgubG9vcGVkU2xpZGVzLCAwLCAhMSkgOiB4LnNsaWRlVG8odCwgMCwgITEpXHJcbiAgICAgICAgICAgIH0sIHgucmVtb3ZlQWxsU2xpZGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gW10sIGEgPSAwOyBhIDwgeC5zbGlkZXMubGVuZ3RoOyBhKyspIGUucHVzaChhKTtcclxuICAgICAgICAgICAgICAgIHgucmVtb3ZlU2xpZGUoZSlcclxuICAgICAgICAgICAgfSwgeC5lZmZlY3RzID0ge1xyXG4gICAgICAgICAgICAgICAgZmFkZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgeC5zbGlkZXMubGVuZ3RoOyBlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0geC5zbGlkZXMuZXEoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGFbMF0uc3dpcGVyU2xpZGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IC10O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSB8fCAocyAtPSB4LnRyYW5zbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmlzSG9yaXpvbnRhbCgpIHx8IChyID0gcywgcyA9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB4LnBhcmFtcy5mYWRlLmNyb3NzRmFkZSA/IE1hdGgubWF4KDEgLSBNYXRoLmFicyhhWzBdLnByb2dyZXNzKSwgMCkgOiAxICsgTWF0aC5taW4oTWF0aC5tYXgoYVswXS5wcm9ncmVzcywgLTEpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY3NzKHsgb3BhY2l0eTogaSB9KS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIHMgKyBcInB4LCBcIiArIHIgKyBcInB4LCAwcHgpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguc2xpZGVzLnRyYW5zaXRpb24oZSksIHgucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgJiYgMCAhPT0gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguc2xpZGVzLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24oKSB7IGlmICghYSAmJiB4KSB7IGEgPSAhMCwgeC5hbmltYXRpbmcgPSAhMTsgZm9yICh2YXIgZSA9IFtcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uZW5kXCIsIFwib1RyYW5zaXRpb25FbmRcIiwgXCJNU1RyYW5zaXRpb25FbmRcIiwgXCJtc1RyYW5zaXRpb25FbmRcIl0sIHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykgeC53cmFwcGVyLnRyaWdnZXIoZVt0XSkgfSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZsaXA6IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHguc2xpZGVzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguc2xpZGVzLmVxKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0WzBdLnByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5wYXJhbXMuZmxpcC5saW1pdFJvdGF0aW9uICYmIChzID0gTWF0aC5tYXgoTWF0aC5taW4odFswXS5wcm9ncmVzcywgMSksIC0xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRbMF0uc3dpcGVyU2xpZGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IC0xODAgKiBzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSAtcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlzSG9yaXpvbnRhbCgpID8geC5ydGwgJiYgKG4gPSAtbikgOiAocCA9IGwsIGwgPSAwLCBvID0gLW4sIG4gPSAwKSwgdFswXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChzKSkgKyB4LnNsaWRlcy5sZW5ndGgsIHgucGFyYW1zLmZsaXAuc2xpZGVTaGFkb3dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB4LmlzSG9yaXpvbnRhbCgpID8gdC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKSA6IHQuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHguaXNIb3Jpem9udGFsKCkgPyB0LmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodFwiKSA6IHQuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID09PSBkLmxlbmd0aCAmJiAoZCA9IGUoJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScgKyAoeC5pc0hvcml6b250YWwoKSA/IFwibGVmdFwiIDogXCJ0b3BcIikgKyAnXCI+PC9kaXY+JyksIHQuYXBwZW5kKGQpKSwgMCA9PT0gbS5sZW5ndGggJiYgKG0gPSBlKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nICsgKHguaXNIb3Jpem9udGFsKCkgPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiKSArICdcIj48L2Rpdj4nKSwgdC5hcHBlbmQobSkpLCBkLmxlbmd0aCAmJiAoZFswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgoLXMsIDApKSwgbS5sZW5ndGggJiYgKG1bMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KHMsIDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIGwgKyBcInB4LCBcIiArIHAgKyBcInB4LCAwcHgpIHJvdGF0ZVgoXCIgKyBvICsgXCJkZWcpIHJvdGF0ZVkoXCIgKyBuICsgXCJkZWcpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguc2xpZGVzLnRyYW5zaXRpb24oYSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGEpLCB4LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIDAgIT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnNsaWRlcy5lcSh4LmFjdGl2ZUluZGV4KS50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uKCkgeyBpZiAoIXQgJiYgeCAmJiBlKHRoaXMpLmhhc0NsYXNzKHgucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpKSB7IHQgPSAhMCwgeC5hbmltYXRpbmcgPSAhMTsgZm9yICh2YXIgYSA9IFtcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uZW5kXCIsIFwib1RyYW5zaXRpb25FbmRcIiwgXCJNU1RyYW5zaXRpb25FbmRcIiwgXCJtc1RyYW5zaXRpb25FbmRcIl0sIHMgPSAwOyBzIDwgYS5sZW5ndGg7IHMrKykgeC53cmFwcGVyLnRyaWdnZXIoYVtzXSkgfSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGN1YmU6IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgucGFyYW1zLmN1YmUuc2hhZG93ICYmICh4LmlzSG9yaXpvbnRhbCgpID8gKGEgPSB4LndyYXBwZXIuZmluZChcIi5zd2lwZXItY3ViZS1zaGFkb3dcIiksIDAgPT09IGEubGVuZ3RoICYmIChhID0gZSgnPGRpdiBjbGFzcz1cInN3aXBlci1jdWJlLXNoYWRvd1wiPjwvZGl2PicpLCB4LndyYXBwZXIuYXBwZW5kKGEpKSwgYS5jc3MoeyBoZWlnaHQ6IHgud2lkdGggKyBcInB4XCIgfSkpIDogKGEgPSB4LmNvbnRhaW5lci5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKSwgMCA9PT0gYS5sZW5ndGggJiYgKGEgPSBlKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+JyksIHguY29udGFpbmVyLmFwcGVuZChhKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB4LnNsaWRlcy5sZW5ndGg7IHMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB4LnNsaWRlcy5lcShzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gOTAgKiBzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBNYXRoLmZsb29yKGkgLyAzNjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5ydGwgJiYgKGkgPSAtaSwgbiA9IE1hdGguZmxvb3IoLWkgLyAzNjApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gTWF0aC5tYXgoTWF0aC5taW4oclswXS5wcm9ncmVzcywgMSksIC0xKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgJSA0ID09IDAgPyAobCA9IDQgKiAtbiAqIHguc2l6ZSwgZCA9IDApIDogKHMgLSAxKSAlIDQgPT0gMCA/IChsID0gMCwgZCA9IDQgKiAtbiAqIHguc2l6ZSkgOiAocyAtIDIpICUgNCA9PSAwID8gKGwgPSB4LnNpemUgKyA0ICogbiAqIHguc2l6ZSwgZCA9IHguc2l6ZSkgOiAocyAtIDMpICUgNCA9PSAwICYmIChsID0gLXguc2l6ZSwgZCA9IDMgKiB4LnNpemUgKyA0ICogeC5zaXplICogbiksIHgucnRsICYmIChsID0gLWwpLCB4LmlzSG9yaXpvbnRhbCgpIHx8IChwID0gbCwgbCA9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBcInJvdGF0ZVgoXCIgKyAoeC5pc0hvcml6b250YWwoKSA/IDAgOiAtaSkgKyBcImRlZykgcm90YXRlWShcIiArICh4LmlzSG9yaXpvbnRhbCgpID8gaSA6IDApICsgXCJkZWcpIHRyYW5zbGF0ZTNkKFwiICsgbCArIFwicHgsIFwiICsgcCArIFwicHgsIFwiICsgZCArIFwicHgpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobyA8PSAxICYmIG8gPiAtMSAmJiAodCA9IDkwICogcyArIDkwICogbywgeC5ydGwgJiYgKHQgPSA5MCAqIC1zIC0gOTAgKiBvKSksIHIudHJhbnNmb3JtKG0pLCB4LnBhcmFtcy5jdWJlLnNsaWRlU2hhZG93cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0geC5pc0hvcml6b250YWwoKSA/IHIuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikgOiByLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB4LmlzSG9yaXpvbnRhbCgpID8gci5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIikgOiByLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gdS5sZW5ndGggJiYgKHUgPSBlKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nICsgKHguaXNIb3Jpem9udGFsKCkgPyBcImxlZnRcIiA6IFwidG9wXCIpICsgJ1wiPjwvZGl2PicpLCByLmFwcGVuZCh1KSksIDAgPT09IGMubGVuZ3RoICYmIChjID0gZSgnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJyArICh4LmlzSG9yaXpvbnRhbCgpID8gXCJyaWdodFwiIDogXCJib3R0b21cIikgKyAnXCI+PC9kaXY+JyksIHIuYXBwZW5kKGMpKSwgdS5sZW5ndGggJiYgKHVbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KC1vLCAwKSksIGMubGVuZ3RoICYmIChjWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heChvLCAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC53cmFwcGVyLmNzcyh7IFwiLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luXCI6IFwiNTAlIDUwJSAtXCIgKyB4LnNpemUgLyAyICsgXCJweFwiLCBcIi1tb3otdHJhbnNmb3JtLW9yaWdpblwiOiBcIjUwJSA1MCUgLVwiICsgeC5zaXplIC8gMiArIFwicHhcIiwgXCItbXMtdHJhbnNmb3JtLW9yaWdpblwiOiBcIjUwJSA1MCUgLVwiICsgeC5zaXplIC8gMiArIFwicHhcIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IFwiNTAlIDUwJSAtXCIgKyB4LnNpemUgLyAyICsgXCJweFwiIH0pLCB4LnBhcmFtcy5jdWJlLnNoYWRvdylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmlzSG9yaXpvbnRhbCgpKSBhLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDBweCwgXCIgKyAoeC53aWR0aCAvIDIgKyB4LnBhcmFtcy5jdWJlLnNoYWRvd09mZnNldCkgKyBcInB4LCBcIiArIC14LndpZHRoIC8gMiArIFwicHgpIHJvdGF0ZVgoOTBkZWcpIHJvdGF0ZVooMGRlZykgc2NhbGUoXCIgKyB4LnBhcmFtcy5jdWJlLnNoYWRvd1NjYWxlICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBNYXRoLmFicyh0KSAtIDkwICogTWF0aC5mbG9vcihNYXRoLmFicyh0KSAvIDkwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IDEuNSAtIChNYXRoLnNpbigyICogZyAqIE1hdGguUEkgLyAzNjApIC8gMiArIE1hdGguY29zKDIgKiBnICogTWF0aC5QSSAvIDM2MCkgLyAyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHgucGFyYW1zLmN1YmUuc2hhZG93U2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSB4LnBhcmFtcy5jdWJlLnNoYWRvd1NjYWxlIC8gaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHgucGFyYW1zLmN1YmUuc2hhZG93T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEudHJhbnNmb3JtKFwic2NhbGUzZChcIiArIHYgKyBcIiwgMSwgXCIgKyBmICsgXCIpIHRyYW5zbGF0ZTNkKDBweCwgXCIgKyAoeC5oZWlnaHQgLyAyICsgdykgKyBcInB4LCBcIiArIC14LmhlaWdodCAvIDIgLyBmICsgXCJweCkgcm90YXRlWCgtOTBkZWcpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0geC5pc1NhZmFyaSB8fCB4LmlzVWlXZWJWaWV3ID8gLXguc2l6ZSAvIDIgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LndyYXBwZXIudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMHB4LDAsXCIgKyB5ICsgXCJweCkgcm90YXRlWChcIiArICh4LmlzSG9yaXpvbnRhbCgpID8gMCA6IHQpICsgXCJkZWcpIHJvdGF0ZVkoXCIgKyAoeC5pc0hvcml6b250YWwoKSA/IC10IDogMCkgKyBcImRlZylcIilcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKGUpIHsgeC5zbGlkZXMudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpLnRyYW5zaXRpb24oZSksIHgucGFyYW1zLmN1YmUuc2hhZG93ICYmICF4LmlzSG9yaXpvbnRhbCgpICYmIHguY29udGFpbmVyLmZpbmQoXCIuc3dpcGVyLWN1YmUtc2hhZG93XCIpLnRyYW5zaXRpb24oZSkgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvdmVyZmxvdzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSB4LnRyYW5zbGF0ZSwgdCA9IHguaXNIb3Jpem9udGFsKCkgPyAtYSArIHgud2lkdGggLyAyIDogLWEgKyB4LmhlaWdodCAvIDIsIHMgPSB4LmlzSG9yaXpvbnRhbCgpID8geC5wYXJhbXMuY292ZXJmbG93LnJvdGF0ZSA6IC14LnBhcmFtcy5jb3ZlcmZsb3cucm90YXRlLCByID0geC5wYXJhbXMuY292ZXJmbG93LmRlcHRoLCBpID0gMCwgbiA9IHguc2xpZGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB4LnNsaWRlcy5lcShpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0geC5zbGlkZXNTaXplc0dyaWRbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG9bMF0uc3dpcGVyU2xpZGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9ICh0IC0gcCAtIGwgLyAyKSAvIGwgKiB4LnBhcmFtcy5jb3ZlcmZsb3cubW9kaWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHguaXNIb3Jpem9udGFsKCkgPyBzICogZCA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHguaXNIb3Jpem9udGFsKCkgPyAwIDogcyAqIGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IC1yICogTWF0aC5hYnMoZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHguaXNIb3Jpem9udGFsKCkgPyAwIDogeC5wYXJhbXMuY292ZXJmbG93LnN0cmV0Y2ggKiBkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSB4LmlzSG9yaXpvbnRhbCgpID8geC5wYXJhbXMuY292ZXJmbG93LnN0cmV0Y2ggKiBkIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGgpIDwgLjAwMSAmJiAoaCA9IDApLCBNYXRoLmFicyhnKSA8IC4wMDEgJiYgKGcgPSAwKSwgTWF0aC5hYnMoYykgPCAuMDAxICYmIChjID0gMCksIE1hdGguYWJzKG0pIDwgLjAwMSAmJiAobSA9IDApLCBNYXRoLmFicyh1KSA8IC4wMDEgJiYgKHUgPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gXCJ0cmFuc2xhdGUzZChcIiArIGggKyBcInB4LFwiICsgZyArIFwicHgsXCIgKyBjICsgXCJweCkgIHJvdGF0ZVgoXCIgKyB1ICsgXCJkZWcpIHJvdGF0ZVkoXCIgKyBtICsgXCJkZWcpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby50cmFuc2Zvcm0odiksIG9bMF0uc3R5bGUuekluZGV4ID0gMSAtIE1hdGguYWJzKE1hdGgucm91bmQoZCkpLCB4LnBhcmFtcy5jb3ZlcmZsb3cuc2xpZGVTaGFkb3dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB4LmlzSG9yaXpvbnRhbCgpID8gby5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKSA6IG8uZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHguaXNIb3Jpem9udGFsKCkgPyBvLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodFwiKSA6IG8uZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID09PSBmLmxlbmd0aCAmJiAoZiA9IGUoJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScgKyAoeC5pc0hvcml6b250YWwoKSA/IFwibGVmdFwiIDogXCJ0b3BcIikgKyAnXCI+PC9kaXY+JyksIG8uYXBwZW5kKGYpKSwgMCA9PT0gdy5sZW5ndGggJiYgKHcgPSBlKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nICsgKHguaXNIb3Jpem9udGFsKCkgPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiKSArICdcIj48L2Rpdj4nKSwgby5hcHBlbmQodykpLCBmLmxlbmd0aCAmJiAoZlswXS5zdHlsZS5vcGFjaXR5ID0gZCA+IDAgPyBkIDogMCksIHcubGVuZ3RoICYmICh3WzBdLnN0eWxlLm9wYWNpdHkgPSAtZCA+IDAgPyAtZCA6IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguYnJvd3Nlci5pZSkgeyB4LndyYXBwZXJbMF0uc3R5bGUucGVyc3BlY3RpdmVPcmlnaW4gPSB0ICsgXCJweCA1MCVcIiB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbihlKSB7IHguc2xpZGVzLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGUpIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC5sYXp5ID0ge1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbEltYWdlTG9hZGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIGxvYWRJbWFnZUluU2xpZGU6IGZ1bmN0aW9uKGEsIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBhICYmICh2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCksIDAgIT09IHguc2xpZGVzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB4LnNsaWRlcy5lcShhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzLmZpbmQoXCIuXCIgKyB4LnBhcmFtcy5sYXp5TG9hZGluZ0NsYXNzICsgXCI6bm90KC5cIiArIHgucGFyYW1zLmxhenlTdGF0dXNMb2FkZWRDbGFzcyArIFwiKTpub3QoLlwiICsgeC5wYXJhbXMubGF6eVN0YXR1c0xvYWRpbmdDbGFzcyArIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXMuaGFzQ2xhc3MoeC5wYXJhbXMubGF6eUxvYWRpbmdDbGFzcykgfHwgcy5oYXNDbGFzcyh4LnBhcmFtcy5sYXp5U3RhdHVzTG9hZGVkQ2xhc3MpIHx8IHMuaGFzQ2xhc3MoeC5wYXJhbXMubGF6eVN0YXR1c0xvYWRpbmdDbGFzcykgfHwgKHIgPSByLmFkZChzWzBdKSksIDAgIT09IHIubGVuZ3RoICYmIHIuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuYWRkQ2xhc3MoeC5wYXJhbXMubGF6eVN0YXR1c0xvYWRpbmdDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGEuYXR0cihcImRhdGEtYmFja2dyb3VuZFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gYS5hdHRyKFwiZGF0YS1zcmNcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGEuYXR0cihcImRhdGEtc3Jjc2V0XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBhLmF0dHIoXCJkYXRhLXNpemVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5sb2FkSW1hZ2UoYVswXSwgaSB8fCByLCBuLCBvLCAhMSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0geCAmJiBudWxsICE9PSB4ICYmIHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPyAoYS5jc3MoXCJiYWNrZ3JvdW5kLWltYWdlXCIsICd1cmwoXCInICsgciArICdcIiknKSwgYS5yZW1vdmVBdHRyKFwiZGF0YS1iYWNrZ3JvdW5kXCIpKSA6IChuICYmIChhLmF0dHIoXCJzcmNzZXRcIiwgbiksIGEucmVtb3ZlQXR0cihcImRhdGEtc3Jjc2V0XCIpKSwgbyAmJiAoYS5hdHRyKFwic2l6ZXNcIiwgbyksIGEucmVtb3ZlQXR0cihcImRhdGEtc2l6ZXNcIikpLCBpICYmIChhLmF0dHIoXCJzcmNcIiwgaSksIGEucmVtb3ZlQXR0cihcImRhdGEtc3JjXCIpKSksIGEuYWRkQ2xhc3MoeC5wYXJhbXMubGF6eVN0YXR1c0xvYWRlZENsYXNzKS5yZW1vdmVDbGFzcyh4LnBhcmFtcy5sYXp5U3RhdHVzTG9hZGluZ0NsYXNzKSwgcy5maW5kKFwiLlwiICsgeC5wYXJhbXMubGF6eVByZWxvYWRlckNsYXNzICsgXCIsIC5cIiArIHgucGFyYW1zLnByZWxvYWRlckNsYXNzKS5yZW1vdmUoKSwgeC5wYXJhbXMubG9vcCAmJiB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHMuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuaGFzQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHgud3JhcHBlci5jaGlsZHJlbignW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArIGUgKyAnXCJdOm5vdCguJyArIHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5sYXp5LmxvYWRJbWFnZUluU2xpZGUobC5pbmRleCgpLCAhMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyBlICsgJ1wiXScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgubGF6eS5sb2FkSW1hZ2VJblNsaWRlKHAuaW5kZXgoKSwgITEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5lbWl0KFwib25MYXp5SW1hZ2VSZWFkeVwiLCB4LCBzWzBdLCBhWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB4LmVtaXQoXCJvbkxhenlJbWFnZUxvYWRcIiwgeCwgc1swXSwgYVswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEsIHQgPSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcImF1dG9cIiA9PT0gdCAmJiAodCA9IDApLCB4LmxhenkuaW5pdGlhbEltYWdlTG9hZGVkIHx8ICh4LmxhenkuaW5pdGlhbEltYWdlTG9hZGVkID0gITApLCB4LnBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKS5lYWNoKGZ1bmN0aW9uKCkgeyB4LmxhenkubG9hZEltYWdlSW5TbGlkZShlKHRoaXMpLmluZGV4KCkpIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGEgPSB4LmFjdGl2ZUluZGV4OyBhIDwgeC5hY3RpdmVJbmRleCArIHQ7IGErKykgeC5zbGlkZXNbYV0gJiYgeC5sYXp5LmxvYWRJbWFnZUluU2xpZGUoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB4LmxhenkubG9hZEltYWdlSW5TbGlkZSh4LmFjdGl2ZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMubGF6eUxvYWRpbmdJblByZXZOZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA+IDEgfHwgeC5wYXJhbXMubGF6eUxvYWRpbmdJblByZXZOZXh0QW1vdW50ICYmIHgucGFyYW1zLmxhenlMb2FkaW5nSW5QcmV2TmV4dEFtb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0geC5wYXJhbXMubGF6eUxvYWRpbmdJblByZXZOZXh0QW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBNYXRoLm1pbih4LmFjdGl2ZUluZGV4ICsgciArIE1hdGgubWF4KHMsIHIpLCB4LnNsaWRlcy5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBNYXRoLm1heCh4LmFjdGl2ZUluZGV4IC0gTWF0aC5tYXgociwgcyksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhID0geC5hY3RpdmVJbmRleCArIHQ7IGEgPCBpOyBhKyspIHguc2xpZGVzW2FdICYmIHgubGF6eS5sb2FkSW1hZ2VJblNsaWRlKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhID0gbjsgYSA8IHguYWN0aXZlSW5kZXg7IGErKykgeC5zbGlkZXNbYV0gJiYgeC5sYXp5LmxvYWRJbWFnZUluU2xpZGUoYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVOZXh0Q2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5sZW5ndGggPiAwICYmIHgubGF6eS5sb2FkSW1hZ2VJblNsaWRlKG8uaW5kZXgoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwubGVuZ3RoID4gMCAmJiB4LmxhenkubG9hZEltYWdlSW5TbGlkZShsLmluZGV4KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblRyYW5zaXRpb25TdGFydDogZnVuY3Rpb24oKSB7IHgucGFyYW1zLmxhenlMb2FkaW5nICYmICh4LnBhcmFtcy5sYXp5TG9hZGluZ09uVHJhbnNpdGlvblN0YXJ0IHx8ICF4LnBhcmFtcy5sYXp5TG9hZGluZ09uVHJhbnNpdGlvblN0YXJ0ICYmICF4LmxhenkuaW5pdGlhbEltYWdlTG9hZGVkKSAmJiB4LmxhenkubG9hZCgpIH0sXHJcbiAgICAgICAgICAgICAgICBvblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uKCkgeyB4LnBhcmFtcy5sYXp5TG9hZGluZyAmJiAheC5wYXJhbXMubGF6eUxvYWRpbmdPblRyYW5zaXRpb25TdGFydCAmJiB4LmxhenkubG9hZCgpIH1cclxuICAgICAgICAgICAgfSwgeC5zY3JvbGxiYXIgPSB7XHJcbiAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6ICExLFxyXG4gICAgICAgICAgICAgICAgc2V0RHJhZ1Bvc2l0aW9uOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4LnNjcm9sbGJhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHguaXNIb3Jpem9udGFsKCkgPyBcInRvdWNoc3RhcnRcIiA9PT0gZS50eXBlIHx8IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVggfHwgZS5jbGllbnRYIDogXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSB8fCBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZIHx8IGUuY2xpZW50WSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHQgLSBhLnRyYWNrLm9mZnNldCgpW3guaXNIb3Jpem9udGFsKCkgPyBcImxlZnRcIiA6IFwidG9wXCJdIC0gYS5kcmFnU2l6ZSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAteC5taW5UcmFuc2xhdGUoKSAqIGEubW92ZURpdmlkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAteC5tYXhUcmFuc2xhdGUoKSAqIGEubW92ZURpdmlkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA8IHIgPyBzID0gciA6IHMgPiBpICYmIChzID0gaSksIHMgPSAtcyAvIGEubW92ZURpdmlkZXIsIHgudXBkYXRlUHJvZ3Jlc3MocyksIHguc2V0V3JhcHBlclRyYW5zbGF0ZShzLCAhMClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHguc2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaXNUb3VjaGVkID0gITAsIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgYS5zZXREcmFnUG9zaXRpb24oZSksIGNsZWFyVGltZW91dChhLmRyYWdUaW1lb3V0KSwgYS50cmFjay50cmFuc2l0aW9uKDApLCB4LnBhcmFtcy5zY3JvbGxiYXJIaWRlICYmIGEudHJhY2suY3NzKFwib3BhY2l0eVwiLCAxKSwgeC53cmFwcGVyLnRyYW5zaXRpb24oMTAwKSwgYS5kcmFnLnRyYW5zaXRpb24oMTAwKSwgeC5lbWl0KFwib25TY3JvbGxiYXJEcmFnU3RhcnRcIiwgeClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkcmFnTW92ZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0geC5zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5pc1RvdWNoZWQgJiYgKGUucHJldmVudERlZmF1bHQgPyBlLnByZXZlbnREZWZhdWx0KCkgOiBlLnJldHVyblZhbHVlID0gITEsIGEuc2V0RHJhZ1Bvc2l0aW9uKGUpLCB4LndyYXBwZXIudHJhbnNpdGlvbigwKSwgYS50cmFjay50cmFuc2l0aW9uKDApLCBhLmRyYWcudHJhbnNpdGlvbigwKSwgeC5lbWl0KFwib25TY3JvbGxiYXJEcmFnTW92ZVwiLCB4KSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkcmFnRW5kOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4LnNjcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICBhLmlzVG91Y2hlZCAmJiAoYS5pc1RvdWNoZWQgPSAhMSwgeC5wYXJhbXMuc2Nyb2xsYmFySGlkZSAmJiAoY2xlYXJUaW1lb3V0KGEuZHJhZ1RpbWVvdXQpLCBhLmRyYWdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgYS50cmFjay5jc3MoXCJvcGFjaXR5XCIsIDApLCBhLnRyYWNrLnRyYW5zaXRpb24oNDAwKSB9LCAxZTMpKSwgeC5lbWl0KFwib25TY3JvbGxiYXJEcmFnRW5kXCIsIHgpLCB4LnBhcmFtcy5zY3JvbGxiYXJTbmFwT25SZWxlYXNlICYmIHguc2xpZGVSZXNldCgpKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZUV2ZW50czogZnVuY3Rpb24oKSB7IHJldHVybiB4LnBhcmFtcy5zaW11bGF0ZVRvdWNoICE9PSAhMSB8fCB4LnN1cHBvcnQudG91Y2ggPyB4LnRvdWNoRXZlbnRzIDogeC50b3VjaEV2ZW50c0Rlc2t0b3AgfSgpLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlRHJhZ2dhYmxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHguc2Nyb2xsYmFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0geC5zdXBwb3J0LnRvdWNoID8gYS50cmFjayA6IGRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGUoYS50cmFjaykub24oYS5kcmFnZ2FibGVFdmVudHMuc3RhcnQsIGEuZHJhZ1N0YXJ0KSwgZSh0KS5vbihhLmRyYWdnYWJsZUV2ZW50cy5tb3ZlLCBhLmRyYWdNb3ZlKSwgZSh0KS5vbihhLmRyYWdnYWJsZUV2ZW50cy5lbmQsIGEuZHJhZ0VuZClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlRHJhZ2dhYmxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHguc2Nyb2xsYmFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0geC5zdXBwb3J0LnRvdWNoID8gYS50cmFjayA6IGRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGUoYS50cmFjaykub2ZmKGEuZHJhZ2dhYmxlRXZlbnRzLnN0YXJ0LCBhLmRyYWdTdGFydCksIGUodCkub2ZmKGEuZHJhZ2dhYmxlRXZlbnRzLm1vdmUsIGEuZHJhZ01vdmUpLCBlKHQpLm9mZihhLmRyYWdnYWJsZUV2ZW50cy5lbmQsIGEuZHJhZ0VuZClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5zY3JvbGxiYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4LnNjcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS50cmFjayA9IGUoeC5wYXJhbXMuc2Nyb2xsYmFyKSwgeC5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIGEudHJhY2subGVuZ3RoID4gMSAmJiAxID09PSB4LmNvbnRhaW5lci5maW5kKHgucGFyYW1zLnNjcm9sbGJhcikubGVuZ3RoICYmIChhLnRyYWNrID0geC5jb250YWluZXIuZmluZCh4LnBhcmFtcy5zY3JvbGxiYXIpKSwgYS5kcmFnID0gYS50cmFjay5maW5kKFwiLnN3aXBlci1zY3JvbGxiYXItZHJhZ1wiKSwgMCA9PT0gYS5kcmFnLmxlbmd0aCAmJiAoYS5kcmFnID0gZSgnPGRpdiBjbGFzcz1cInN3aXBlci1zY3JvbGxiYXItZHJhZ1wiPjwvZGl2PicpLCBhLnRyYWNrLmFwcGVuZChhLmRyYWcpKSwgYS5kcmFnWzBdLnN0eWxlLndpZHRoID0gXCJcIiwgYS5kcmFnWzBdLnN0eWxlLmhlaWdodCA9IFwiXCIsIGEudHJhY2tTaXplID0geC5pc0hvcml6b250YWwoKSA/IGEudHJhY2tbMF0ub2Zmc2V0V2lkdGggOiBhLnRyYWNrWzBdLm9mZnNldEhlaWdodCwgYS5kaXZpZGVyID0geC5zaXplIC8geC52aXJ0dWFsU2l6ZSwgYS5tb3ZlRGl2aWRlciA9IGEuZGl2aWRlciAqIChhLnRyYWNrU2l6ZSAvIHguc2l6ZSksIGEuZHJhZ1NpemUgPSBhLnRyYWNrU2l6ZSAqIGEuZGl2aWRlciwgeC5pc0hvcml6b250YWwoKSA/IGEuZHJhZ1swXS5zdHlsZS53aWR0aCA9IGEuZHJhZ1NpemUgKyBcInB4XCIgOiBhLmRyYWdbMF0uc3R5bGUuaGVpZ2h0ID0gYS5kcmFnU2l6ZSArIFwicHhcIiwgYS5kaXZpZGVyID49IDEgPyBhLnRyYWNrWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiA6IGEudHJhY2tbMF0uc3R5bGUuZGlzcGxheSA9IFwiXCIsIHgucGFyYW1zLnNjcm9sbGJhckhpZGUgJiYgKGEudHJhY2tbMF0uc3R5bGUub3BhY2l0eSA9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLnNjcm9sbGJhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSwgYSA9IHguc2Nyb2xsYmFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh4LnRyYW5zbGF0ZSwgYS5kcmFnU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAoYS50cmFja1NpemUgLSBhLmRyYWdTaXplKSAqIHgucHJvZ3Jlc3MsIHgucnRsICYmIHguaXNIb3Jpem9udGFsKCkgPyAoZSA9IC1lLCBlID4gMCA/ICh0ID0gYS5kcmFnU2l6ZSAtIGUsIGUgPSAwKSA6IC1lICsgYS5kcmFnU2l6ZSA+IGEudHJhY2tTaXplICYmICh0ID0gYS50cmFja1NpemUgKyBlKSkgOiBlIDwgMCA/ICh0ID0gYS5kcmFnU2l6ZSArIGUsIGUgPSAwKSA6IGUgKyBhLmRyYWdTaXplID4gYS50cmFja1NpemUgJiYgKHQgPSBhLnRyYWNrU2l6ZSAtIGUpLCB4LmlzSG9yaXpvbnRhbCgpID8gKHguc3VwcG9ydC50cmFuc2Zvcm1zM2QgPyBhLmRyYWcudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIgKyBlICsgXCJweCwgMCwgMClcIikgOiBhLmRyYWcudHJhbnNmb3JtKFwidHJhbnNsYXRlWChcIiArIGUgKyBcInB4KVwiKSwgYS5kcmFnWzBdLnN0eWxlLndpZHRoID0gdCArIFwicHhcIikgOiAoeC5zdXBwb3J0LnRyYW5zZm9ybXMzZCA/IGEuZHJhZy50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwcHgsIFwiICsgZSArIFwicHgsIDApXCIpIDogYS5kcmFnLnRyYW5zZm9ybShcInRyYW5zbGF0ZVkoXCIgKyBlICsgXCJweClcIiksIGEuZHJhZ1swXS5zdHlsZS5oZWlnaHQgPSB0ICsgXCJweFwiKSwgeC5wYXJhbXMuc2Nyb2xsYmFySGlkZSAmJiAoY2xlYXJUaW1lb3V0KGEudGltZW91dCksIGEudHJhY2tbMF0uc3R5bGUub3BhY2l0eSA9IDEsIGEudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGEudHJhY2tbMF0uc3R5bGUub3BhY2l0eSA9IDAsIGEudHJhY2sudHJhbnNpdGlvbig0MDApIH0sIDFlMykpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKGUpIHsgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyLmRyYWcudHJhbnNpdGlvbihlKSB9XHJcbiAgICAgICAgICAgIH0sIHguY29udHJvbGxlciA9IHtcclxuICAgICAgICAgICAgICAgIExpbmVhclNwbGluZTogZnVuY3Rpb24oZSwgYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7IHZhciBlLCBhLCB0OyByZXR1cm4gZnVuY3Rpb24ocywgcikgeyBmb3IgKGEgPSAtMSwgZSA9IHMubGVuZ3RoOyBlIC0gYSA+IDE7KSBzW3QgPSBlICsgYSA+PiAxXSA8PSByID8gYSA9IHQgOiBlID0gdDsgcmV0dXJuIGUgfSB9KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gZSwgdGhpcy55ID0gYSwgdGhpcy5sYXN0SW5kZXggPSBlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMsIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA/IChyID0gdCh0aGlzLngsIGUpLCBzID0gciAtIDEsIChlIC0gdGhpcy54W3NdKSAqICh0aGlzLnlbcl0gLSB0aGlzLnlbc10pIC8gKHRoaXMueFtyXSAtIHRoaXMueFtzXSkgKyB0aGlzLnlbc10pIDogMCB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbjogZnVuY3Rpb24oZSkgeyB4LmNvbnRyb2xsZXIuc3BsaW5lIHx8ICh4LmNvbnRyb2xsZXIuc3BsaW5lID0geC5wYXJhbXMubG9vcCA/IG5ldyB4LmNvbnRyb2xsZXIuTGluZWFyU3BsaW5lKHguc2xpZGVzR3JpZCwgZS5zbGlkZXNHcmlkKSA6IG5ldyB4LmNvbnRyb2xsZXIuTGluZWFyU3BsaW5lKHguc25hcEdyaWQsIGUuc25hcEdyaWQpKSB9LFxyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhhKSB7IGUgPSBhLnJ0bCAmJiBcImhvcml6b250YWxcIiA9PT0gYS5wYXJhbXMuZGlyZWN0aW9uID8gLXgudHJhbnNsYXRlIDogeC50cmFuc2xhdGUsIFwic2xpZGVcIiA9PT0geC5wYXJhbXMuY29udHJvbEJ5ICYmICh4LmNvbnRyb2xsZXIuZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbihhKSwgaSA9IC14LmNvbnRyb2xsZXIuc3BsaW5lLmludGVycG9sYXRlKC1lKSksIGkgJiYgXCJjb250YWluZXJcIiAhPT0geC5wYXJhbXMuY29udHJvbEJ5IHx8IChyID0gKGEubWF4VHJhbnNsYXRlKCkgLSBhLm1pblRyYW5zbGF0ZSgpKSAvICh4Lm1heFRyYW5zbGF0ZSgpIC0geC5taW5UcmFuc2xhdGUoKSksIGkgPSAoZSAtIHgubWluVHJhbnNsYXRlKCkpICogciArIGEubWluVHJhbnNsYXRlKCkpLCB4LnBhcmFtcy5jb250cm9sSW52ZXJzZSAmJiAoaSA9IGEubWF4VHJhbnNsYXRlKCkgLSBpKSwgYS51cGRhdGVQcm9ncmVzcyhpKSwgYS5zZXRXcmFwcGVyVHJhbnNsYXRlKGksICExLCB4KSwgYS51cGRhdGVBY3RpdmVJbmRleCgpIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgciwgaSwgbiA9IHgucGFyYW1zLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKykgbltvXSAhPT0gdCAmJiBuW29dIGluc3RhbmNlb2YgYSAmJiBzKG5bb10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgbiBpbnN0YW5jZW9mIGEgJiYgdCAhPT0gbiAmJiBzKG4pXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoYSkgeyBhLnNldFdyYXBwZXJUcmFuc2l0aW9uKGUsIHgpLCAwICE9PSBlICYmIChhLm9uVHJhbnNpdGlvblN0YXJ0KCksIGEud3JhcHBlci50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uKCkgeyBpICYmIChhLnBhcmFtcy5sb29wICYmIFwic2xpZGVcIiA9PT0geC5wYXJhbXMuY29udHJvbEJ5ICYmIGEuZml4TG9vcCgpLCBhLm9uVHJhbnNpdGlvbkVuZCgpKSB9KSkgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByLCBpID0geC5wYXJhbXMuY29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IGkubGVuZ3RoOyByKyspIGlbcl0gIT09IHQgJiYgaVtyXSBpbnN0YW5jZW9mIGEgJiYgcyhpW3JdKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGkgaW5zdGFuY2VvZiBhICYmIHQgIT09IGkgJiYgcyhpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB4Lmhhc2huYXYgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkhhc2hDYW5nZTogZnVuY3Rpb24oZSwgYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZG9jdW1lbnQubG9jYXRpb24uaGFzaC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0ICE9PSB4LnNsaWRlcy5lcSh4LmFjdGl2ZUluZGV4KS5hdHRyKFwiZGF0YS1oYXNoXCIpICYmIHguc2xpZGVUbyh4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgJ1tkYXRhLWhhc2g9XCInICsgdCArICdcIl0nKS5pbmRleCgpKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50czogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYSA/IFwib2ZmXCIgOiBcIm9uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZSh3aW5kb3cpW3RdKFwiaGFzaGNoYW5nZVwiLCB4Lmhhc2huYXYub25IYXNoQ2FuZ2UpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0SGFzaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguaGFzaG5hdi5pbml0aWFsaXplZCAmJiB4LnBhcmFtcy5oYXNobmF2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMucmVwbGFjZVN0YXRlICYmIHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIFwiI1wiICsgeC5zbGlkZXMuZXEoeC5hY3RpdmVJbmRleCkuYXR0cihcImRhdGEtaGFzaFwiKSB8fCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHguc2xpZGVzLmVxKHguYWN0aXZlSW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBlLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgZS5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGEgfHwgXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmhhc2huYXYgJiYgIXgucGFyYW1zLmhpc3RvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5oYXNobmF2LmluaXRpYWxpemVkID0gITA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gZG9jdW1lbnQubG9jYXRpb24uaGFzaC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMCwgdCA9IHguc2xpZGVzLmxlbmd0aDsgYSA8IHQ7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0geC5zbGlkZXMuZXEoYSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgcy5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID09PSBlICYmICFzLmhhc0NsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gcy5pbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnNsaWRlVG8oaSwgMCwgeC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCAhMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgucGFyYW1zLmhhc2huYXZXYXRjaFN0YXRlICYmIHguaGFzaG5hdi5hdHRhY2hFdmVudHMoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHsgeC5wYXJhbXMuaGFzaG5hdldhdGNoU3RhdGUgJiYgeC5oYXNobmF2LmF0dGFjaEV2ZW50cyghMCkgfVxyXG4gICAgICAgICAgICB9LCB4Lmhpc3RvcnkgPSB7XHJcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMuaGlzdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5oaXN0b3J5IHx8ICF3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHJldHVybiB4LnBhcmFtcy5oaXN0b3J5ID0gITEsIHZvaWQoeC5wYXJhbXMuaGFzaG5hdiA9ICEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5oaXN0b3J5LmluaXRpYWxpemVkID0gITAsIHRoaXMucGF0aHMgPSB0aGlzLmdldFBhdGhWYWx1ZXMoKSwgKHRoaXMucGF0aHMua2V5IHx8IHRoaXMucGF0aHMudmFsdWUpICYmICh0aGlzLnNjcm9sbFRvU2xpZGUoMCwgdGhpcy5wYXRocy52YWx1ZSwgeC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSwgeC5wYXJhbXMucmVwbGFjZVN0YXRlIHx8IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5zZXRIaXN0b3J5UG9wU3RhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXRIaXN0b3J5UG9wU3RhdGU6IGZ1bmN0aW9uKCkgeyB4Lmhpc3RvcnkucGF0aHMgPSB4Lmhpc3RvcnkuZ2V0UGF0aFZhbHVlcygpLCB4Lmhpc3Rvcnkuc2Nyb2xsVG9TbGlkZSh4LnBhcmFtcy5zcGVlZCwgeC5oaXN0b3J5LnBhdGhzLnZhbHVlLCAhMSkgfSxcclxuICAgICAgICAgICAgICAgIGdldFBhdGhWYWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnNsaWNlKDEpLnNwbGl0KFwiL1wiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogZVthIC0gMl0sIHZhbHVlOiBlW2EgLSAxXSB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0SGlzdG9yeTogZnVuY3Rpb24oZSwgYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Lmhpc3RvcnkuaW5pdGlhbGl6ZWQgJiYgeC5wYXJhbXMuaGlzdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguc2xpZGVzLmVxKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHRoaXMuc2x1Z2lmeSh0LmF0dHIoXCJkYXRhLWhpc3RvcnlcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuaW5jbHVkZXMoZSkgfHwgKHMgPSBlICsgXCIvXCIgKyBzKSwgeC5wYXJhbXMucmVwbGFjZVN0YXRlID8gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIHMpIDogd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNsdWdpZnk6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgXCItXCIpLnJlcGxhY2UoL1teXFx3XFwtXSsvZywgXCJcIikucmVwbGFjZSgvXFwtXFwtKy9nLCBcIi1cIikucmVwbGFjZSgvXi0rLywgXCJcIikucmVwbGFjZSgvLSskLywgXCJcIikgfSxcclxuICAgICAgICAgICAgICAgIHNjcm9sbFRvU2xpZGU6IGZ1bmN0aW9uKGUsIGEsIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDAsIHIgPSB4LnNsaWRlcy5sZW5ndGg7IHMgPCByOyBzKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0geC5zbGlkZXMuZXEocyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMuc2x1Z2lmeShpLmF0dHIoXCJkYXRhLWhpc3RvcnlcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IGEgJiYgIWkuaGFzQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnNsaWRlVG8obywgZSwgdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHguc2xpZGVUbygwLCBlLCB0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB4LmRpc2FibGVLZXlib2FyZENvbnRyb2wgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMua2V5Ym9hcmRDb250cm9sID0gITEsIGUoZG9jdW1lbnQpLm9mZihcImtleWRvd25cIiwgbCkgfSwgeC5lbmFibGVLZXlib2FyZENvbnRyb2wgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMua2V5Ym9hcmRDb250cm9sID0gITAsIGUoZG9jdW1lbnQpLm9uKFwia2V5ZG93blwiLCBsKSB9LCB4Lm1vdXNld2hlZWwgPSB7IGV2ZW50OiAhMSwgbGFzdFNjcm9sbFRpbWU6IChuZXcgd2luZG93LkRhdGUpLmdldFRpbWUoKSB9LCB4LnBhcmFtcy5tb3VzZXdoZWVsQ29udHJvbCAmJiAoeC5tb3VzZXdoZWVsLmV2ZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiZmlyZWZveFwiKSA+IC0xID8gXCJET01Nb3VzZVNjcm9sbFwiIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IFwib253aGVlbFwiIGluIGRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKFwib253aGVlbFwiLCBcInJldHVybjtcIiksIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEub253aGVlbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFlICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIlwiLCBcIlwiKSAhPT0gITAgJiYgKGUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiRXZlbnRzLndoZWVsXCIsIFwiMy4wXCIpKSwgZVxyXG4gICAgICAgICAgICB9KCkgPyBcIndoZWVsXCIgOiBcIm1vdXNld2hlZWxcIiksIHguZGlzYWJsZU1vdXNld2hlZWxDb250cm9sID0gZnVuY3Rpb24oKSB7IGlmICgheC5tb3VzZXdoZWVsLmV2ZW50KSByZXR1cm4gITE7IHZhciBhID0geC5jb250YWluZXI7IHJldHVybiBcImNvbnRhaW5lclwiICE9PSB4LnBhcmFtcy5tb3VzZXdoZWVsRXZlbnRzVGFyZ2VkICYmIChhID0gZSh4LnBhcmFtcy5tb3VzZXdoZWVsRXZlbnRzVGFyZ2VkKSksIGEub2ZmKHgubW91c2V3aGVlbC5ldmVudCwgZCksIHgucGFyYW1zLm1vdXNld2hlZWxDb250cm9sID0gITEsICEwIH0sIHguZW5hYmxlTW91c2V3aGVlbENvbnRyb2wgPSBmdW5jdGlvbigpIHsgaWYgKCF4Lm1vdXNld2hlZWwuZXZlbnQpIHJldHVybiAhMTsgdmFyIGEgPSB4LmNvbnRhaW5lcjsgcmV0dXJuIFwiY29udGFpbmVyXCIgIT09IHgucGFyYW1zLm1vdXNld2hlZWxFdmVudHNUYXJnZWQgJiYgKGEgPSBlKHgucGFyYW1zLm1vdXNld2hlZWxFdmVudHNUYXJnZWQpKSwgYS5vbih4Lm1vdXNld2hlZWwuZXZlbnQsIGQpLCB4LnBhcmFtcy5tb3VzZXdoZWVsQ29udHJvbCA9ICEwLCAhMCB9LCB4LnBhcmFsbGF4ID0ge1xyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB4LmNvbnRhaW5lci5jaGlsZHJlbihcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldXCIpLmVhY2goZnVuY3Rpb24oKSB7IG0odGhpcywgeC5wcm9ncmVzcykgfSksIHguc2xpZGVzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5maW5kKFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV1cIikuZWFjaChmdW5jdGlvbigpIHsgbSh0aGlzLCBNYXRoLm1pbihNYXRoLm1heChhWzBdLnByb2dyZXNzLCAtMSksIDEpKSB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IHgucGFyYW1zLnNwZWVkKSwgeC5jb250YWluZXIuZmluZChcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldXCIpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZSh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBwYXJzZUludCh0LmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC1kdXJhdGlvblwiKSwgMTApIHx8IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IGEgJiYgKHMgPSAwKSwgdC50cmFuc2l0aW9uKHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC56b29tID0ge1xyXG4gICAgICAgICAgICAgICAgc2NhbGU6IDEsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NhbGU6IDEsXHJcbiAgICAgICAgICAgICAgICBpc1NjYWxpbmc6ICExLFxyXG4gICAgICAgICAgICAgICAgZ2VzdHVyZTogeyBzbGlkZTogdm9pZCAwLCBzbGlkZVdpZHRoOiB2b2lkIDAsIHNsaWRlSGVpZ2h0OiB2b2lkIDAsIGltYWdlOiB2b2lkIDAsIGltYWdlV3JhcDogdm9pZCAwLCB6b29tTWF4OiB4LnBhcmFtcy56b29tTWF4IH0sXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogeyBpc1RvdWNoZWQ6IHZvaWQgMCwgaXNNb3ZlZDogdm9pZCAwLCBjdXJyZW50WDogdm9pZCAwLCBjdXJyZW50WTogdm9pZCAwLCBtaW5YOiB2b2lkIDAsIG1pblk6IHZvaWQgMCwgbWF4WDogdm9pZCAwLCBtYXhZOiB2b2lkIDAsIHdpZHRoOiB2b2lkIDAsIGhlaWdodDogdm9pZCAwLCBzdGFydFg6IHZvaWQgMCwgc3RhcnRZOiB2b2lkIDAsIHRvdWNoZXNTdGFydDoge30sIHRvdWNoZXNDdXJyZW50OiB7fSB9LFxyXG4gICAgICAgICAgICAgICAgdmVsb2NpdHk6IHsgeDogdm9pZCAwLCB5OiB2b2lkIDAsIHByZXZQb3NpdGlvblg6IHZvaWQgMCwgcHJldlBvc2l0aW9uWTogdm9pZCAwLCBwcmV2VGltZTogdm9pZCAwIH0sXHJcbiAgICAgICAgICAgICAgICBnZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHMgLSBhLCAyKSArIE1hdGgucG93KHIgLSB0LCAyKSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkdlc3R1cmVTdGFydDogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0geC56b29tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgheC5zdXBwb3J0Lmdlc3R1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInRvdWNoc3RhcnRcIiAhPT0gYS50eXBlIHx8IFwidG91Y2hzdGFydFwiID09PSBhLnR5cGUgJiYgYS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5nZXN0dXJlLnNjYWxlU3RhcnQgPSB0LmdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoYSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodC5nZXN0dXJlLnNsaWRlICYmIHQuZ2VzdHVyZS5zbGlkZS5sZW5ndGggfHwgKHQuZ2VzdHVyZS5zbGlkZSA9IGUodGhpcyksIDAgPT09IHQuZ2VzdHVyZS5zbGlkZS5sZW5ndGggJiYgKHQuZ2VzdHVyZS5zbGlkZSA9IHguc2xpZGVzLmVxKHguYWN0aXZlSW5kZXgpKSwgdC5nZXN0dXJlLmltYWdlID0gdC5nZXN0dXJlLnNsaWRlLmZpbmQoXCJpbWcsIHN2ZywgY2FudmFzXCIpLCB0Lmdlc3R1cmUuaW1hZ2VXcmFwID0gdC5nZXN0dXJlLmltYWdlLnBhcmVudChcIi5cIiArIHgucGFyYW1zLnpvb21Db250YWluZXJDbGFzcyksIHQuZ2VzdHVyZS56b29tTWF4ID0gdC5nZXN0dXJlLmltYWdlV3JhcC5hdHRyKFwiZGF0YS1zd2lwZXItem9vbVwiKSB8fCB4LnBhcmFtcy56b29tTWF4LCAwICE9PSB0Lmdlc3R1cmUuaW1hZ2VXcmFwLmxlbmd0aCkpKSByZXR1cm4gdm9pZCh0Lmdlc3R1cmUuaW1hZ2UgPSB2b2lkIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuZ2VzdHVyZS5pbWFnZS50cmFuc2l0aW9uKDApLCB0LmlzU2NhbGluZyA9ICEwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25HZXN0dXJlQ2hhbmdlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4Lnpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF4LnN1cHBvcnQuZ2VzdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidG91Y2htb3ZlXCIgIT09IGUudHlwZSB8fCBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5nZXN0dXJlLnNjYWxlTW92ZSA9IGEuZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlcyhlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhLmdlc3R1cmUuaW1hZ2UgJiYgMCAhPT0gYS5nZXN0dXJlLmltYWdlLmxlbmd0aCAmJiAoeC5zdXBwb3J0Lmdlc3R1cmVzID8gYS5zY2FsZSA9IGUuc2NhbGUgKiBhLmN1cnJlbnRTY2FsZSA6IGEuc2NhbGUgPSBhLmdlc3R1cmUuc2NhbGVNb3ZlIC8gYS5nZXN0dXJlLnNjYWxlU3RhcnQgKiBhLmN1cnJlbnRTY2FsZSwgYS5zY2FsZSA+IGEuZ2VzdHVyZS56b29tTWF4ICYmIChhLnNjYWxlID0gYS5nZXN0dXJlLnpvb21NYXggLSAxICsgTWF0aC5wb3coYS5zY2FsZSAtIGEuZ2VzdHVyZS56b29tTWF4ICsgMSwgLjUpKSwgYS5zY2FsZSA8IHgucGFyYW1zLnpvb21NaW4gJiYgKGEuc2NhbGUgPSB4LnBhcmFtcy56b29tTWluICsgMSAtIE1hdGgucG93KHgucGFyYW1zLnpvb21NaW4gLSBhLnNjYWxlICsgMSwgLjUpKSwgYS5nZXN0dXJlLmltYWdlLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZShcIiArIGEuc2NhbGUgKyBcIilcIikpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25HZXN0dXJlRW5kOiBmdW5jdGlvbihlKSB7IHZhciBhID0geC56b29tOyF4LnN1cHBvcnQuZ2VzdHVyZXMgJiYgKFwidG91Y2hlbmRcIiAhPT0gZS50eXBlIHx8IFwidG91Y2hlbmRcIiA9PT0gZS50eXBlICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDwgMikgfHwgYS5nZXN0dXJlLmltYWdlICYmIDAgIT09IGEuZ2VzdHVyZS5pbWFnZS5sZW5ndGggJiYgKGEuc2NhbGUgPSBNYXRoLm1heChNYXRoLm1pbihhLnNjYWxlLCBhLmdlc3R1cmUuem9vbU1heCksIHgucGFyYW1zLnpvb21NaW4pLCBhLmdlc3R1cmUuaW1hZ2UudHJhbnNpdGlvbih4LnBhcmFtcy5zcGVlZCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKFwiICsgYS5zY2FsZSArIFwiKVwiKSwgYS5jdXJyZW50U2NhbGUgPSBhLnNjYWxlLCBhLmlzU2NhbGluZyA9ICExLCAxID09PSBhLnNjYWxlICYmIChhLmdlc3R1cmUuc2xpZGUgPSB2b2lkIDApKSB9LFxyXG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbihlLCBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgdC5nZXN0dXJlLmltYWdlICYmIDAgIT09IHQuZ2VzdHVyZS5pbWFnZS5sZW5ndGggJiYgKHQuaW1hZ2UuaXNUb3VjaGVkIHx8IChcImFuZHJvaWRcIiA9PT0gZS5kZXZpY2Uub3MgJiYgYS5wcmV2ZW50RGVmYXVsdCgpLCB0LmltYWdlLmlzVG91Y2hlZCA9ICEwLCB0LmltYWdlLnRvdWNoZXNTdGFydC54ID0gXCJ0b3VjaHN0YXJ0XCIgPT09IGEudHlwZSA/IGEudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGEucGFnZVgsIHQuaW1hZ2UudG91Y2hlc1N0YXJ0LnkgPSBcInRvdWNoc3RhcnRcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogYS5wYWdlWSkpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25Ub3VjaE1vdmU6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHguem9vbTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5nZXN0dXJlLmltYWdlICYmIDAgIT09IGEuZ2VzdHVyZS5pbWFnZS5sZW5ndGggJiYgKHguYWxsb3dDbGljayA9ICExLCBhLmltYWdlLmlzVG91Y2hlZCAmJiBhLmdlc3R1cmUuc2xpZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuaW1hZ2UuaXNNb3ZlZCB8fCAoYS5pbWFnZS53aWR0aCA9IGEuZ2VzdHVyZS5pbWFnZVswXS5vZmZzZXRXaWR0aCwgYS5pbWFnZS5oZWlnaHQgPSBhLmdlc3R1cmUuaW1hZ2VbMF0ub2Zmc2V0SGVpZ2h0LCBhLmltYWdlLnN0YXJ0WCA9IHguZ2V0VHJhbnNsYXRlKGEuZ2VzdHVyZS5pbWFnZVdyYXBbMF0sIFwieFwiKSB8fCAwLCBhLmltYWdlLnN0YXJ0WSA9IHguZ2V0VHJhbnNsYXRlKGEuZ2VzdHVyZS5pbWFnZVdyYXBbMF0sIFwieVwiKSB8fCAwLCBhLmdlc3R1cmUuc2xpZGVXaWR0aCA9IGEuZ2VzdHVyZS5zbGlkZVswXS5vZmZzZXRXaWR0aCwgYS5nZXN0dXJlLnNsaWRlSGVpZ2h0ID0gYS5nZXN0dXJlLnNsaWRlWzBdLm9mZnNldEhlaWdodCwgYS5nZXN0dXJlLmltYWdlV3JhcC50cmFuc2l0aW9uKDApLCB4LnJ0bCAmJiAoYS5pbWFnZS5zdGFydFggPSAtYS5pbWFnZS5zdGFydFgpLCB4LnJ0bCAmJiAoYS5pbWFnZS5zdGFydFkgPSAtYS5pbWFnZS5zdGFydFkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBhLmltYWdlLndpZHRoICogYS5zY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBhLmltYWdlLmhlaWdodCAqIGEuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPCBhLmdlc3R1cmUuc2xpZGVXaWR0aCAmJiBzIDwgYS5nZXN0dXJlLnNsaWRlSGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEuaW1hZ2UubWluWCA9IE1hdGgubWluKGEuZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMiAtIHQgLyAyLCAwKSwgYS5pbWFnZS5tYXhYID0gLWEuaW1hZ2UubWluWCwgYS5pbWFnZS5taW5ZID0gTWF0aC5taW4oYS5nZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMiAtIHMgLyAyLCAwKSwgYS5pbWFnZS5tYXhZID0gLWEuaW1hZ2UubWluWSwgYS5pbWFnZS50b3VjaGVzQ3VycmVudC54ID0gXCJ0b3VjaG1vdmVcIiA9PT0gZS50eXBlID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWCwgYS5pbWFnZS50b3VjaGVzQ3VycmVudC55ID0gXCJ0b3VjaG1vdmVcIiA9PT0gZS50eXBlID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWSwgIWEuaW1hZ2UuaXNNb3ZlZCAmJiAhYS5pc1NjYWxpbmcpIHsgaWYgKHguaXNIb3Jpem9udGFsKCkgJiYgTWF0aC5mbG9vcihhLmltYWdlLm1pblgpID09PSBNYXRoLmZsb29yKGEuaW1hZ2Uuc3RhcnRYKSAmJiBhLmltYWdlLnRvdWNoZXNDdXJyZW50LnggPCBhLmltYWdlLnRvdWNoZXNTdGFydC54IHx8IE1hdGguZmxvb3IoYS5pbWFnZS5tYXhYKSA9PT0gTWF0aC5mbG9vcihhLmltYWdlLnN0YXJ0WCkgJiYgYS5pbWFnZS50b3VjaGVzQ3VycmVudC54ID4gYS5pbWFnZS50b3VjaGVzU3RhcnQueCkgcmV0dXJuIHZvaWQoYS5pbWFnZS5pc1RvdWNoZWQgPSAhMSk7IGlmICgheC5pc0hvcml6b250YWwoKSAmJiBNYXRoLmZsb29yKGEuaW1hZ2UubWluWSkgPT09IE1hdGguZmxvb3IoYS5pbWFnZS5zdGFydFkpICYmIGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA8IGEuaW1hZ2UudG91Y2hlc1N0YXJ0LnkgfHwgTWF0aC5mbG9vcihhLmltYWdlLm1heFkpID09PSBNYXRoLmZsb29yKGEuaW1hZ2Uuc3RhcnRZKSAmJiBhLmltYWdlLnRvdWNoZXNDdXJyZW50LnkgPiBhLmltYWdlLnRvdWNoZXNTdGFydC55KSByZXR1cm4gdm9pZChhLmltYWdlLmlzVG91Y2hlZCA9ICExKSB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIGEuaW1hZ2UuaXNNb3ZlZCA9ICEwLCBhLmltYWdlLmN1cnJlbnRYID0gYS5pbWFnZS50b3VjaGVzQ3VycmVudC54IC0gYS5pbWFnZS50b3VjaGVzU3RhcnQueCArIGEuaW1hZ2Uuc3RhcnRYLCBhLmltYWdlLmN1cnJlbnRZID0gYS5pbWFnZS50b3VjaGVzQ3VycmVudC55IC0gYS5pbWFnZS50b3VjaGVzU3RhcnQueSArIGEuaW1hZ2Uuc3RhcnRZLCBhLmltYWdlLmN1cnJlbnRYIDwgYS5pbWFnZS5taW5YICYmIChhLmltYWdlLmN1cnJlbnRYID0gYS5pbWFnZS5taW5YICsgMSAtIE1hdGgucG93KGEuaW1hZ2UubWluWCAtIGEuaW1hZ2UuY3VycmVudFggKyAxLCAuOCkpLCBhLmltYWdlLmN1cnJlbnRYID4gYS5pbWFnZS5tYXhYICYmIChhLmltYWdlLmN1cnJlbnRYID0gYS5pbWFnZS5tYXhYIC0gMSArIE1hdGgucG93KGEuaW1hZ2UuY3VycmVudFggLSBhLmltYWdlLm1heFggKyAxLCAuOCkpLCBhLmltYWdlLmN1cnJlbnRZIDwgYS5pbWFnZS5taW5ZICYmIChhLmltYWdlLmN1cnJlbnRZID0gYS5pbWFnZS5taW5ZICsgMSAtIE1hdGgucG93KGEuaW1hZ2UubWluWSAtIGEuaW1hZ2UuY3VycmVudFkgKyAxLCAuOCkpLCBhLmltYWdlLmN1cnJlbnRZID4gYS5pbWFnZS5tYXhZICYmIChhLmltYWdlLmN1cnJlbnRZID0gYS5pbWFnZS5tYXhZIC0gMSArIE1hdGgucG93KGEuaW1hZ2UuY3VycmVudFkgLSBhLmltYWdlLm1heFkgKyAxLCAuOCkpLCBhLnZlbG9jaXR5LnByZXZQb3NpdGlvblggfHwgKGEudmVsb2NpdHkucHJldlBvc2l0aW9uWCA9IGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueCksIGEudmVsb2NpdHkucHJldlBvc2l0aW9uWSB8fCAoYS52ZWxvY2l0eS5wcmV2UG9zaXRpb25ZID0gYS5pbWFnZS50b3VjaGVzQ3VycmVudC55KSwgYS52ZWxvY2l0eS5wcmV2VGltZSB8fCAoYS52ZWxvY2l0eS5wcmV2VGltZSA9IERhdGUubm93KCkpLCBhLnZlbG9jaXR5LnggPSAoYS5pbWFnZS50b3VjaGVzQ3VycmVudC54IC0gYS52ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSAvIChEYXRlLm5vdygpIC0gYS52ZWxvY2l0eS5wcmV2VGltZSkgLyAyLCBhLnZlbG9jaXR5LnkgPSAoYS5pbWFnZS50b3VjaGVzQ3VycmVudC55IC0gYS52ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSAvIChEYXRlLm5vdygpIC0gYS52ZWxvY2l0eS5wcmV2VGltZSkgLyAyLCBNYXRoLmFicyhhLmltYWdlLnRvdWNoZXNDdXJyZW50LnggLSBhLnZlbG9jaXR5LnByZXZQb3NpdGlvblgpIDwgMiAmJiAoYS52ZWxvY2l0eS54ID0gMCksIE1hdGguYWJzKGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueSAtIGEudmVsb2NpdHkucHJldlBvc2l0aW9uWSkgPCAyICYmIChhLnZlbG9jaXR5LnkgPSAwKSwgYS52ZWxvY2l0eS5wcmV2UG9zaXRpb25YID0gYS5pbWFnZS50b3VjaGVzQ3VycmVudC54LCBhLnZlbG9jaXR5LnByZXZQb3NpdGlvblkgPSBhLmltYWdlLnRvdWNoZXNDdXJyZW50LnksIGEudmVsb2NpdHkucHJldlRpbWUgPSBEYXRlLm5vdygpLCBhLmdlc3R1cmUuaW1hZ2VXcmFwLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiICsgYS5pbWFnZS5jdXJyZW50WCArIFwicHgsIFwiICsgYS5pbWFnZS5jdXJyZW50WSArIFwicHgsMClcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblRvdWNoRW5kOiBmdW5jdGlvbihlLCBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuZ2VzdHVyZS5pbWFnZSAmJiAwICE9PSB0Lmdlc3R1cmUuaW1hZ2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdC5pbWFnZS5pc1RvdWNoZWQgfHwgIXQuaW1hZ2UuaXNNb3ZlZCkgcmV0dXJuIHQuaW1hZ2UuaXNUb3VjaGVkID0gITEsIHZvaWQodC5pbWFnZS5pc01vdmVkID0gITEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmltYWdlLmlzVG91Y2hlZCA9ICExLCB0LmltYWdlLmlzTW92ZWQgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAzMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gMzAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHQudmVsb2NpdHkueCAqIHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gdC5pbWFnZS5jdXJyZW50WCArIGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gdC52ZWxvY2l0eS55ICogcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB0LmltYWdlLmN1cnJlbnRZICsgbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgMCAhPT0gdC52ZWxvY2l0eS54ICYmIChzID0gTWF0aC5hYnMoKG4gLSB0LmltYWdlLmN1cnJlbnRYKSAvIHQudmVsb2NpdHkueCkpLCAwICE9PSB0LnZlbG9jaXR5LnkgJiYgKHIgPSBNYXRoLmFicygobCAtIHQuaW1hZ2UuY3VycmVudFkpIC8gdC52ZWxvY2l0eS55KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTWF0aC5tYXgocywgcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuaW1hZ2UuY3VycmVudFggPSBuLCB0LmltYWdlLmN1cnJlbnRZID0gbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB0LmltYWdlLndpZHRoICogdC5zY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB0LmltYWdlLmhlaWdodCAqIHQuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuaW1hZ2UubWluWCA9IE1hdGgubWluKHQuZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMiAtIGQgLyAyLCAwKSwgdC5pbWFnZS5tYXhYID0gLXQuaW1hZ2UubWluWCwgdC5pbWFnZS5taW5ZID0gTWF0aC5taW4odC5nZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMiAtIG0gLyAyLCAwKSwgdC5pbWFnZS5tYXhZID0gLXQuaW1hZ2UubWluWSwgdC5pbWFnZS5jdXJyZW50WCA9IE1hdGgubWF4KE1hdGgubWluKHQuaW1hZ2UuY3VycmVudFgsIHQuaW1hZ2UubWF4WCksIHQuaW1hZ2UubWluWCksIHQuaW1hZ2UuY3VycmVudFkgPSBNYXRoLm1heChNYXRoLm1pbih0LmltYWdlLmN1cnJlbnRZLCB0LmltYWdlLm1heFkpLCB0LmltYWdlLm1pblkpLCB0Lmdlc3R1cmUuaW1hZ2VXcmFwLnRyYW5zaXRpb24ocCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIgKyB0LmltYWdlLmN1cnJlbnRYICsgXCJweCwgXCIgKyB0LmltYWdlLmN1cnJlbnRZICsgXCJweCwwKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUuem9vbTtcclxuICAgICAgICAgICAgICAgICAgICBhLmdlc3R1cmUuc2xpZGUgJiYgZS5wcmV2aW91c0luZGV4ICE9PSBlLmFjdGl2ZUluZGV4ICYmIChhLmdlc3R1cmUuaW1hZ2UudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKDEpXCIpLCBhLmdlc3R1cmUuaW1hZ2VXcmFwLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKVwiKSwgYS5nZXN0dXJlLnNsaWRlID0gYS5nZXN0dXJlLmltYWdlID0gYS5nZXN0dXJlLmltYWdlV3JhcCA9IHZvaWQgMCwgYS5zY2FsZSA9IGEuY3VycmVudFNjYWxlID0gMSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b2dnbGVab29tOiBmdW5jdGlvbihhLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBhLnpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuZ2VzdHVyZS5zbGlkZSB8fCAocy5nZXN0dXJlLnNsaWRlID0gYS5jbGlja2VkU2xpZGUgPyBlKGEuY2xpY2tlZFNsaWRlKSA6IGEuc2xpZGVzLmVxKGEuYWN0aXZlSW5kZXgpLCBzLmdlc3R1cmUuaW1hZ2UgPSBzLmdlc3R1cmUuc2xpZGUuZmluZChcImltZywgc3ZnLCBjYW52YXNcIiksIHMuZ2VzdHVyZS5pbWFnZVdyYXAgPSBzLmdlc3R1cmUuaW1hZ2UucGFyZW50KFwiLlwiICsgYS5wYXJhbXMuem9vbUNvbnRhaW5lckNsYXNzKSksIHMuZ2VzdHVyZS5pbWFnZSAmJiAwICE9PSBzLmdlc3R1cmUuaW1hZ2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByLCBpLCBuLCBvLCBsLCBwLCBkLCBtLCB1LCBjLCBnLCBoLCB2LCBmLCB3LCB5LCB4LCBUO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHMuaW1hZ2UudG91Y2hlc1N0YXJ0LnggJiYgdCA/IChyID0gXCJ0b3VjaGVuZFwiID09PSB0LnR5cGUgPyB0LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIDogdC5wYWdlWCwgaSA9IFwidG91Y2hlbmRcIiA9PT0gdC50eXBlID8gdC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSA6IHQucGFnZVkpIDogKHIgPSBzLmltYWdlLnRvdWNoZXNTdGFydC54LCBpID0gcy5pbWFnZS50b3VjaGVzU3RhcnQueSksIHMuc2NhbGUgJiYgMSAhPT0gcy5zY2FsZSA/IChzLnNjYWxlID0gcy5jdXJyZW50U2NhbGUgPSAxLCBzLmdlc3R1cmUuaW1hZ2VXcmFwLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMClcIiksIHMuZ2VzdHVyZS5pbWFnZS50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKDEpXCIpLCBzLmdlc3R1cmUuc2xpZGUgPSB2b2lkIDApIDogKHMuc2NhbGUgPSBzLmN1cnJlbnRTY2FsZSA9IHMuZ2VzdHVyZS5pbWFnZVdyYXAuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIikgfHwgYS5wYXJhbXMuem9vbU1heCwgdCA/ICh4ID0gcy5nZXN0dXJlLnNsaWRlWzBdLm9mZnNldFdpZHRoLCBUID0gcy5nZXN0dXJlLnNsaWRlWzBdLm9mZnNldEhlaWdodCwgbiA9IHMuZ2VzdHVyZS5zbGlkZS5vZmZzZXQoKS5sZWZ0LCBvID0gcy5nZXN0dXJlLnNsaWRlLm9mZnNldCgpLnRvcCwgbCA9IG4gKyB4IC8gMiAtIHIsIHAgPSBvICsgVCAvIDIgLSBpLCB1ID0gcy5nZXN0dXJlLmltYWdlWzBdLm9mZnNldFdpZHRoLCBjID0gcy5nZXN0dXJlLmltYWdlWzBdLm9mZnNldEhlaWdodCwgZyA9IHUgKiBzLnNjYWxlLCBoID0gYyAqIHMuc2NhbGUsIHYgPSBNYXRoLm1pbih4IC8gMiAtIGcgLyAyLCAwKSwgZiA9IE1hdGgubWluKFQgLyAyIC0gaCAvIDIsIDApLCB3ID0gLXYsIHkgPSAtZiwgZCA9IGwgKiBzLnNjYWxlLCBtID0gcCAqIHMuc2NhbGUsIGQgPCB2ICYmIChkID0gdiksIGQgPiB3ICYmIChkID0gdyksIG0gPCBmICYmIChtID0gZiksIG0gPiB5ICYmIChtID0geSkpIDogKGQgPSAwLCBtID0gMCksIHMuZ2VzdHVyZS5pbWFnZVdyYXAudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiICsgZCArIFwicHgsIFwiICsgbSArIFwicHgsMClcIiksIHMuZ2VzdHVyZS5pbWFnZS50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKFwiICsgcy5zY2FsZSArIFwiKVwiKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnRzOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBhID8gXCJvZmZcIiA6IFwib25cIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMuem9vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9ICh4LnNsaWRlcywgIShcInRvdWNoc3RhcnRcIiAhPT0geC50b3VjaEV2ZW50cy5zdGFydCB8fCAheC5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciB8fCAheC5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycykgJiYgeyBwYXNzaXZlOiAhMCwgY2FwdHVyZTogITEgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHguc3VwcG9ydC5nZXN0dXJlcyA/ICh4LnNsaWRlc1t0XShcImdlc3R1cmVzdGFydFwiLCB4Lnpvb20ub25HZXN0dXJlU3RhcnQsIHMpLCB4LnNsaWRlc1t0XShcImdlc3R1cmVjaGFuZ2VcIiwgeC56b29tLm9uR2VzdHVyZUNoYW5nZSwgcyksIHguc2xpZGVzW3RdKFwiZ2VzdHVyZWVuZFwiLCB4Lnpvb20ub25HZXN0dXJlRW5kLCBzKSkgOiBcInRvdWNoc3RhcnRcIiA9PT0geC50b3VjaEV2ZW50cy5zdGFydCAmJiAoeC5zbGlkZXNbdF0oeC50b3VjaEV2ZW50cy5zdGFydCwgeC56b29tLm9uR2VzdHVyZVN0YXJ0LCBzKSwgeC5zbGlkZXNbdF0oeC50b3VjaEV2ZW50cy5tb3ZlLCB4Lnpvb20ub25HZXN0dXJlQ2hhbmdlLCBzKSwgeC5zbGlkZXNbdF0oeC50b3VjaEV2ZW50cy5lbmQsIHguem9vbS5vbkdlc3R1cmVFbmQsIHMpKSwgeFt0XShcInRvdWNoU3RhcnRcIiwgeC56b29tLm9uVG91Y2hTdGFydCksIHguc2xpZGVzLmVhY2goZnVuY3Rpb24oYSwgcykgeyBlKHMpLmZpbmQoXCIuXCIgKyB4LnBhcmFtcy56b29tQ29udGFpbmVyQ2xhc3MpLmxlbmd0aCA+IDAgJiYgZShzKVt0XSh4LnRvdWNoRXZlbnRzLm1vdmUsIHguem9vbS5vblRvdWNoTW92ZSkgfSksIHhbdF0oXCJ0b3VjaEVuZFwiLCB4Lnpvb20ub25Ub3VjaEVuZCksIHhbdF0oXCJ0cmFuc2l0aW9uRW5kXCIsIHguem9vbS5vblRyYW5zaXRpb25FbmQpLCB4LnBhcmFtcy56b29tVG9nZ2xlICYmIHgub24oXCJkb3VibGVUYXBcIiwgeC56b29tLnRvZ2dsZVpvb20pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkgeyB4Lnpvb20uYXR0YWNoRXZlbnRzKCkgfSxcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkgeyB4Lnpvb20uYXR0YWNoRXZlbnRzKCEwKSB9XHJcbiAgICAgICAgICAgIH0sIHguX3BsdWdpbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgWSBpbiB4LnBsdWdpbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBBID0geC5wbHVnaW5zW1ldKHgsIHgucGFyYW1zW1ldKTtcclxuICAgICAgICAgICAgICAgIEEgJiYgeC5fcGx1Z2lucy5wdXNoKEEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHguY2FsbFBsdWdpbnMgPSBmdW5jdGlvbihlKSB7IGZvciAodmFyIGEgPSAwOyBhIDwgeC5fcGx1Z2lucy5sZW5ndGg7IGErKykgZSBpbiB4Ll9wbHVnaW5zW2FdICYmIHguX3BsdWdpbnNbYV1bZV0oYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSwgYXJndW1lbnRzWzRdLCBhcmd1bWVudHNbNV0pIH0sIHguZW1pdHRlckV2ZW50TGlzdGVuZXJzID0ge30sIHguZW1pdCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zW2VdICYmIHgucGFyYW1zW2VdKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKTtcclxuICAgICAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCB4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXS5sZW5ndGg7IGErKykgeC5lbWl0dGVyRXZlbnRMaXN0ZW5lcnNbZV1bYV0oYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSwgYXJndW1lbnRzWzRdLCBhcmd1bWVudHNbNV0pO1xyXG4gICAgICAgICAgICAgICAgeC5jYWxsUGx1Z2lucyAmJiB4LmNhbGxQbHVnaW5zKGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKVxyXG4gICAgICAgICAgICB9LCB4Lm9uID0gZnVuY3Rpb24oZSwgYSkgeyByZXR1cm4gZSA9IHUoZSksIHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdIHx8ICh4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXSA9IFtdKSwgeC5lbWl0dGVyRXZlbnRMaXN0ZW5lcnNbZV0ucHVzaChhKSwgeCB9LCB4Lm9mZiA9IGZ1bmN0aW9uKGUsIGEpIHsgdmFyIHQ7IGlmIChlID0gdShlKSwgdm9pZCAwID09PSBhKSByZXR1cm4geC5lbWl0dGVyRXZlbnRMaXN0ZW5lcnNbZV0gPSBbXSwgeDsgaWYgKHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdICYmIDAgIT09IHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdLmxlbmd0aCkgeyBmb3IgKHQgPSAwOyB0IDwgeC5lbWl0dGVyRXZlbnRMaXN0ZW5lcnNbZV0ubGVuZ3RoOyB0KyspIHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdW3RdID09PSBhICYmIHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdLnNwbGljZSh0LCAxKTsgcmV0dXJuIHggfSB9LCB4Lm9uY2UgPSBmdW5jdGlvbihlLCBhKSB7IGUgPSB1KGUpOyB2YXIgdCA9IGZ1bmN0aW9uKCkgeyBhKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSwgYXJndW1lbnRzWzRdKSwgeC5vZmYoZSwgdCkgfTsgcmV0dXJuIHgub24oZSwgdCksIHggfSwgeC5hMTF5ID0ge1xyXG4gICAgICAgICAgICAgICAgbWFrZUZvY3VzYWJsZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5hdHRyKFwidGFiSW5kZXhcIiwgXCIwXCIpLCBlIH0sXHJcbiAgICAgICAgICAgICAgICBhZGRSb2xlOiBmdW5jdGlvbihlLCBhKSB7IHJldHVybiBlLmF0dHIoXCJyb2xlXCIsIGEpLCBlIH0sXHJcbiAgICAgICAgICAgICAgICBhZGRMYWJlbDogZnVuY3Rpb24oZSwgYSkgeyByZXR1cm4gZS5hdHRyKFwiYXJpYS1sYWJlbFwiLCBhKSwgZSB9LFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCAhMCksIGUgfSxcclxuICAgICAgICAgICAgICAgIGVuYWJsZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCAhMSksIGUgfSxcclxuICAgICAgICAgICAgICAgIG9uRW50ZXJLZXk6IGZ1bmN0aW9uKGEpIHsgMTMgPT09IGEua2V5Q29kZSAmJiAoZShhLnRhcmdldCkuaXMoeC5wYXJhbXMubmV4dEJ1dHRvbikgPyAoeC5vbkNsaWNrTmV4dChhKSwgeC5pc0VuZCA/IHguYTExeS5ub3RpZnkoeC5wYXJhbXMubGFzdFNsaWRlTWVzc2FnZSkgOiB4LmExMXkubm90aWZ5KHgucGFyYW1zLm5leHRTbGlkZU1lc3NhZ2UpKSA6IGUoYS50YXJnZXQpLmlzKHgucGFyYW1zLnByZXZCdXR0b24pICYmICh4Lm9uQ2xpY2tQcmV2KGEpLCB4LmlzQmVnaW5uaW5nID8geC5hMTF5Lm5vdGlmeSh4LnBhcmFtcy5maXJzdFNsaWRlTWVzc2FnZSkgOiB4LmExMXkubm90aWZ5KHgucGFyYW1zLnByZXZTbGlkZU1lc3NhZ2UpKSwgZShhLnRhcmdldCkuaXMoXCIuXCIgKyB4LnBhcmFtcy5idWxsZXRDbGFzcykgJiYgZShhLnRhcmdldClbMF0uY2xpY2soKSkgfSxcclxuICAgICAgICAgICAgICAgIGxpdmVSZWdpb246IGUoJzxzcGFuIGNsYXNzPVwiJyArIHgucGFyYW1zLm5vdGlmaWNhdGlvbkNsYXNzICsgJ1wiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiPjwvc3Bhbj4nKSxcclxuICAgICAgICAgICAgICAgIG5vdGlmeTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0geC5hMTF5LmxpdmVSZWdpb247XHJcbiAgICAgICAgICAgICAgICAgICAgMCAhPT0gYS5sZW5ndGggJiYgKGEuaHRtbChcIlwiKSwgYS5odG1sKGUpKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkgeyB4LnBhcmFtcy5uZXh0QnV0dG9uICYmIHgubmV4dEJ1dHRvbiAmJiB4Lm5leHRCdXR0b24ubGVuZ3RoID4gMCAmJiAoeC5hMTF5Lm1ha2VGb2N1c2FibGUoeC5uZXh0QnV0dG9uKSwgeC5hMTF5LmFkZFJvbGUoeC5uZXh0QnV0dG9uLCBcImJ1dHRvblwiKSwgeC5hMTF5LmFkZExhYmVsKHgubmV4dEJ1dHRvbiwgeC5wYXJhbXMubmV4dFNsaWRlTWVzc2FnZSkpLCB4LnBhcmFtcy5wcmV2QnV0dG9uICYmIHgucHJldkJ1dHRvbiAmJiB4LnByZXZCdXR0b24ubGVuZ3RoID4gMCAmJiAoeC5hMTF5Lm1ha2VGb2N1c2FibGUoeC5wcmV2QnV0dG9uKSwgeC5hMTF5LmFkZFJvbGUoeC5wcmV2QnV0dG9uLCBcImJ1dHRvblwiKSwgeC5hMTF5LmFkZExhYmVsKHgucHJldkJ1dHRvbiwgeC5wYXJhbXMucHJldlNsaWRlTWVzc2FnZSkpLCBlKHguY29udGFpbmVyKS5hcHBlbmQoeC5hMTF5LmxpdmVSZWdpb24pIH0sXHJcbiAgICAgICAgICAgICAgICBpbml0UGFnaW5hdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJhbXMucGFnaW5hdGlvbiAmJiB4LnBhcmFtcy5wYWdpbmF0aW9uQ2xpY2thYmxlICYmIHguYnVsbGV0cyAmJiB4LmJ1bGxldHMubGVuZ3RoICYmIHguYnVsbGV0cy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHguYTExeS5tYWtlRm9jdXNhYmxlKGEpLCB4LmExMXkuYWRkUm9sZShhLCBcImJ1dHRvblwiKSwgeC5hMTF5LmFkZExhYmVsKGEsIHgucGFyYW1zLnBhZ2luYXRpb25CdWxsZXRNZXNzYWdlLnJlcGxhY2UoL3t7aW5kZXh9fS8sIGEuaW5kZXgoKSArIDEpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7IHguYTExeS5saXZlUmVnaW9uICYmIHguYTExeS5saXZlUmVnaW9uLmxlbmd0aCA+IDAgJiYgeC5hMTF5LmxpdmVSZWdpb24ucmVtb3ZlKCkgfVxyXG4gICAgICAgICAgICB9LCB4LmluaXQgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMubG9vcCAmJiB4LmNyZWF0ZUxvb3AoKSwgeC51cGRhdGVDb250YWluZXJTaXplKCksIHgudXBkYXRlU2xpZGVzU2l6ZSgpLCB4LnVwZGF0ZVBhZ2luYXRpb24oKSwgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyICYmICh4LnNjcm9sbGJhci5zZXQoKSwgeC5wYXJhbXMuc2Nyb2xsYmFyRHJhZ2dhYmxlICYmIHguc2Nyb2xsYmFyLmVuYWJsZURyYWdnYWJsZSgpKSwgXCJzbGlkZVwiICE9PSB4LnBhcmFtcy5lZmZlY3QgJiYgeC5lZmZlY3RzW3gucGFyYW1zLmVmZmVjdF0gJiYgKHgucGFyYW1zLmxvb3AgfHwgeC51cGRhdGVQcm9ncmVzcygpLCB4LmVmZmVjdHNbeC5wYXJhbXMuZWZmZWN0XS5zZXRUcmFuc2xhdGUoKSksIHgucGFyYW1zLmxvb3AgPyB4LnNsaWRlVG8oeC5wYXJhbXMuaW5pdGlhbFNsaWRlICsgeC5sb29wZWRTbGlkZXMsIDAsIHgucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCkgOiAoeC5zbGlkZVRvKHgucGFyYW1zLmluaXRpYWxTbGlkZSwgMCwgeC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSwgMCA9PT0geC5wYXJhbXMuaW5pdGlhbFNsaWRlICYmICh4LnBhcmFsbGF4ICYmIHgucGFyYW1zLnBhcmFsbGF4ICYmIHgucGFyYWxsYXguc2V0VHJhbnNsYXRlKCksIHgubGF6eSAmJiB4LnBhcmFtcy5sYXp5TG9hZGluZyAmJiAoeC5sYXp5LmxvYWQoKSwgeC5sYXp5LmluaXRpYWxJbWFnZUxvYWRlZCA9ICEwKSkpLCB4LmF0dGFjaEV2ZW50cygpLCB4LnBhcmFtcy5vYnNlcnZlciAmJiB4LnN1cHBvcnQub2JzZXJ2ZXIgJiYgeC5pbml0T2JzZXJ2ZXJzKCksIHgucGFyYW1zLnByZWxvYWRJbWFnZXMgJiYgIXgucGFyYW1zLmxhenlMb2FkaW5nICYmIHgucHJlbG9hZEltYWdlcygpLCB4LnBhcmFtcy56b29tICYmIHguem9vbSAmJiB4Lnpvb20uaW5pdCgpLCB4LnBhcmFtcy5hdXRvcGxheSAmJiB4LnN0YXJ0QXV0b3BsYXkoKSwgeC5wYXJhbXMua2V5Ym9hcmRDb250cm9sICYmIHguZW5hYmxlS2V5Ym9hcmRDb250cm9sICYmIHguZW5hYmxlS2V5Ym9hcmRDb250cm9sKCksIHgucGFyYW1zLm1vdXNld2hlZWxDb250cm9sICYmIHguZW5hYmxlTW91c2V3aGVlbENvbnRyb2wgJiYgeC5lbmFibGVNb3VzZXdoZWVsQ29udHJvbCgpLCB4LnBhcmFtcy5oYXNobmF2UmVwbGFjZVN0YXRlICYmICh4LnBhcmFtcy5yZXBsYWNlU3RhdGUgPSB4LnBhcmFtcy5oYXNobmF2UmVwbGFjZVN0YXRlKSwgeC5wYXJhbXMuaGlzdG9yeSAmJiB4Lmhpc3RvcnkgJiYgeC5oaXN0b3J5LmluaXQoKSwgeC5wYXJhbXMuaGFzaG5hdiAmJiB4Lmhhc2huYXYgJiYgeC5oYXNobmF2LmluaXQoKSwgeC5wYXJhbXMuYTExeSAmJiB4LmExMXkgJiYgeC5hMTF5LmluaXQoKSwgeC5lbWl0KFwib25Jbml0XCIsIHgpIH0sIHguY2xlYW51cFN0eWxlcyA9IGZ1bmN0aW9uKCkgeyB4LmNvbnRhaW5lci5yZW1vdmVDbGFzcyh4LmNsYXNzTmFtZXMuam9pbihcIiBcIikpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKSwgeC53cmFwcGVyLnJlbW92ZUF0dHIoXCJzdHlsZVwiKSwgeC5zbGlkZXMgJiYgeC5zbGlkZXMubGVuZ3RoICYmIHguc2xpZGVzLnJlbW92ZUNsYXNzKFt4LnBhcmFtcy5zbGlkZVZpc2libGVDbGFzcywgeC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzcywgeC5wYXJhbXMuc2xpZGVOZXh0Q2xhc3MsIHgucGFyYW1zLnNsaWRlUHJldkNsYXNzXS5qb2luKFwiIFwiKSkucmVtb3ZlQXR0cihcInN0eWxlXCIpLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1jb2x1bW5cIikucmVtb3ZlQXR0cihcImRhdGEtc3dpcGVyLXJvd1wiKSwgeC5wYWdpbmF0aW9uQ29udGFpbmVyICYmIHgucGFnaW5hdGlvbkNvbnRhaW5lci5sZW5ndGggJiYgeC5wYWdpbmF0aW9uQ29udGFpbmVyLnJlbW92ZUNsYXNzKHgucGFyYW1zLnBhZ2luYXRpb25IaWRkZW5DbGFzcyksIHguYnVsbGV0cyAmJiB4LmJ1bGxldHMubGVuZ3RoICYmIHguYnVsbGV0cy5yZW1vdmVDbGFzcyh4LnBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyksIHgucGFyYW1zLnByZXZCdXR0b24gJiYgZSh4LnBhcmFtcy5wcmV2QnV0dG9uKS5yZW1vdmVDbGFzcyh4LnBhcmFtcy5idXR0b25EaXNhYmxlZENsYXNzKSwgeC5wYXJhbXMubmV4dEJ1dHRvbiAmJiBlKHgucGFyYW1zLm5leHRCdXR0b24pLnJlbW92ZUNsYXNzKHgucGFyYW1zLmJ1dHRvbkRpc2FibGVkQ2xhc3MpLCB4LnBhcmFtcy5zY3JvbGxiYXIgJiYgeC5zY3JvbGxiYXIgJiYgKHguc2Nyb2xsYmFyLnRyYWNrICYmIHguc2Nyb2xsYmFyLnRyYWNrLmxlbmd0aCAmJiB4LnNjcm9sbGJhci50cmFjay5yZW1vdmVBdHRyKFwic3R5bGVcIiksIHguc2Nyb2xsYmFyLmRyYWcgJiYgeC5zY3JvbGxiYXIuZHJhZy5sZW5ndGggJiYgeC5zY3JvbGxiYXIuZHJhZy5yZW1vdmVBdHRyKFwic3R5bGVcIikpIH0sIHguZGVzdHJveSA9IGZ1bmN0aW9uKGUsIGEpIHsgeC5kZXRhY2hFdmVudHMoKSwgeC5zdG9wQXV0b3BsYXkoKSwgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyICYmIHgucGFyYW1zLnNjcm9sbGJhckRyYWdnYWJsZSAmJiB4LnNjcm9sbGJhci5kaXNhYmxlRHJhZ2dhYmxlKCksIHgucGFyYW1zLmxvb3AgJiYgeC5kZXN0cm95TG9vcCgpLCBhICYmIHguY2xlYW51cFN0eWxlcygpLCB4LmRpc2Nvbm5lY3RPYnNlcnZlcnMoKSwgeC5wYXJhbXMuem9vbSAmJiB4Lnpvb20gJiYgeC56b29tLmRlc3Ryb3koKSwgeC5wYXJhbXMua2V5Ym9hcmRDb250cm9sICYmIHguZGlzYWJsZUtleWJvYXJkQ29udHJvbCAmJiB4LmRpc2FibGVLZXlib2FyZENvbnRyb2woKSwgeC5wYXJhbXMubW91c2V3aGVlbENvbnRyb2wgJiYgeC5kaXNhYmxlTW91c2V3aGVlbENvbnRyb2wgJiYgeC5kaXNhYmxlTW91c2V3aGVlbENvbnRyb2woKSwgeC5wYXJhbXMuYTExeSAmJiB4LmExMXkgJiYgeC5hMTF5LmRlc3Ryb3koKSwgeC5wYXJhbXMuaGlzdG9yeSAmJiAheC5wYXJhbXMucmVwbGFjZVN0YXRlICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgeC5oaXN0b3J5LnNldEhpc3RvcnlQb3BTdGF0ZSksIHgucGFyYW1zLmhhc2huYXYgJiYgeC5oYXNobmF2ICYmIHguaGFzaG5hdi5kZXN0cm95KCksIHguZW1pdChcIm9uRGVzdHJveVwiKSwgZSAhPT0gITEgJiYgKHggPSBudWxsKSB9LCB4LmluaXQoKSwgeFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBhLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBpc1NhZmFyaTogZnVuY3Rpb24oKSB7IHZhciBlID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTsgcmV0dXJuIGUuaW5kZXhPZihcInNhZmFyaVwiKSA+PSAwICYmIGUuaW5kZXhPZihcImNocm9tZVwiKSA8IDAgJiYgZS5pbmRleE9mKFwiYW5kcm9pZFwiKSA8IDAgfSgpLFxyXG4gICAgICAgIGlzVWlXZWJWaWV3OiAvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLFxyXG4gICAgICAgIGlzQXJyYXk6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIFwiW29iamVjdCBBcnJheV1cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShlKSB9LFxyXG4gICAgICAgIGJyb3dzZXI6IHsgaWU6IHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkLCBpZVRvdWNoOiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgJiYgd2luZG93Lm5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMSB8fCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxLCBsdGVJRTk6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IHJldHVybiBlLmlubmVySFRNTCA9IFwiPCEtLVtpZiBsdGUgSUUgOV0+PGk+PC9pPjwhW2VuZGlmXS0tPlwiLCAxID09PSBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaVwiKS5sZW5ndGggfSgpIH0sXHJcbiAgICAgICAgZGV2aWNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCxcclxuICAgICAgICAgICAgICAgIGEgPSBlLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKSxcclxuICAgICAgICAgICAgICAgIHQgPSBlLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyksXHJcbiAgICAgICAgICAgICAgICBzID0gZS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pLFxyXG4gICAgICAgICAgICAgICAgciA9ICF0ICYmIGUubWF0Y2goLyhpUGhvbmVcXHNPU3xpT1MpXFxzKFtcXGRfXSspLyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGlvczogdCB8fCByIHx8IHMsIGFuZHJvaWQ6IGEgfVxyXG4gICAgICAgIH0oKSxcclxuICAgICAgICBzdXBwb3J0OiB7XHJcbiAgICAgICAgICAgIHRvdWNoOiB3aW5kb3cuTW9kZXJuaXpyICYmIE1vZGVybml6ci50b3VjaCA9PT0gITAgfHwgZnVuY3Rpb24oKSB7IHJldHVybiAhIShcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2gpIH0oKSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtczNkOiB3aW5kb3cuTW9kZXJuaXpyICYmIE1vZGVybml6ci5jc3N0cmFuc2Zvcm1zM2QgPT09ICEwIHx8IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7IHJldHVybiBcIndlYmtpdFBlcnNwZWN0aXZlXCIgaW4gZSB8fCBcIk1velBlcnNwZWN0aXZlXCIgaW4gZSB8fCBcIk9QZXJzcGVjdGl2ZVwiIGluIGUgfHwgXCJNc1BlcnNwZWN0aXZlXCIgaW4gZSB8fCBcInBlcnNwZWN0aXZlXCIgaW4gZSB9KCksXHJcbiAgICAgICAgICAgIGZsZXhib3g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsIGEgPSBcImFsaWduSXRlbXMgd2Via2l0QWxpZ25JdGVtcyB3ZWJraXRCb3hBbGlnbiBtc0ZsZXhBbGlnbiBtb3pCb3hBbGlnbiB3ZWJraXRGbGV4RGlyZWN0aW9uIG1zRmxleERpcmVjdGlvbiBtb3pCb3hEaXJlY3Rpb24gbW96Qm94T3JpZW50IHdlYmtpdEJveERpcmVjdGlvbiB3ZWJraXRCb3hPcmllbnRcIi5zcGxpdChcIiBcIiksIHQgPSAwOyB0IDwgYS5sZW5ndGg7IHQrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVt0XSBpbiBlKSByZXR1cm4gITBcclxuICAgICAgICAgICAgfSgpLFxyXG4gICAgICAgICAgICBvYnNlcnZlcjogZnVuY3Rpb24oKSB7IHJldHVybiBcIk11dGF0aW9uT2JzZXJ2ZXJcIiBpbiB3aW5kb3cgfHwgXCJXZWJraXRNdXRhdGlvbk9ic2VydmVyXCIgaW4gd2luZG93IH0oKSxcclxuICAgICAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gITE7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyBlID0gITAgfSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RQYXNzaXZlTGlzdGVuZXJcIiwgbnVsbCwgYSlcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICB9KCksXHJcbiAgICAgICAgICAgIGdlc3R1cmVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwib25nZXN0dXJlc3RhcnRcIiBpbiB3aW5kb3cgfSgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbHVnaW5zOiB7fVxyXG4gICAgfTtcclxuICAgIGZvciAodmFyIHQgPSBbXCJqUXVlcnlcIiwgXCJaZXB0b1wiLCBcIkRvbTdcIl0sIHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMrKykgd2luZG93W3Rbc11dICYmIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBlLmZuLnN3aXBlciA9IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgdmFyIHM7XHJcbiAgICAgICAgICAgIHJldHVybiBlKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IG5ldyBhKHRoaXMsIHQpO1xyXG4gICAgICAgICAgICAgICAgcyB8fCAocyA9IGUpXHJcbiAgICAgICAgICAgIH0pLCBzXHJcbiAgICAgICAgfVxyXG4gICAgfSh3aW5kb3dbdFtzXV0pO1xyXG4gICAgdmFyIHI7XHJcbiAgICByID0gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgRG9tNyA/IHdpbmRvdy5Eb203IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5IDogRG9tNywgciAmJiAoXCJ0cmFuc2l0aW9uRW5kXCIgaW4gci5mbiB8fCAoci5mbi50cmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGEoaSkge1xyXG4gICAgICAgICAgICBpZiAoaS50YXJnZXQgPT09IHRoaXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGUuY2FsbCh0aGlzLCBpKSwgdCA9IDA7IHQgPCBzLmxlbmd0aDsgdCsrKSByLm9mZihzW3RdLCBhKVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdCwgcyA9IFtcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uZW5kXCIsIFwib1RyYW5zaXRpb25FbmRcIiwgXCJNU1RyYW5zaXRpb25FbmRcIiwgXCJtc1RyYW5zaXRpb25FbmRcIl0sXHJcbiAgICAgICAgICAgIHIgPSB0aGlzO1xyXG4gICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICBmb3IgKHQgPSAwOyB0IDwgcy5sZW5ndGg7IHQrKykgci5vbihzW3RdLCBhKTtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfSksIFwidHJhbnNmb3JtXCIgaW4gci5mbiB8fCAoci5mbi50cmFuc2Zvcm0gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gdGhpc1thXS5zdHlsZTtcclxuICAgICAgICAgICAgdC53ZWJraXRUcmFuc2Zvcm0gPSB0Lk1zVHJhbnNmb3JtID0gdC5tc1RyYW5zZm9ybSA9IHQuTW96VHJhbnNmb3JtID0gdC5PVHJhbnNmb3JtID0gdC50cmFuc2Zvcm0gPSBlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9KSwgXCJ0cmFuc2l0aW9uXCIgaW4gci5mbiB8fCAoci5mbi50cmFuc2l0aW9uID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKGUgKz0gXCJtc1wiKTtcclxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzW2FdLnN0eWxlO1xyXG4gICAgICAgICAgICB0LndlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9IHQuTXNUcmFuc2l0aW9uRHVyYXRpb24gPSB0Lm1zVHJhbnNpdGlvbkR1cmF0aW9uID0gdC5Nb3pUcmFuc2l0aW9uRHVyYXRpb24gPSB0Lk9UcmFuc2l0aW9uRHVyYXRpb24gPSB0LnRyYW5zaXRpb25EdXJhdGlvbiA9IGVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0pLCBcIm91dGVyV2lkdGhcIiBpbiByLmZuIHx8IChyLmZuLm91dGVyV2lkdGggPSBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLmxlbmd0aCA+IDAgPyBlID8gdGhpc1swXS5vZmZzZXRXaWR0aCArIHBhcnNlRmxvYXQodGhpcy5jc3MoXCJtYXJnaW4tcmlnaHRcIikpICsgcGFyc2VGbG9hdCh0aGlzLmNzcyhcIm1hcmdpbi1sZWZ0XCIpKSA6IHRoaXNbMF0ub2Zmc2V0V2lkdGggOiBudWxsIH0pKSwgd2luZG93LlN3aXBlciA9IGFcclxufSgpLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBtb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5Td2lwZXIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kICYmIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IFwidXNlIHN0cmljdFwiOyByZXR1cm4gd2luZG93LlN3aXBlciB9KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwcy9zd2lwZXIuanF1ZXJ5Lm1pbi5qcy5tYXAiXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
