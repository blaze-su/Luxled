;
$(document).ready(function() {
    // $('.mainContent').css('min-height', ($(window).outerHeight() - $(".footer").outerHeight()) - $(".header").outerHeight());
    catalogFilters();
    headerMenuItemHover();
    catalogCheckBox();
    catalogAccordion();
    catalogSorting();
    productPhotoGalery();
    productMoreTableColumnColor();
    productMoreTab();
    orderForm();
    footerMenu();
    $('img').on('mousedown', function(e) { e.preventDefault(); });
    hScroll($('.header__catalogItem'), $('.header__catalog'));
    hScroll($('.portfolio__item'), $('.portfolio__itemBox'));

    mediaCenter(5, $('.whyWe__belief'), $('.whyWe__beliefs'), $('.totalWidth'));
    mediaCenter(3, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection'));
    mediaCenter(4, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection--full'));
    if ($(window).outerWidth() <= 1023) {
        mediaCenter(8, $('.footer__paymentLink'), $('.footer__paymentLinks'));
    }
    var mySwiper = new Swiper('.swiper2', {
        pagination: '.swiper-pagination',
        paginationClickable: true,
        paginationElement: 'li'
    });
    // catalogFilterBox();
});

$(window).resize(function() {
    slider();
    mediaCenter(5, $('.whyWe__belief'), $('.whyWe__beliefs'), $('.totalWidth'));
    mediaCenter(3, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection'));
    mediaCenter(4, $('.catalog__item'), $('.catalog__items'), $('.catalog__mainSection--full'));
    if ($(window).outerWidth() <= 1023) {
        mediaCenter(8, $('.footer__paymentLink'), $('.footer__paymentLinks'));
    }
});

// var catalogFilterBox = function() {
//     $('.catalog__optionsItem').on('click', function() {
//         var top = $(this).offset().top - $('.catalog__optionItems').offset().top;
//         $('.catalog__optionFindProductBox').addClass('catalog__optionFindProductBox--active').css('top', top);
//     });
// };

var mediaCenter = function(count, elem, box, boxControlSize) {
    var size;
    for (var i = 1; i <= (count + 1); i++) {
        if (boxControlSize) {
            size = boxControlSize.width();
        } else {
            size = box.width();
        }
        if (size < elem.outerWidth(true) * i) {
            if (i == 1) {
                box.css('max-width', elem.outerWidth(true) * i);
            } else {
                box.css('max-width', elem.outerWidth(true) * (i - 1));
            }
            break
        }
    }
};

var hScroll = function(el, elB) {
    el.on('mousedown', function(e) {
        e.preventDefault();
        var x = e.pageX - $(this).offset().left;
        $(this).on('mousemove', function(e) {
            $(this).on('click', function(e) {
                e.preventDefault();
            });
            var xx = e.pageX - $(this).offset().left;
            if (xx < x) {
                var curTr = elB.scrollLeft() + (x - xx);
                elB.scrollLeft(curTr);
            }
            if (xx > x) {
                var curTr = elB.scrollLeft() - (xx - x);
                elB.scrollLeft(curTr);
            }
        });
        elB.on('mouseup', function() {
            el.unbind('mousemove');
            setTimeout(function() {
                el.unbind('click');
            }, 1);
        });
        elB.on('mouseleave', function() {
            el.unbind('mousemove');
        });
    });
};

var productPhotoGalery = function() {
    var firstSrc = $('.productMore__galeryPictureOther').eq(0).attr('src');
    $('.productMore__galeryPictureMain').attr('src', firstSrc);
    $('.productMore__galeryPictureOtherCase').eq(0).addClass('productMore__galeryPictureOtherCase--active');
    $('.productMore__galeryPictureOther').on('click', function() {

        var needSrc = $(this).attr('src');
        $('.productMore__galeryPictureMain').attr('src', needSrc);

        $('.productMore__galeryPictureOtherCase--active').removeClass('productMore__galeryPictureOtherCase--active');

        $(this).closest('.productMore__galeryPictureOtherCase').addClass('productMore__galeryPictureOtherCase--active');

    });
};

var productMoreTableColumnColor = function() {
    var rows = $('.productMore__infoCharacteristicsTableRow');
    var firstColor = '#f4f4f4';
    var secondColor = '#ffffff';
    for (var i = 0; i < rows.length; i++) {
        if (i % 2 == 0) {
            rows.eq(i).css('background-color', firstColor);
        } else {
            rows.eq(i).css('background-color', secondColor);
        }
    }
};

var productMoreTab = function() {
    var tabs = $('.productMore__infoTab');
    var links = $('.productMore__infoMenuLink');

    links.on('click', function(e) {
        e.preventDefault();
        $('.productMore__infoMenuLink--active').removeClass('productMore__infoMenuLink--active')
        $(this).addClass('productMore__infoMenuLink--active');
        var path = $(this).attr('href');
        tabs.each(function(index) {
            if (tabs.eq(index).attr('id') === path) {
                tabs.css('display', 'none');
                $(this).css('display', 'block');
            }
        });
    });

    tabs.eq(0).css('display', 'block');
    var tabId0 = tabs.eq(0).attr('id');

    $('.productMore__infoMenuLink').each(function(index) {
        if (links.eq(index).attr('href') === tabId0) {
            $(this).addClass('productMore__infoMenuLink--active');
        }
    });
};

var catalogCheckBox = function() {
    $('.catalog__optionsItem').on('click', function() {
        if ($(this).find('input').prop('checked') == true) {
            $(this).addClass('catalog__optionsItem--checked');
        } else {
            $(this).removeClass('catalog__optionsItem--checked');
        }
    });
};

var catalogAccordion = function() {
    $('.catalog__option').on('click', function() {
        $(this).find('.accordionIcon').toggleClass('accordionIcon--active');
        $(this).find('.catalog__optionsItemList').toggleClass('catalog__optionsItemList--active');
    });
};

var catalogSorting = function() {
    $('.catalog__sortingTitleBox').on('click', function() {
        $(this).find('.accordionIcon').toggleClass('accordionIcon--active');
        $(this).next().toggleClass('catalog__sortingList--active');
    });
};

var orderForm = function() {
    var phone = $('.orders__form').find('input[name="phone"]');
    phone.mask("+7(999) 999-99-99");

    var form = $('.orders__form');
    var titleError = $('.orders__formErrorTitle');
    var visionTitleError = titleError.css('display');

    if (visionTitleError === 'block') {
        form.css('margin-top', '55px');
    }

    var inputRequire = $('.orders__formItem--require > input');

};

var headerMenuItemHover = function() {
    // $('body').on('click', function() {
    //     if ($('.header__menuList').hasClass('header__menuList--full')) {
    //         $('.header__menuList').removeClass('header__menuList--full');
    //     }
    // });
    $('.header__catalogBtn').on('click', function() {
        if ($('.header__catalogBtnText').css('display') === 'none') {
            $('.header__menuList').toggleClass('header__menuList--full');
        } else {
            $('.header__menuList').toggleClass('header__menuList--active');
        }
    });
    $('.header__menuItem').on('mouseover', function() {
        if ($('.header__menuList').hasClass('header__menuList--active')) {
            $(this).find('.header__menuItemAfter').css('display', 'block');
            var index = $(this).index();
            var top;
            if (index != 0) {
                top = (-50 * index) + 49;
            } else {
                top = -1;
            }
            $(this).find('.header__subMenu').css({
                'display': 'flex',
                'top': top
            });
        }
    });
    $('.header__menuItem').on('mouseout', function() {
        $(this).find('.header__menuItemAfter').css('display', 'none');
        $(this).find('.header__subMenu').css('display', 'none');
    });
};

var catalogFilters = function() {
    $('.filtersBtn').on('click', function() {
        $('.catalog__options').toggleClass('catalog__options--active');
    });
};

var footerMenu = function() {
    $('.footer__menuTitle').on('click', function() {
        var i = $('.footer__menu--active').index();
        var j = $(this).closest('.footer__menu').index();
        if (j === i) {
            $(this).closest('.footer__menu').toggleClass('footer__menu--active');
        } else {
            $('.footer__menu--active').removeClass('footer__menu--active');
            $(this).closest('.footer__menu').toggleClass('footer__menu--active');
        }

    });
};

/**
 * Swiper 3.4.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * 
 * http://www.idangero.us/swiper/
 * 
 * Copyright 2017, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: March 10, 2017
 */
! function() {
    "use strict";
    var e, a = function(t, s) {
        function r(e) { return Math.floor(e) }

        function i() {
            var e = x.params.autoplay,
                a = x.slides.eq(x.activeIndex);
            a.attr("data-swiper-autoplay") && (e = a.attr("data-swiper-autoplay") || x.params.autoplay), x.autoplayTimeoutId = setTimeout(function() { x.params.loop ? (x.fixLoop(), x._slideNext(), x.emit("onAutoplay", x)) : x.isEnd ? s.autoplayStopOnLast ? x.stopAutoplay() : (x._slideTo(0), x.emit("onAutoplay", x)) : (x._slideNext(), x.emit("onAutoplay", x)) }, e)
        }

        function n(a, t) {
            var s = e(a.target);
            if (!s.is(t))
                if ("string" == typeof t) s = s.parents(t);
                else if (t.nodeType) { var r; return s.parents().each(function(e, a) { a === t && (r = t) }), r ? t : void 0 }
            if (0 !== s.length) return s[0]
        }

        function o(e, a) {
            a = a || {};
            var t = window.MutationObserver || window.WebkitMutationObserver,
                s = new t(function(e) { e.forEach(function(e) { x.onResize(!0), x.emit("onObserverUpdate", x, e) }) });
            s.observe(e, { attributes: void 0 === a.attributes || a.attributes, childList: void 0 === a.childList || a.childList, characterData: void 0 === a.characterData || a.characterData }), x.observers.push(s)
        }

        function l(e) {
            e.originalEvent && (e = e.originalEvent);
            var a = e.keyCode || e.charCode;
            if (!x.params.allowSwipeToNext && (x.isHorizontal() && 39 === a || !x.isHorizontal() && 40 === a)) return !1;
            if (!x.params.allowSwipeToPrev && (x.isHorizontal() && 37 === a || !x.isHorizontal() && 38 === a)) return !1;
            if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || document.activeElement && document.activeElement.nodeName && ("input" === document.activeElement.nodeName.toLowerCase() || "textarea" === document.activeElement.nodeName.toLowerCase()))) {
                if (37 === a || 39 === a || 38 === a || 40 === a) {
                    var t = !1;
                    if (x.container.parents("." + x.params.slideClass).length > 0 && 0 === x.container.parents("." + x.params.slideActiveClass).length) return;
                    var s = { left: window.pageXOffset, top: window.pageYOffset },
                        r = window.innerWidth,
                        i = window.innerHeight,
                        n = x.container.offset();
                    x.rtl && (n.left = n.left - x.container[0].scrollLeft);
                    for (var o = [
                            [n.left, n.top],
                            [n.left + x.width, n.top],
                            [n.left, n.top + x.height],
                            [n.left + x.width, n.top + x.height]
                        ], l = 0; l < o.length; l++) {
                        var p = o[l];
                        p[0] >= s.left && p[0] <= s.left + r && p[1] >= s.top && p[1] <= s.top + i && (t = !0)
                    }
                    if (!t) return
                }
                x.isHorizontal() ? (37 !== a && 39 !== a || (e.preventDefault ? e.preventDefault() : e.returnValue = !1), (39 === a && !x.rtl || 37 === a && x.rtl) && x.slideNext(), (37 === a && !x.rtl || 39 === a && x.rtl) && x.slidePrev()) : (38 !== a && 40 !== a || (e.preventDefault ? e.preventDefault() : e.returnValue = !1), 40 === a && x.slideNext(), 38 === a && x.slidePrev()), x.emit("onKeyPress", x, a)
            }
        }

        function p(e) {
            var a = 0,
                t = 0,
                s = 0,
                r = 0;
            return "detail" in e && (t = e.detail), "wheelDelta" in e && (t = -e.wheelDelta / 120), "wheelDeltaY" in e && (t = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (a = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (a = t, t = 0), s = 10 * a, r = 10 * t, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (s = e.deltaX), (s || r) && e.deltaMode && (1 === e.deltaMode ? (s *= 40, r *= 40) : (s *= 800, r *= 800)), s && !a && (a = s < 1 ? -1 : 1), r && !t && (t = r < 1 ? -1 : 1), { spinX: a, spinY: t, pixelX: s, pixelY: r }
        }

        function d(e) {
            e.originalEvent && (e = e.originalEvent);
            var a = 0,
                t = x.rtl ? -1 : 1,
                s = p(e);
            if (x.params.mousewheelForceToAxis)
                if (x.isHorizontal()) {
                    if (!(Math.abs(s.pixelX) > Math.abs(s.pixelY))) return;
                    a = s.pixelX * t
                } else {
                    if (!(Math.abs(s.pixelY) > Math.abs(s.pixelX))) return;
                    a = s.pixelY
                }
            else a = Math.abs(s.pixelX) > Math.abs(s.pixelY) ? -s.pixelX * t : -s.pixelY;
            if (0 !== a) {
                if (x.params.mousewheelInvert && (a = -a), x.params.freeMode) {
                    var r = x.getWrapperTranslate() + a * x.params.mousewheelSensitivity,
                        i = x.isBeginning,
                        n = x.isEnd;
                    if (r >= x.minTranslate() && (r = x.minTranslate()), r <= x.maxTranslate() && (r = x.maxTranslate()), x.setWrapperTransition(0), x.setWrapperTranslate(r), x.updateProgress(), x.updateActiveIndex(), (!i && x.isBeginning || !n && x.isEnd) && x.updateClasses(), x.params.freeModeSticky ? (clearTimeout(x.mousewheel.timeout), x.mousewheel.timeout = setTimeout(function() { x.slideReset() }, 300)) : x.params.lazyLoading && x.lazy && x.lazy.load(), x.emit("onScroll", x, e), x.params.autoplay && x.params.autoplayDisableOnInteraction && x.stopAutoplay(), 0 === r || r === x.maxTranslate()) return
                } else {
                    if ((new window.Date).getTime() - x.mousewheel.lastScrollTime > 60)
                        if (a < 0)
                            if (x.isEnd && !x.params.loop || x.animating) { if (x.params.mousewheelReleaseOnEdges) return !0 } else x.slideNext(), x.emit("onScroll", x, e);
                    else if (x.isBeginning && !x.params.loop || x.animating) { if (x.params.mousewheelReleaseOnEdges) return !0 } else x.slidePrev(), x.emit("onScroll", x, e);
                    x.mousewheel.lastScrollTime = (new window.Date).getTime()
                }
                return e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1
            }
        }

        function m(a, t) {
            a = e(a);
            var s, r, i, n = x.rtl ? -1 : 1;
            s = a.attr("data-swiper-parallax") || "0", r = a.attr("data-swiper-parallax-x"), i = a.attr("data-swiper-parallax-y"), r || i ? (r = r || "0", i = i || "0") : x.isHorizontal() ? (r = s, i = "0") : (i = s, r = "0"), r = r.indexOf("%") >= 0 ? parseInt(r, 10) * t * n + "%" : r * t * n + "px", i = i.indexOf("%") >= 0 ? parseInt(i, 10) * t + "%" : i * t + "px", a.transform("translate3d(" + r + ", " + i + ",0px)")
        }

        function u(e) { return 0 !== e.indexOf("on") && (e = e[0] !== e[0].toUpperCase() ? "on" + e[0].toUpperCase() + e.substring(1) : "on" + e), e }
        if (!(this instanceof a)) return new a(t, s);
        var c = { direction: "horizontal", touchEventsTarget: "container", initialSlide: 0, speed: 300, autoplay: !1, autoplayDisableOnInteraction: !0, autoplayStopOnLast: !1, iOSEdgeSwipeDetection: !1, iOSEdgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: .02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", coverflow: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0 }, flip: { slideShadows: !0, limitRotation: !0 }, cube: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 }, fade: { crossFade: !1 }, parallax: !1, zoom: !1, zoomMax: 3, zoomMin: 1, zoomToggle: !0, scrollbar: null, scrollbarHide: !0, scrollbarDraggable: !1, scrollbarSnapOnRelease: !1, keyboardControl: !1, mousewheelControl: !1, mousewheelReleaseOnEdges: !1, mousewheelInvert: !1, mousewheelForceToAxis: !1, mousewheelSensitivity: 1, mousewheelEventsTarged: "container", hashnav: !1, hashnavWatchState: !1, history: !1, replaceState: !1, breakpoints: void 0, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: "column", slidesPerGroup: 1, centeredSlides: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, onlyExternal: !1, threshold: 0, touchMoveStopPropagation: !0, touchReleaseOnEdges: !1, uniqueNavElements: !0, pagination: null, paginationElement: "span", paginationClickable: !1, paginationHide: !1, paginationBulletRender: null, paginationProgressRender: null, paginationFractionRender: null, paginationCustomRender: null, paginationType: "bullets", resistance: !0, resistanceRatio: .85, nextButton: null, prevButton: null, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, lazyLoading: !1, lazyLoadingInPrevNext: !1, lazyLoadingInPrevNextAmount: 1, lazyLoadingOnTransitionStart: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, control: void 0, controlInverse: !1, controlBy: "slide", normalizeSlideIndex: !0, allowSwipeToPrev: !0, allowSwipeToNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", passiveListeners: !0, containerModifierClass: "swiper-container-", slideClass: "swiper-slide", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", bulletClass: "swiper-pagination-bullet", bulletActiveClass: "swiper-pagination-bullet-active", buttonDisabledClass: "swiper-button-disabled", paginationCurrentClass: "swiper-pagination-current", paginationTotalClass: "swiper-pagination-total", paginationHiddenClass: "swiper-pagination-hidden", paginationProgressbarClass: "swiper-pagination-progressbar", paginationClickableClass: "swiper-pagination-clickable", paginationModifierClass: "swiper-pagination-", lazyLoadingClass: "swiper-lazy", lazyStatusLoadingClass: "swiper-lazy-loading", lazyStatusLoadedClass: "swiper-lazy-loaded", lazyPreloaderClass: "swiper-lazy-preloader", notificationClass: "swiper-notification", preloaderClass: "preloader", zoomContainerClass: "swiper-zoom-container", observer: !1, observeParents: !1, a11y: !1, prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", runCallbacksOnInit: !0 },
            g = s && s.virtualTranslate;
        s = s || {};
        var h = {};
        for (var v in s)
            if ("object" != typeof s[v] || null === s[v] || (s[v].nodeType || s[v] === window || s[v] === document || "undefined" != typeof Dom7 && s[v] instanceof Dom7 || "undefined" != typeof jQuery && s[v] instanceof jQuery)) h[v] = s[v];
            else { h[v] = {}; for (var f in s[v]) h[v][f] = s[v][f] }
        for (var w in c)
            if (void 0 === s[w]) s[w] = c[w];
            else if ("object" == typeof s[w])
            for (var y in c[w]) void 0 === s[w][y] && (s[w][y] = c[w][y]);
        var x = this;
        if (x.params = s, x.originalParams = h, x.classNames = [], void 0 !== e && "undefined" != typeof Dom7 && (e = Dom7), (void 0 !== e || (e = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7)) && (x.$ = e, x.currentBreakpoint = void 0, x.getActiveBreakpoint = function() {
                if (!x.params.breakpoints) return !1;
                var e, a = !1,
                    t = [];
                for (e in x.params.breakpoints) x.params.breakpoints.hasOwnProperty(e) && t.push(e);
                t.sort(function(e, a) { return parseInt(e, 10) > parseInt(a, 10) });
                for (var s = 0; s < t.length; s++)(e = t[s]) >= window.innerWidth && !a && (a = e);
                return a || "max"
            }, x.setBreakpoint = function() {
                var e = x.getActiveBreakpoint();
                if (e && x.currentBreakpoint !== e) {
                    var a = e in x.params.breakpoints ? x.params.breakpoints[e] : x.originalParams,
                        t = x.params.loop && a.slidesPerView !== x.params.slidesPerView;
                    for (var s in a) x.params[s] = a[s];
                    x.currentBreakpoint = e, t && x.destroyLoop && x.reLoop(!0)
                }
            }, x.params.breakpoints && x.setBreakpoint(), x.container = e(t), 0 !== x.container.length)) {
            if (x.container.length > 1) { var T = []; return x.container.each(function() { T.push(new a(this, s)) }), T }
            x.container[0].swiper = x, x.container.data("swiper", x), x.classNames.push(x.params.containerModifierClass + x.params.direction), x.params.freeMode && x.classNames.push(x.params.containerModifierClass + "free-mode"), x.support.flexbox || (x.classNames.push(x.params.containerModifierClass + "no-flexbox"), x.params.slidesPerColumn = 1), x.params.autoHeight && x.classNames.push(x.params.containerModifierClass + "autoheight"), (x.params.parallax || x.params.watchSlidesVisibility) && (x.params.watchSlidesProgress = !0), x.params.touchReleaseOnEdges && (x.params.resistanceRatio = 0), ["cube", "coverflow", "flip"].indexOf(x.params.effect) >= 0 && (x.support.transforms3d ? (x.params.watchSlidesProgress = !0, x.classNames.push(x.params.containerModifierClass + "3d")) : x.params.effect = "slide"), "slide" !== x.params.effect && x.classNames.push(x.params.containerModifierClass + x.params.effect), "cube" === x.params.effect && (x.params.resistanceRatio = 0, x.params.slidesPerView = 1, x.params.slidesPerColumn = 1, x.params.slidesPerGroup = 1, x.params.centeredSlides = !1, x.params.spaceBetween = 0, x.params.virtualTranslate = !0), "fade" !== x.params.effect && "flip" !== x.params.effect || (x.params.slidesPerView = 1, x.params.slidesPerColumn = 1, x.params.slidesPerGroup = 1, x.params.watchSlidesProgress = !0, x.params.spaceBetween = 0, void 0 === g && (x.params.virtualTranslate = !0)), x.params.grabCursor && x.support.touch && (x.params.grabCursor = !1), x.wrapper = x.container.children("." + x.params.wrapperClass), x.params.pagination && (x.paginationContainer = e(x.params.pagination), x.params.uniqueNavElements && "string" == typeof x.params.pagination && x.paginationContainer.length > 1 && 1 === x.container.find(x.params.pagination).length && (x.paginationContainer = x.container.find(x.params.pagination)), "bullets" === x.params.paginationType && x.params.paginationClickable ? x.paginationContainer.addClass(x.params.paginationModifierClass + "clickable") : x.params.paginationClickable = !1, x.paginationContainer.addClass(x.params.paginationModifierClass + x.params.paginationType)), (x.params.nextButton || x.params.prevButton) && (x.params.nextButton && (x.nextButton = e(x.params.nextButton), x.params.uniqueNavElements && "string" == typeof x.params.nextButton && x.nextButton.length > 1 && 1 === x.container.find(x.params.nextButton).length && (x.nextButton = x.container.find(x.params.nextButton))), x.params.prevButton && (x.prevButton = e(x.params.prevButton), x.params.uniqueNavElements && "string" == typeof x.params.prevButton && x.prevButton.length > 1 && 1 === x.container.find(x.params.prevButton).length && (x.prevButton = x.container.find(x.params.prevButton)))), x.isHorizontal = function() { return "horizontal" === x.params.direction }, x.rtl = x.isHorizontal() && ("rtl" === x.container[0].dir.toLowerCase() || "rtl" === x.container.css("direction")), x.rtl && x.classNames.push(x.params.containerModifierClass + "rtl"), x.rtl && (x.wrongRTL = "-webkit-box" === x.wrapper.css("display")), x.params.slidesPerColumn > 1 && x.classNames.push(x.params.containerModifierClass + "multirow"), x.device.android && x.classNames.push(x.params.containerModifierClass + "android"), x.container.addClass(x.classNames.join(" ")), x.translate = 0, x.progress = 0, x.velocity = 0, x.lockSwipeToNext = function() { x.params.allowSwipeToNext = !1, x.params.allowSwipeToPrev === !1 && x.params.grabCursor && x.unsetGrabCursor() }, x.lockSwipeToPrev = function() { x.params.allowSwipeToPrev = !1, x.params.allowSwipeToNext === !1 && x.params.grabCursor && x.unsetGrabCursor() }, x.lockSwipes = function() { x.params.allowSwipeToNext = x.params.allowSwipeToPrev = !1, x.params.grabCursor && x.unsetGrabCursor() }, x.unlockSwipeToNext = function() { x.params.allowSwipeToNext = !0, x.params.allowSwipeToPrev === !0 && x.params.grabCursor && x.setGrabCursor() }, x.unlockSwipeToPrev = function() { x.params.allowSwipeToPrev = !0, x.params.allowSwipeToNext === !0 && x.params.grabCursor && x.setGrabCursor() }, x.unlockSwipes = function() { x.params.allowSwipeToNext = x.params.allowSwipeToPrev = !0, x.params.grabCursor && x.setGrabCursor() }, x.setGrabCursor = function(e) { x.container[0].style.cursor = "move", x.container[0].style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", x.container[0].style.cursor = e ? "-moz-grabbin" : "-moz-grab", x.container[0].style.cursor = e ? "grabbing" : "grab" }, x.unsetGrabCursor = function() { x.container[0].style.cursor = "" }, x.params.grabCursor && x.setGrabCursor(), x.imagesToLoad = [], x.imagesLoaded = 0, x.loadImage = function(e, a, t, s, r, i) {
                function n() { i && i() }
                var o;
                e.complete && r ? n() : a ? (o = new window.Image, o.onload = n, o.onerror = n, s && (o.sizes = s), t && (o.srcset = t), a && (o.src = a)) : n()
            }, x.preloadImages = function() {
                function e() { void 0 !== x && null !== x && x && (void 0 !== x.imagesLoaded && x.imagesLoaded++, x.imagesLoaded === x.imagesToLoad.length && (x.params.updateOnImagesReady && x.update(), x.emit("onImagesReady", x))) }
                x.imagesToLoad = x.container.find("img");
                for (var a = 0; a < x.imagesToLoad.length; a++) x.loadImage(x.imagesToLoad[a], x.imagesToLoad[a].currentSrc || x.imagesToLoad[a].getAttribute("src"), x.imagesToLoad[a].srcset || x.imagesToLoad[a].getAttribute("srcset"), x.imagesToLoad[a].sizes || x.imagesToLoad[a].getAttribute("sizes"), !0, e)
            }, x.autoplayTimeoutId = void 0, x.autoplaying = !1, x.autoplayPaused = !1, x.startAutoplay = function() { return void 0 === x.autoplayTimeoutId && (!!x.params.autoplay && (!x.autoplaying && (x.autoplaying = !0, x.emit("onAutoplayStart", x), void i()))) }, x.stopAutoplay = function(e) { x.autoplayTimeoutId && (x.autoplayTimeoutId && clearTimeout(x.autoplayTimeoutId), x.autoplaying = !1, x.autoplayTimeoutId = void 0, x.emit("onAutoplayStop", x)) }, x.pauseAutoplay = function(e) { x.autoplayPaused || (x.autoplayTimeoutId && clearTimeout(x.autoplayTimeoutId), x.autoplayPaused = !0, 0 === e ? (x.autoplayPaused = !1, i()) : x.wrapper.transitionEnd(function() { x && (x.autoplayPaused = !1, x.autoplaying ? i() : x.stopAutoplay()) })) }, x.minTranslate = function() { return -x.snapGrid[0] }, x.maxTranslate = function() { return -x.snapGrid[x.snapGrid.length - 1] }, x.updateAutoHeight = function() {
                var e, a = [],
                    t = 0;
                if ("auto" !== x.params.slidesPerView && x.params.slidesPerView > 1)
                    for (e = 0; e < Math.ceil(x.params.slidesPerView); e++) {
                        var s = x.activeIndex + e;
                        if (s > x.slides.length) break;
                        a.push(x.slides.eq(s)[0])
                    } else a.push(x.slides.eq(x.activeIndex)[0]);
                for (e = 0; e < a.length; e++)
                    if (void 0 !== a[e]) {
                        var r = a[e].offsetHeight;
                        t = r > t ? r : t
                    }
                t && x.wrapper.css("height", t + "px")
            }, x.updateContainerSize = function() {
                var e, a;
                e = void 0 !== x.params.width ? x.params.width : x.container[0].clientWidth, a = void 0 !== x.params.height ? x.params.height : x.container[0].clientHeight, 0 === e && x.isHorizontal() || 0 === a && !x.isHorizontal() || (e = e - parseInt(x.container.css("padding-left"), 10) - parseInt(x.container.css("padding-right"), 10), a = a - parseInt(x.container.css("padding-top"), 10) - parseInt(x.container.css("padding-bottom"), 10), x.width = e, x.height = a, x.size = x.isHorizontal() ? x.width : x.height)
            }, x.updateSlidesSize = function() {
                x.slides = x.wrapper.children("." + x.params.slideClass), x.snapGrid = [], x.slidesGrid = [], x.slidesSizesGrid = [];
                var e, a = x.params.spaceBetween,
                    t = -x.params.slidesOffsetBefore,
                    s = 0,
                    i = 0;
                if (void 0 !== x.size) {
                    "string" == typeof a && a.indexOf("%") >= 0 && (a = parseFloat(a.replace("%", "")) / 100 * x.size), x.virtualSize = -a, x.rtl ? x.slides.css({ marginLeft: "", marginTop: "" }) : x.slides.css({ marginRight: "", marginBottom: "" });
                    var n;
                    x.params.slidesPerColumn > 1 && (n = Math.floor(x.slides.length / x.params.slidesPerColumn) === x.slides.length / x.params.slidesPerColumn ? x.slides.length : Math.ceil(x.slides.length / x.params.slidesPerColumn) * x.params.slidesPerColumn, "auto" !== x.params.slidesPerView && "row" === x.params.slidesPerColumnFill && (n = Math.max(n, x.params.slidesPerView * x.params.slidesPerColumn)));
                    var o, l = x.params.slidesPerColumn,
                        p = n / l,
                        d = p - (x.params.slidesPerColumn * p - x.slides.length);
                    for (e = 0; e < x.slides.length; e++) { o = 0; var m = x.slides.eq(e); if (x.params.slidesPerColumn > 1) { var u, c, g; "column" === x.params.slidesPerColumnFill ? (c = Math.floor(e / l), g = e - c * l, (c > d || c === d && g === l - 1) && ++g >= l && (g = 0, c++), u = c + g * n / l, m.css({ "-webkit-box-ordinal-group": u, "-moz-box-ordinal-group": u, "-ms-flex-order": u, "-webkit-order": u, order: u })) : (g = Math.floor(e / p), c = e - g * p), m.css("margin-" + (x.isHorizontal() ? "top" : "left"), 0 !== g && x.params.spaceBetween && x.params.spaceBetween + "px").attr("data-swiper-column", c).attr("data-swiper-row", g) } "none" !== m.css("display") && ("auto" === x.params.slidesPerView ? (o = x.isHorizontal() ? m.outerWidth(!0) : m.outerHeight(!0), x.params.roundLengths && (o = r(o))) : (o = (x.size - (x.params.slidesPerView - 1) * a) / x.params.slidesPerView, x.params.roundLengths && (o = r(o)), x.isHorizontal() ? x.slides[e].style.width = o + "px" : x.slides[e].style.height = o + "px"), x.slides[e].swiperSlideSize = o, x.slidesSizesGrid.push(o), x.params.centeredSlides ? (t = t + o / 2 + s / 2 + a, 0 === s && 0 !== e && (t = t - x.size / 2 - a), 0 === e && (t = t - x.size / 2 - a), Math.abs(t) < .001 && (t = 0), i % x.params.slidesPerGroup == 0 && x.snapGrid.push(t), x.slidesGrid.push(t)) : (i % x.params.slidesPerGroup == 0 && x.snapGrid.push(t), x.slidesGrid.push(t), t = t + o + a), x.virtualSize += o + a, s = o, i++) }
                    x.virtualSize = Math.max(x.virtualSize, x.size) + x.params.slidesOffsetAfter;
                    var h;
                    if (x.rtl && x.wrongRTL && ("slide" === x.params.effect || "coverflow" === x.params.effect) && x.wrapper.css({ width: x.virtualSize + x.params.spaceBetween + "px" }), x.support.flexbox && !x.params.setWrapperSize || (x.isHorizontal() ? x.wrapper.css({ width: x.virtualSize + x.params.spaceBetween + "px" }) : x.wrapper.css({ height: x.virtualSize + x.params.spaceBetween + "px" })), x.params.slidesPerColumn > 1 && (x.virtualSize = (o + x.params.spaceBetween) * n, x.virtualSize = Math.ceil(x.virtualSize / x.params.slidesPerColumn) - x.params.spaceBetween, x.isHorizontal() ? x.wrapper.css({ width: x.virtualSize + x.params.spaceBetween + "px" }) : x.wrapper.css({ height: x.virtualSize + x.params.spaceBetween + "px" }), x.params.centeredSlides)) {
                        for (h = [], e = 0; e < x.snapGrid.length; e++) x.snapGrid[e] < x.virtualSize + x.snapGrid[0] && h.push(x.snapGrid[e]);
                        x.snapGrid = h
                    }
                    if (!x.params.centeredSlides) {
                        for (h = [], e = 0; e < x.snapGrid.length; e++) x.snapGrid[e] <= x.virtualSize - x.size && h.push(x.snapGrid[e]);
                        x.snapGrid = h, Math.floor(x.virtualSize - x.size) - Math.floor(x.snapGrid[x.snapGrid.length - 1]) > 1 && x.snapGrid.push(x.virtualSize - x.size)
                    }
                    0 === x.snapGrid.length && (x.snapGrid = [0]), 0 !== x.params.spaceBetween && (x.isHorizontal() ? x.rtl ? x.slides.css({ marginLeft: a + "px" }) : x.slides.css({ marginRight: a + "px" }) : x.slides.css({ marginBottom: a + "px" })), x.params.watchSlidesProgress && x.updateSlidesOffset()
                }
            }, x.updateSlidesOffset = function() { for (var e = 0; e < x.slides.length; e++) x.slides[e].swiperSlideOffset = x.isHorizontal() ? x.slides[e].offsetLeft : x.slides[e].offsetTop }, x.currentSlidesPerView = function() {
                var e, a, t = 1;
                if (x.params.centeredSlides) { var s, r = x.slides[x.activeIndex].swiperSlideSize; for (e = x.activeIndex + 1; e < x.slides.length; e++) x.slides[e] && !s && (r += x.slides[e].swiperSlideSize, t++, r > x.size && (s = !0)); for (a = x.activeIndex - 1; a >= 0; a--) x.slides[a] && !s && (r += x.slides[a].swiperSlideSize, t++, r > x.size && (s = !0)) } else
                    for (e = x.activeIndex + 1; e < x.slides.length; e++) x.slidesGrid[e] - x.slidesGrid[x.activeIndex] < x.size && t++;
                return t
            }, x.updateSlidesProgress = function(e) {
                if (void 0 === e && (e = x.translate || 0), 0 !== x.slides.length) {
                    void 0 === x.slides[0].swiperSlideOffset && x.updateSlidesOffset();
                    var a = -e;
                    x.rtl && (a = e), x.slides.removeClass(x.params.slideVisibleClass);
                    for (var t = 0; t < x.slides.length; t++) {
                        var s = x.slides[t],
                            r = (a + (x.params.centeredSlides ? x.minTranslate() : 0) - s.swiperSlideOffset) / (s.swiperSlideSize + x.params.spaceBetween);
                        if (x.params.watchSlidesVisibility) {
                            var i = -(a - s.swiperSlideOffset),
                                n = i + x.slidesSizesGrid[t];
                            (i >= 0 && i < x.size || n > 0 && n <= x.size || i <= 0 && n >= x.size) && x.slides.eq(t).addClass(x.params.slideVisibleClass)
                        }
                        s.progress = x.rtl ? -r : r
                    }
                }
            }, x.updateProgress = function(e) {
                void 0 === e && (e = x.translate || 0);
                var a = x.maxTranslate() - x.minTranslate(),
                    t = x.isBeginning,
                    s = x.isEnd;
                0 === a ? (x.progress = 0, x.isBeginning = x.isEnd = !0) : (x.progress = (e - x.minTranslate()) / a, x.isBeginning = x.progress <= 0, x.isEnd = x.progress >= 1), x.isBeginning && !t && x.emit("onReachBeginning", x), x.isEnd && !s && x.emit("onReachEnd", x), x.params.watchSlidesProgress && x.updateSlidesProgress(e), x.emit("onProgress", x, x.progress)
            }, x.updateActiveIndex = function() {
                var e, a, t, s = x.rtl ? x.translate : -x.translate;
                for (a = 0; a < x.slidesGrid.length; a++) void 0 !== x.slidesGrid[a + 1] ? s >= x.slidesGrid[a] && s < x.slidesGrid[a + 1] - (x.slidesGrid[a + 1] - x.slidesGrid[a]) / 2 ? e = a : s >= x.slidesGrid[a] && s < x.slidesGrid[a + 1] && (e = a + 1) : s >= x.slidesGrid[a] && (e = a);
                x.params.normalizeSlideIndex && (e < 0 || void 0 === e) && (e = 0), t = Math.floor(e / x.params.slidesPerGroup), t >= x.snapGrid.length && (t = x.snapGrid.length - 1), e !== x.activeIndex && (x.snapIndex = t, x.previousIndex = x.activeIndex, x.activeIndex = e, x.updateClasses(), x.updateRealIndex())
            }, x.updateRealIndex = function() { x.realIndex = parseInt(x.slides.eq(x.activeIndex).attr("data-swiper-slide-index") || x.activeIndex, 10) }, x.updateClasses = function() {
                x.slides.removeClass(x.params.slideActiveClass + " " + x.params.slideNextClass + " " + x.params.slidePrevClass + " " + x.params.slideDuplicateActiveClass + " " + x.params.slideDuplicateNextClass + " " + x.params.slideDuplicatePrevClass);
                var a = x.slides.eq(x.activeIndex);
                a.addClass(x.params.slideActiveClass), s.loop && (a.hasClass(x.params.slideDuplicateClass) ? x.wrapper.children("." + x.params.slideClass + ":not(." + x.params.slideDuplicateClass + ')[data-swiper-slide-index="' + x.realIndex + '"]').addClass(x.params.slideDuplicateActiveClass) : x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + x.realIndex + '"]').addClass(x.params.slideDuplicateActiveClass));
                var t = a.next("." + x.params.slideClass).addClass(x.params.slideNextClass);
                x.params.loop && 0 === t.length && (t = x.slides.eq(0), t.addClass(x.params.slideNextClass));
                var r = a.prev("." + x.params.slideClass).addClass(x.params.slidePrevClass);
                if (x.params.loop && 0 === r.length && (r = x.slides.eq(-1), r.addClass(x.params.slidePrevClass)), s.loop && (t.hasClass(x.params.slideDuplicateClass) ? x.wrapper.children("." + x.params.slideClass + ":not(." + x.params.slideDuplicateClass + ')[data-swiper-slide-index="' + t.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicateNextClass) : x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + t.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicateNextClass), r.hasClass(x.params.slideDuplicateClass) ? x.wrapper.children("." + x.params.slideClass + ":not(." + x.params.slideDuplicateClass + ')[data-swiper-slide-index="' + r.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicatePrevClass) : x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + r.attr("data-swiper-slide-index") + '"]').addClass(x.params.slideDuplicatePrevClass)), x.paginationContainer && x.paginationContainer.length > 0) {
                    var i, n = x.params.loop ? Math.ceil((x.slides.length - 2 * x.loopedSlides) / x.params.slidesPerGroup) : x.snapGrid.length;
                    if (x.params.loop ? (i = Math.ceil((x.activeIndex - x.loopedSlides) / x.params.slidesPerGroup), i > x.slides.length - 1 - 2 * x.loopedSlides && (i -= x.slides.length - 2 * x.loopedSlides), i > n - 1 && (i -= n), i < 0 && "bullets" !== x.params.paginationType && (i = n + i)) : i = void 0 !== x.snapIndex ? x.snapIndex : x.activeIndex || 0, "bullets" === x.params.paginationType && x.bullets && x.bullets.length > 0 && (x.bullets.removeClass(x.params.bulletActiveClass), x.paginationContainer.length > 1 ? x.bullets.each(function() { e(this).index() === i && e(this).addClass(x.params.bulletActiveClass) }) : x.bullets.eq(i).addClass(x.params.bulletActiveClass)), "fraction" === x.params.paginationType && (x.paginationContainer.find("." + x.params.paginationCurrentClass).text(i + 1), x.paginationContainer.find("." + x.params.paginationTotalClass).text(n)), "progress" === x.params.paginationType) {
                        var o = (i + 1) / n,
                            l = o,
                            p = 1;
                        x.isHorizontal() || (p = o, l = 1), x.paginationContainer.find("." + x.params.paginationProgressbarClass).transform("translate3d(0,0,0) scaleX(" + l + ") scaleY(" + p + ")").transition(x.params.speed)
                    }
                    "custom" === x.params.paginationType && x.params.paginationCustomRender && (x.paginationContainer.html(x.params.paginationCustomRender(x, i + 1, n)), x.emit("onPaginationRendered", x, x.paginationContainer[0]))
                }
                x.params.loop || (x.params.prevButton && x.prevButton && x.prevButton.length > 0 && (x.isBeginning ? (x.prevButton.addClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.disable(x.prevButton)) : (x.prevButton.removeClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.enable(x.prevButton))), x.params.nextButton && x.nextButton && x.nextButton.length > 0 && (x.isEnd ? (x.nextButton.addClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.disable(x.nextButton)) : (x.nextButton.removeClass(x.params.buttonDisabledClass), x.params.a11y && x.a11y && x.a11y.enable(x.nextButton))))
            }, x.updatePagination = function() {
                if (x.params.pagination && x.paginationContainer && x.paginationContainer.length > 0) {
                    var e = "";
                    if ("bullets" === x.params.paginationType) {
                        for (var a = x.params.loop ? Math.ceil((x.slides.length - 2 * x.loopedSlides) / x.params.slidesPerGroup) : x.snapGrid.length, t = 0; t < a; t++) e += x.params.paginationBulletRender ? x.params.paginationBulletRender(x, t, x.params.bulletClass) : "<" + x.params.paginationElement + ' class="' + x.params.bulletClass + '"></' + x.params.paginationElement + ">";
                        x.paginationContainer.html(e), x.bullets = x.paginationContainer.find("." + x.params.bulletClass), x.params.paginationClickable && x.params.a11y && x.a11y && x.a11y.initPagination()
                    }
                    "fraction" === x.params.paginationType && (e = x.params.paginationFractionRender ? x.params.paginationFractionRender(x, x.params.paginationCurrentClass, x.params.paginationTotalClass) : '<span class="' + x.params.paginationCurrentClass + '"></span> / <span class="' + x.params.paginationTotalClass + '"></span>', x.paginationContainer.html(e)), "progress" === x.params.paginationType && (e = x.params.paginationProgressRender ? x.params.paginationProgressRender(x, x.params.paginationProgressbarClass) : '<span class="' + x.params.paginationProgressbarClass + '"></span>', x.paginationContainer.html(e)), "custom" !== x.params.paginationType && x.emit("onPaginationRendered", x, x.paginationContainer[0])
                }
            }, x.update = function(e) {
                function a() {
                    x.rtl, x.translate;
                    t = Math.min(Math.max(x.translate, x.maxTranslate()), x.minTranslate()), x.setWrapperTranslate(t), x.updateActiveIndex(), x.updateClasses()
                }
                if (x) { x.updateContainerSize(), x.updateSlidesSize(), x.updateProgress(), x.updatePagination(), x.updateClasses(), x.params.scrollbar && x.scrollbar && x.scrollbar.set(); var t; if (e) { x.controller && x.controller.spline && (x.controller.spline = void 0), x.params.freeMode ? (a(), x.params.autoHeight && x.updateAutoHeight()) : (("auto" === x.params.slidesPerView || x.params.slidesPerView > 1) && x.isEnd && !x.params.centeredSlides ? x.slideTo(x.slides.length - 1, 0, !1, !0) : x.slideTo(x.activeIndex, 0, !1, !0)) || a() } else x.params.autoHeight && x.updateAutoHeight() }
            }, x.onResize = function(e) {
                x.params.onBeforeResize && x.params.onBeforeResize(x), x.params.breakpoints && x.setBreakpoint();
                var a = x.params.allowSwipeToPrev,
                    t = x.params.allowSwipeToNext;
                x.params.allowSwipeToPrev = x.params.allowSwipeToNext = !0, x.updateContainerSize(), x.updateSlidesSize(), ("auto" === x.params.slidesPerView || x.params.freeMode || e) && x.updatePagination(), x.params.scrollbar && x.scrollbar && x.scrollbar.set(), x.controller && x.controller.spline && (x.controller.spline = void 0);
                var s = !1;
                if (x.params.freeMode) {
                    var r = Math.min(Math.max(x.translate, x.maxTranslate()), x.minTranslate());
                    x.setWrapperTranslate(r), x.updateActiveIndex(), x.updateClasses(), x.params.autoHeight && x.updateAutoHeight()
                } else x.updateClasses(), s = ("auto" === x.params.slidesPerView || x.params.slidesPerView > 1) && x.isEnd && !x.params.centeredSlides ? x.slideTo(x.slides.length - 1, 0, !1, !0) : x.slideTo(x.activeIndex, 0, !1, !0);
                x.params.lazyLoading && !s && x.lazy && x.lazy.load(), x.params.allowSwipeToPrev = a, x.params.allowSwipeToNext = t, x.params.onAfterResize && x.params.onAfterResize(x)
            }, x.touchEventsDesktop = { start: "mousedown", move: "mousemove", end: "mouseup" }, window.navigator.pointerEnabled ? x.touchEventsDesktop = { start: "pointerdown", move: "pointermove", end: "pointerup" } : window.navigator.msPointerEnabled && (x.touchEventsDesktop = { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" }), x.touchEvents = { start: x.support.touch || !x.params.simulateTouch ? "touchstart" : x.touchEventsDesktop.start, move: x.support.touch || !x.params.simulateTouch ? "touchmove" : x.touchEventsDesktop.move, end: x.support.touch || !x.params.simulateTouch ? "touchend" : x.touchEventsDesktop.end }, (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && ("container" === x.params.touchEventsTarget ? x.container : x.wrapper).addClass("swiper-wp8-" + x.params.direction), x.initEvents = function(e) {
                var a = e ? "off" : "on",
                    t = e ? "removeEventListener" : "addEventListener",
                    r = "container" === x.params.touchEventsTarget ? x.container[0] : x.wrapper[0],
                    i = x.support.touch ? r : document,
                    n = !!x.params.nested;
                if (x.browser.ie) r[t](x.touchEvents.start, x.onTouchStart, !1), i[t](x.touchEvents.move, x.onTouchMove, n), i[t](x.touchEvents.end, x.onTouchEnd, !1);
                else {
                    if (x.support.touch) {
                        var o = !("touchstart" !== x.touchEvents.start || !x.support.passiveListener || !x.params.passiveListeners) && { passive: !0, capture: !1 };
                        r[t](x.touchEvents.start, x.onTouchStart, o), r[t](x.touchEvents.move, x.onTouchMove, n), r[t](x.touchEvents.end, x.onTouchEnd, o)
                    }(s.simulateTouch && !x.device.ios && !x.device.android || s.simulateTouch && !x.support.touch && x.device.ios) && (r[t]("mousedown", x.onTouchStart, !1), document[t]("mousemove", x.onTouchMove, n), document[t]("mouseup", x.onTouchEnd, !1))
                }
                window[t]("resize", x.onResize), x.params.nextButton && x.nextButton && x.nextButton.length > 0 && (x.nextButton[a]("click", x.onClickNext), x.params.a11y && x.a11y && x.nextButton[a]("keydown", x.a11y.onEnterKey)), x.params.prevButton && x.prevButton && x.prevButton.length > 0 && (x.prevButton[a]("click", x.onClickPrev), x.params.a11y && x.a11y && x.prevButton[a]("keydown", x.a11y.onEnterKey)), x.params.pagination && x.params.paginationClickable && (x.paginationContainer[a]("click", "." + x.params.bulletClass, x.onClickIndex), x.params.a11y && x.a11y && x.paginationContainer[a]("keydown", "." + x.params.bulletClass, x.a11y.onEnterKey)), (x.params.preventClicks || x.params.preventClicksPropagation) && r[t]("click", x.preventClicks, !0)
            }, x.attachEvents = function() { x.initEvents() }, x.detachEvents = function() { x.initEvents(!0) }, x.allowClick = !0, x.preventClicks = function(e) { x.allowClick || (x.params.preventClicks && e.preventDefault(), x.params.preventClicksPropagation && x.animating && (e.stopPropagation(), e.stopImmediatePropagation())) }, x.onClickNext = function(e) { e.preventDefault(), x.isEnd && !x.params.loop || x.slideNext() }, x.onClickPrev = function(e) { e.preventDefault(), x.isBeginning && !x.params.loop || x.slidePrev() }, x.onClickIndex = function(a) {
                a.preventDefault();
                var t = e(this).index() * x.params.slidesPerGroup;
                x.params.loop && (t += x.loopedSlides), x.slideTo(t)
            }, x.updateClickedSlide = function(a) {
                var t = n(a, "." + x.params.slideClass),
                    s = !1;
                if (t)
                    for (var r = 0; r < x.slides.length; r++) x.slides[r] === t && (s = !0);
                if (!t || !s) return x.clickedSlide = void 0, void(x.clickedIndex = void 0);
                if (x.clickedSlide = t, x.clickedIndex = e(t).index(), x.params.slideToClickedSlide && void 0 !== x.clickedIndex && x.clickedIndex !== x.activeIndex) {
                    var i, o = x.clickedIndex,
                        l = "auto" === x.params.slidesPerView ? x.currentSlidesPerView() : x.params.slidesPerView;
                    if (x.params.loop) {
                        if (x.animating) return;
                        i = parseInt(e(x.clickedSlide).attr("data-swiper-slide-index"), 10), x.params.centeredSlides ? o < x.loopedSlides - l / 2 || o > x.slides.length - x.loopedSlides + l / 2 ? (x.fixLoop(), o = x.wrapper.children("." + x.params.slideClass + '[data-swiper-slide-index="' + i + '"]:not(.' + x.params.slideDuplicateClass + ")").eq(0).index(), setTimeout(function() { x.slideTo(o) }, 0)) : x.slideTo(o) : o > x.slides.length - l ? (x.fixLoop(), o = x.wrapper.children("." + x.params.slideClass + '[data-swiper-slide-index="' + i + '"]:not(.' + x.params.slideDuplicateClass + ")").eq(0).index(), setTimeout(function() { x.slideTo(o) }, 0)) : x.slideTo(o)
                    } else x.slideTo(o)
                }
            };
            var b, C, S, z, M, P, E, I, k, D, L = "input, select, textarea, button, video",
                B = Date.now(),
                H = [];
            x.animating = !1, x.touches = { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 };
            var G, X;
            x.onTouchStart = function(a) {
                if (a.originalEvent && (a = a.originalEvent), (G = "touchstart" === a.type) || !("which" in a) || 3 !== a.which) {
                    if (x.params.noSwiping && n(a, "." + x.params.noSwipingClass)) return void(x.allowClick = !0);
                    if (!x.params.swipeHandler || n(a, x.params.swipeHandler)) {
                        var t = x.touches.currentX = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX,
                            s = x.touches.currentY = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY;
                        if (!(x.device.ios && x.params.iOSEdgeSwipeDetection && t <= x.params.iOSEdgeSwipeThreshold)) {
                            if (b = !0, C = !1, S = !0, M = void 0, X = void 0, x.touches.startX = t, x.touches.startY = s, z = Date.now(), x.allowClick = !0, x.updateContainerSize(), x.swipeDirection = void 0, x.params.threshold > 0 && (I = !1), "touchstart" !== a.type) {
                                var r = !0;
                                e(a.target).is(L) && (r = !1), document.activeElement && e(document.activeElement).is(L) && document.activeElement.blur(), r && a.preventDefault()
                            }
                            x.emit("onTouchStart", x, a)
                        }
                    }
                }
            }, x.onTouchMove = function(a) {
                if (a.originalEvent && (a = a.originalEvent), !G || "mousemove" !== a.type) {
                    if (a.preventedByNestedSwiper) return x.touches.startX = "touchmove" === a.type ? a.targetTouches[0].pageX : a.pageX, void(x.touches.startY = "touchmove" === a.type ? a.targetTouches[0].pageY : a.pageY);
                    if (x.params.onlyExternal) return x.allowClick = !1, void(b && (x.touches.startX = x.touches.currentX = "touchmove" === a.type ? a.targetTouches[0].pageX : a.pageX, x.touches.startY = x.touches.currentY = "touchmove" === a.type ? a.targetTouches[0].pageY : a.pageY, z = Date.now()));
                    if (G && x.params.touchReleaseOnEdges && !x.params.loop)
                        if (x.isHorizontal()) { if (x.touches.currentX < x.touches.startX && x.translate <= x.maxTranslate() || x.touches.currentX > x.touches.startX && x.translate >= x.minTranslate()) return } else if (x.touches.currentY < x.touches.startY && x.translate <= x.maxTranslate() || x.touches.currentY > x.touches.startY && x.translate >= x.minTranslate()) return;
                    if (G && document.activeElement && a.target === document.activeElement && e(a.target).is(L)) return C = !0, void(x.allowClick = !1);
                    if (S && x.emit("onTouchMove", x, a), !(a.targetTouches && a.targetTouches.length > 1)) {
                        if (x.touches.currentX = "touchmove" === a.type ? a.targetTouches[0].pageX : a.pageX, x.touches.currentY = "touchmove" === a.type ? a.targetTouches[0].pageY : a.pageY, void 0 === M) {
                            var t;
                            x.isHorizontal() && x.touches.currentY === x.touches.startY || !x.isHorizontal() && x.touches.currentX === x.touches.startX ? M = !1 : (t = 180 * Math.atan2(Math.abs(x.touches.currentY - x.touches.startY), Math.abs(x.touches.currentX - x.touches.startX)) / Math.PI, M = x.isHorizontal() ? t > x.params.touchAngle : 90 - t > x.params.touchAngle)
                        }
                        if (M && x.emit("onTouchMoveOpposite", x, a), void 0 === X && (x.touches.currentX === x.touches.startX && x.touches.currentY === x.touches.startY || (X = !0)), b) {
                            if (M) return void(b = !1);
                            if (X) {
                                x.allowClick = !1, x.emit("onSliderMove", x, a), a.preventDefault(), x.params.touchMoveStopPropagation && !x.params.nested && a.stopPropagation(), C || (s.loop && x.fixLoop(), E = x.getWrapperTranslate(), x.setWrapperTransition(0), x.animating && x.wrapper.trigger("webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd"), x.params.autoplay && x.autoplaying && (x.params.autoplayDisableOnInteraction ? x.stopAutoplay() : x.pauseAutoplay()), D = !1, !x.params.grabCursor || x.params.allowSwipeToNext !== !0 && x.params.allowSwipeToPrev !== !0 || x.setGrabCursor(!0)), C = !0;
                                var r = x.touches.diff = x.isHorizontal() ? x.touches.currentX - x.touches.startX : x.touches.currentY - x.touches.startY;
                                r *= x.params.touchRatio, x.rtl && (r = -r), x.swipeDirection = r > 0 ? "prev" : "next", P = r + E;
                                var i = !0;
                                if (r > 0 && P > x.minTranslate() ? (i = !1, x.params.resistance && (P = x.minTranslate() - 1 + Math.pow(-x.minTranslate() + E + r, x.params.resistanceRatio))) : r < 0 && P < x.maxTranslate() && (i = !1, x.params.resistance && (P = x.maxTranslate() + 1 - Math.pow(x.maxTranslate() - E - r, x.params.resistanceRatio))), i && (a.preventedByNestedSwiper = !0), !x.params.allowSwipeToNext && "next" === x.swipeDirection && P < E && (P = E), !x.params.allowSwipeToPrev && "prev" === x.swipeDirection && P > E && (P = E), x.params.threshold > 0) { if (!(Math.abs(r) > x.params.threshold || I)) return void(P = E); if (!I) return I = !0, x.touches.startX = x.touches.currentX, x.touches.startY = x.touches.currentY, P = E, void(x.touches.diff = x.isHorizontal() ? x.touches.currentX - x.touches.startX : x.touches.currentY - x.touches.startY) }
                                x.params.followFinger && ((x.params.freeMode || x.params.watchSlidesProgress) && x.updateActiveIndex(), x.params.freeMode && (0 === H.length && H.push({ position: x.touches[x.isHorizontal() ? "startX" : "startY"], time: z }), H.push({ position: x.touches[x.isHorizontal() ? "currentX" : "currentY"], time: (new window.Date).getTime() })), x.updateProgress(P), x.setWrapperTranslate(P))
                            }
                        }
                    }
                }
            }, x.onTouchEnd = function(a) {
                if (a.originalEvent && (a = a.originalEvent), S && x.emit("onTouchEnd", x, a), S = !1, b) {
                    x.params.grabCursor && C && b && (x.params.allowSwipeToNext === !0 || x.params.allowSwipeToPrev === !0) && x.setGrabCursor(!1);
                    var t = Date.now(),
                        s = t - z;
                    if (x.allowClick && (x.updateClickedSlide(a), x.emit("onTap", x, a), s < 300 && t - B > 300 && (k && clearTimeout(k), k = setTimeout(function() { x && (x.params.paginationHide && x.paginationContainer.length > 0 && !e(a.target).hasClass(x.params.bulletClass) && x.paginationContainer.toggleClass(x.params.paginationHiddenClass), x.emit("onClick", x, a)) }, 300)), s < 300 && t - B < 300 && (k && clearTimeout(k), x.emit("onDoubleTap", x, a))), B = Date.now(), setTimeout(function() { x && (x.allowClick = !0) }, 0), !b || !C || !x.swipeDirection || 0 === x.touches.diff || P === E) return void(b = C = !1);
                    b = C = !1;
                    var r;
                    if (r = x.params.followFinger ? x.rtl ? x.translate : -x.translate : -P, x.params.freeMode) {
                        if (r < -x.minTranslate()) return void x.slideTo(x.activeIndex);
                        if (r > -x.maxTranslate()) return void(x.slides.length < x.snapGrid.length ? x.slideTo(x.snapGrid.length - 1) : x.slideTo(x.slides.length - 1));
                        if (x.params.freeModeMomentum) {
                            if (H.length > 1) {
                                var i = H.pop(),
                                    n = H.pop(),
                                    o = i.position - n.position,
                                    l = i.time - n.time;
                                x.velocity = o / l, x.velocity = x.velocity / 2, Math.abs(x.velocity) < x.params.freeModeMinimumVelocity && (x.velocity = 0), (l > 150 || (new window.Date).getTime() - i.time > 300) && (x.velocity = 0)
                            } else x.velocity = 0;
                            x.velocity = x.velocity * x.params.freeModeMomentumVelocityRatio, H.length = 0;
                            var p = 1e3 * x.params.freeModeMomentumRatio,
                                d = x.velocity * p,
                                m = x.translate + d;
                            x.rtl && (m = -m);
                            var u, c = !1,
                                g = 20 * Math.abs(x.velocity) * x.params.freeModeMomentumBounceRatio;
                            if (m < x.maxTranslate()) x.params.freeModeMomentumBounce ? (m + x.maxTranslate() < -g && (m = x.maxTranslate() - g), u = x.maxTranslate(), c = !0, D = !0) : m = x.maxTranslate();
                            else if (m > x.minTranslate()) x.params.freeModeMomentumBounce ? (m - x.minTranslate() > g && (m = x.minTranslate() + g), u = x.minTranslate(), c = !0, D = !0) : m = x.minTranslate();
                            else if (x.params.freeModeSticky) {
                                var h, v = 0;
                                for (v = 0; v < x.snapGrid.length; v += 1)
                                    if (x.snapGrid[v] > -m) { h = v; break }
                                m = Math.abs(x.snapGrid[h] - m) < Math.abs(x.snapGrid[h - 1] - m) || "next" === x.swipeDirection ? x.snapGrid[h] : x.snapGrid[h - 1], x.rtl || (m = -m)
                            }
                            if (0 !== x.velocity) p = x.rtl ? Math.abs((-m - x.translate) / x.velocity) : Math.abs((m - x.translate) / x.velocity);
                            else if (x.params.freeModeSticky) return void x.slideReset();
                            x.params.freeModeMomentumBounce && c ? (x.updateProgress(u), x.setWrapperTransition(p), x.setWrapperTranslate(m), x.onTransitionStart(), x.animating = !0, x.wrapper.transitionEnd(function() { x && D && (x.emit("onMomentumBounce", x), x.setWrapperTransition(x.params.speed), x.setWrapperTranslate(u), x.wrapper.transitionEnd(function() { x && x.onTransitionEnd() })) })) : x.velocity ? (x.updateProgress(m), x.setWrapperTransition(p), x.setWrapperTranslate(m), x.onTransitionStart(), x.animating || (x.animating = !0, x.wrapper.transitionEnd(function() { x && x.onTransitionEnd() }))) : x.updateProgress(m), x.updateActiveIndex()
                        }
                        return void((!x.params.freeModeMomentum || s >= x.params.longSwipesMs) && (x.updateProgress(), x.updateActiveIndex()))
                    }
                    var f, w = 0,
                        y = x.slidesSizesGrid[0];
                    for (f = 0; f < x.slidesGrid.length; f += x.params.slidesPerGroup) void 0 !== x.slidesGrid[f + x.params.slidesPerGroup] ? r >= x.slidesGrid[f] && r < x.slidesGrid[f + x.params.slidesPerGroup] && (w = f, y = x.slidesGrid[f + x.params.slidesPerGroup] - x.slidesGrid[f]) : r >= x.slidesGrid[f] && (w = f, y = x.slidesGrid[x.slidesGrid.length - 1] - x.slidesGrid[x.slidesGrid.length - 2]);
                    var T = (r - x.slidesGrid[w]) / y;
                    if (s > x.params.longSwipesMs) { if (!x.params.longSwipes) return void x.slideTo(x.activeIndex); "next" === x.swipeDirection && (T >= x.params.longSwipesRatio ? x.slideTo(w + x.params.slidesPerGroup) : x.slideTo(w)), "prev" === x.swipeDirection && (T > 1 - x.params.longSwipesRatio ? x.slideTo(w + x.params.slidesPerGroup) : x.slideTo(w)) } else { if (!x.params.shortSwipes) return void x.slideTo(x.activeIndex); "next" === x.swipeDirection && x.slideTo(w + x.params.slidesPerGroup), "prev" === x.swipeDirection && x.slideTo(w) }
                }
            }, x._slideTo = function(e, a) { return x.slideTo(e, a, !0, !0) }, x.slideTo = function(e, a, t, s) {
                void 0 === t && (t = !0), void 0 === e && (e = 0), e < 0 && (e = 0), x.snapIndex = Math.floor(e / x.params.slidesPerGroup), x.snapIndex >= x.snapGrid.length && (x.snapIndex = x.snapGrid.length - 1);
                var r = -x.snapGrid[x.snapIndex];
                if (x.params.autoplay && x.autoplaying && (s || !x.params.autoplayDisableOnInteraction ? x.pauseAutoplay(a) : x.stopAutoplay()), x.updateProgress(r), x.params.normalizeSlideIndex)
                    for (var i = 0; i < x.slidesGrid.length; i++) - Math.floor(100 * r) >= Math.floor(100 * x.slidesGrid[i]) && (e = i);
                return !(!x.params.allowSwipeToNext && r < x.translate && r < x.minTranslate()) && (!(!x.params.allowSwipeToPrev && r > x.translate && r > x.maxTranslate() && (x.activeIndex || 0) !== e) && (void 0 === a && (a = x.params.speed), x.previousIndex = x.activeIndex || 0, x.activeIndex = e, x.updateRealIndex(), x.rtl && -r === x.translate || !x.rtl && r === x.translate ? (x.params.autoHeight && x.updateAutoHeight(), x.updateClasses(), "slide" !== x.params.effect && x.setWrapperTranslate(r), !1) : (x.updateClasses(), x.onTransitionStart(t), 0 === a || x.browser.lteIE9 ? (x.setWrapperTranslate(r), x.setWrapperTransition(0), x.onTransitionEnd(t)) : (x.setWrapperTranslate(r), x.setWrapperTransition(a), x.animating || (x.animating = !0, x.wrapper.transitionEnd(function() { x && x.onTransitionEnd(t) }))), !0)))
            }, x.onTransitionStart = function(e) { void 0 === e && (e = !0), x.params.autoHeight && x.updateAutoHeight(), x.lazy && x.lazy.onTransitionStart(), e && (x.emit("onTransitionStart", x), x.activeIndex !== x.previousIndex && (x.emit("onSlideChangeStart", x), x.activeIndex > x.previousIndex ? x.emit("onSlideNextStart", x) : x.emit("onSlidePrevStart", x))) }, x.onTransitionEnd = function(e) { x.animating = !1, x.setWrapperTransition(0), void 0 === e && (e = !0), x.lazy && x.lazy.onTransitionEnd(), e && (x.emit("onTransitionEnd", x), x.activeIndex !== x.previousIndex && (x.emit("onSlideChangeEnd", x), x.activeIndex > x.previousIndex ? x.emit("onSlideNextEnd", x) : x.emit("onSlidePrevEnd", x))), x.params.history && x.history && x.history.setHistory(x.params.history, x.activeIndex), x.params.hashnav && x.hashnav && x.hashnav.setHash() }, x.slideNext = function(e, a, t) {
                if (x.params.loop) {
                    if (x.animating) return !1;
                    x.fixLoop();
                    x.container[0].clientLeft;
                    return x.slideTo(x.activeIndex + x.params.slidesPerGroup, a, e, t)
                }
                return x.slideTo(x.activeIndex + x.params.slidesPerGroup, a, e, t)
            }, x._slideNext = function(e) { return x.slideNext(!0, e, !0) }, x.slidePrev = function(e, a, t) {
                if (x.params.loop) {
                    if (x.animating) return !1;
                    x.fixLoop();
                    x.container[0].clientLeft;
                    return x.slideTo(x.activeIndex - 1, a, e, t)
                }
                return x.slideTo(x.activeIndex - 1, a, e, t)
            }, x._slidePrev = function(e) { return x.slidePrev(!0, e, !0) }, x.slideReset = function(e, a, t) { return x.slideTo(x.activeIndex, a, e) }, x.disableTouchControl = function() { return x.params.onlyExternal = !0, !0 }, x.enableTouchControl = function() { return x.params.onlyExternal = !1, !0 }, x.setWrapperTransition = function(e, a) { x.wrapper.transition(e), "slide" !== x.params.effect && x.effects[x.params.effect] && x.effects[x.params.effect].setTransition(e), x.params.parallax && x.parallax && x.parallax.setTransition(e), x.params.scrollbar && x.scrollbar && x.scrollbar.setTransition(e), x.params.control && x.controller && x.controller.setTransition(e, a), x.emit("onSetTransition", x, e) }, x.setWrapperTranslate = function(e, a, t) {
                var s = 0,
                    i = 0;
                x.isHorizontal() ? s = x.rtl ? -e : e : i = e, x.params.roundLengths && (s = r(s), i = r(i)), x.params.virtualTranslate || (x.support.transforms3d ? x.wrapper.transform("translate3d(" + s + "px, " + i + "px, 0px)") : x.wrapper.transform("translate(" + s + "px, " + i + "px)")), x.translate = x.isHorizontal() ? s : i;
                var n, o = x.maxTranslate() - x.minTranslate();
                n = 0 === o ? 0 : (e - x.minTranslate()) / o, n !== x.progress && x.updateProgress(e), a && x.updateActiveIndex(), "slide" !== x.params.effect && x.effects[x.params.effect] && x.effects[x.params.effect].setTranslate(x.translate), x.params.parallax && x.parallax && x.parallax.setTranslate(x.translate), x.params.scrollbar && x.scrollbar && x.scrollbar.setTranslate(x.translate), x.params.control && x.controller && x.controller.setTranslate(x.translate, t), x.emit("onSetTranslate", x, x.translate)
            }, x.getTranslate = function(e, a) { var t, s, r, i; return void 0 === a && (a = "x"), x.params.virtualTranslate ? x.rtl ? -x.translate : x.translate : (r = window.getComputedStyle(e, null), window.WebKitCSSMatrix ? (s = r.transform || r.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(function(e) { return e.replace(",", ".") }).join(", ")), i = new window.WebKitCSSMatrix("none" === s ? "" : s)) : (i = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), t = i.toString().split(",")), "x" === a && (s = window.WebKitCSSMatrix ? i.m41 : 16 === t.length ? parseFloat(t[12]) : parseFloat(t[4])), "y" === a && (s = window.WebKitCSSMatrix ? i.m42 : 16 === t.length ? parseFloat(t[13]) : parseFloat(t[5])), x.rtl && s && (s = -s), s || 0) }, x.getWrapperTranslate = function(e) { return void 0 === e && (e = x.isHorizontal() ? "x" : "y"), x.getTranslate(x.wrapper[0], e) }, x.observers = [], x.initObservers = function() {
                if (x.params.observeParents)
                    for (var e = x.container.parents(), a = 0; a < e.length; a++) o(e[a]);
                o(x.container[0], { childList: !1 }), o(x.wrapper[0], { attributes: !1 })
            }, x.disconnectObservers = function() {
                for (var e = 0; e < x.observers.length; e++) x.observers[e].disconnect();
                x.observers = []
            }, x.createLoop = function() {
                x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass).remove();
                var a = x.wrapper.children("." + x.params.slideClass);
                "auto" !== x.params.slidesPerView || x.params.loopedSlides || (x.params.loopedSlides = a.length), x.loopedSlides = parseInt(x.params.loopedSlides || x.params.slidesPerView, 10), x.loopedSlides = x.loopedSlides + x.params.loopAdditionalSlides, x.loopedSlides > a.length && (x.loopedSlides = a.length);
                var t, s = [],
                    r = [];
                for (a.each(function(t, i) {
                        var n = e(this);
                        t < x.loopedSlides && r.push(i), t < a.length && t >= a.length - x.loopedSlides && s.push(i), n.attr("data-swiper-slide-index", t)
                    }), t = 0; t < r.length; t++) x.wrapper.append(e(r[t].cloneNode(!0)).addClass(x.params.slideDuplicateClass));
                for (t = s.length - 1; t >= 0; t--) x.wrapper.prepend(e(s[t].cloneNode(!0)).addClass(x.params.slideDuplicateClass))
            }, x.destroyLoop = function() { x.wrapper.children("." + x.params.slideClass + "." + x.params.slideDuplicateClass).remove(), x.slides.removeAttr("data-swiper-slide-index") }, x.reLoop = function(e) {
                var a = x.activeIndex - x.loopedSlides;
                x.destroyLoop(), x.createLoop(), x.updateSlidesSize(), e && x.slideTo(a + x.loopedSlides, 0, !1)
            }, x.fixLoop = function() {
                var e;
                x.activeIndex < x.loopedSlides ? (e = x.slides.length - 3 * x.loopedSlides + x.activeIndex, e += x.loopedSlides, x.slideTo(e, 0, !1, !0)) : ("auto" === x.params.slidesPerView && x.activeIndex >= 2 * x.loopedSlides || x.activeIndex > x.slides.length - 2 * x.params.slidesPerView) && (e = -x.slides.length + x.activeIndex + x.loopedSlides, e += x.loopedSlides, x.slideTo(e, 0, !1, !0))
            }, x.appendSlide = function(e) {
                if (x.params.loop && x.destroyLoop(), "object" == typeof e && e.length)
                    for (var a = 0; a < e.length; a++) e[a] && x.wrapper.append(e[a]);
                else x.wrapper.append(e);
                x.params.loop && x.createLoop(), x.params.observer && x.support.observer || x.update(!0)
            }, x.prependSlide = function(e) {
                x.params.loop && x.destroyLoop();
                var a = x.activeIndex + 1;
                if ("object" == typeof e && e.length) {
                    for (var t = 0; t < e.length; t++) e[t] && x.wrapper.prepend(e[t]);
                    a = x.activeIndex + e.length
                } else x.wrapper.prepend(e);
                x.params.loop && x.createLoop(), x.params.observer && x.support.observer || x.update(!0), x.slideTo(a, 0, !1)
            }, x.removeSlide = function(e) {
                x.params.loop && (x.destroyLoop(), x.slides = x.wrapper.children("." + x.params.slideClass));
                var a, t = x.activeIndex;
                if ("object" == typeof e && e.length) {
                    for (var s = 0; s < e.length; s++) a = e[s], x.slides[a] && x.slides.eq(a).remove(), a < t && t--;
                    t = Math.max(t, 0)
                } else a = e, x.slides[a] && x.slides.eq(a).remove(), a < t && t--, t = Math.max(t, 0);
                x.params.loop && x.createLoop(), x.params.observer && x.support.observer || x.update(!0), x.params.loop ? x.slideTo(t + x.loopedSlides, 0, !1) : x.slideTo(t, 0, !1)
            }, x.removeAllSlides = function() {
                for (var e = [], a = 0; a < x.slides.length; a++) e.push(a);
                x.removeSlide(e)
            }, x.effects = {
                fade: {
                    setTranslate: function() {
                        for (var e = 0; e < x.slides.length; e++) {
                            var a = x.slides.eq(e),
                                t = a[0].swiperSlideOffset,
                                s = -t;
                            x.params.virtualTranslate || (s -= x.translate);
                            var r = 0;
                            x.isHorizontal() || (r = s, s = 0);
                            var i = x.params.fade.crossFade ? Math.max(1 - Math.abs(a[0].progress), 0) : 1 + Math.min(Math.max(a[0].progress, -1), 0);
                            a.css({ opacity: i }).transform("translate3d(" + s + "px, " + r + "px, 0px)")
                        }
                    },
                    setTransition: function(e) {
                        if (x.slides.transition(e), x.params.virtualTranslate && 0 !== e) {
                            var a = !1;
                            x.slides.transitionEnd(function() { if (!a && x) { a = !0, x.animating = !1; for (var e = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"], t = 0; t < e.length; t++) x.wrapper.trigger(e[t]) } })
                        }
                    }
                },
                flip: {
                    setTranslate: function() {
                        for (var a = 0; a < x.slides.length; a++) {
                            var t = x.slides.eq(a),
                                s = t[0].progress;
                            x.params.flip.limitRotation && (s = Math.max(Math.min(t[0].progress, 1), -1));
                            var r = t[0].swiperSlideOffset,
                                i = -180 * s,
                                n = i,
                                o = 0,
                                l = -r,
                                p = 0;
                            if (x.isHorizontal() ? x.rtl && (n = -n) : (p = l, l = 0, o = -n, n = 0), t[0].style.zIndex = -Math.abs(Math.round(s)) + x.slides.length, x.params.flip.slideShadows) {
                                var d = x.isHorizontal() ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                                    m = x.isHorizontal() ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                                0 === d.length && (d = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "left" : "top") + '"></div>'), t.append(d)), 0 === m.length && (m = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "right" : "bottom") + '"></div>'), t.append(m)), d.length && (d[0].style.opacity = Math.max(-s, 0)), m.length && (m[0].style.opacity = Math.max(s, 0))
                            }
                            t.transform("translate3d(" + l + "px, " + p + "px, 0px) rotateX(" + o + "deg) rotateY(" + n + "deg)")
                        }
                    },
                    setTransition: function(a) {
                        if (x.slides.transition(a).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(a), x.params.virtualTranslate && 0 !== a) {
                            var t = !1;
                            x.slides.eq(x.activeIndex).transitionEnd(function() { if (!t && x && e(this).hasClass(x.params.slideActiveClass)) { t = !0, x.animating = !1; for (var a = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"], s = 0; s < a.length; s++) x.wrapper.trigger(a[s]) } })
                        }
                    }
                },
                cube: {
                    setTranslate: function() {
                        var a, t = 0;
                        x.params.cube.shadow && (x.isHorizontal() ? (a = x.wrapper.find(".swiper-cube-shadow"), 0 === a.length && (a = e('<div class="swiper-cube-shadow"></div>'), x.wrapper.append(a)), a.css({ height: x.width + "px" })) : (a = x.container.find(".swiper-cube-shadow"), 0 === a.length && (a = e('<div class="swiper-cube-shadow"></div>'), x.container.append(a))));
                        for (var s = 0; s < x.slides.length; s++) {
                            var r = x.slides.eq(s),
                                i = 90 * s,
                                n = Math.floor(i / 360);
                            x.rtl && (i = -i, n = Math.floor(-i / 360));
                            var o = Math.max(Math.min(r[0].progress, 1), -1),
                                l = 0,
                                p = 0,
                                d = 0;
                            s % 4 == 0 ? (l = 4 * -n * x.size, d = 0) : (s - 1) % 4 == 0 ? (l = 0, d = 4 * -n * x.size) : (s - 2) % 4 == 0 ? (l = x.size + 4 * n * x.size, d = x.size) : (s - 3) % 4 == 0 && (l = -x.size, d = 3 * x.size + 4 * x.size * n), x.rtl && (l = -l), x.isHorizontal() || (p = l, l = 0);
                            var m = "rotateX(" + (x.isHorizontal() ? 0 : -i) + "deg) rotateY(" + (x.isHorizontal() ? i : 0) + "deg) translate3d(" + l + "px, " + p + "px, " + d + "px)";
                            if (o <= 1 && o > -1 && (t = 90 * s + 90 * o, x.rtl && (t = 90 * -s - 90 * o)), r.transform(m), x.params.cube.slideShadows) {
                                var u = x.isHorizontal() ? r.find(".swiper-slide-shadow-left") : r.find(".swiper-slide-shadow-top"),
                                    c = x.isHorizontal() ? r.find(".swiper-slide-shadow-right") : r.find(".swiper-slide-shadow-bottom");
                                0 === u.length && (u = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "left" : "top") + '"></div>'), r.append(u)), 0 === c.length && (c = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "right" : "bottom") + '"></div>'), r.append(c)), u.length && (u[0].style.opacity = Math.max(-o, 0)), c.length && (c[0].style.opacity = Math.max(o, 0))
                            }
                        }
                        if (x.wrapper.css({ "-webkit-transform-origin": "50% 50% -" + x.size / 2 + "px", "-moz-transform-origin": "50% 50% -" + x.size / 2 + "px", "-ms-transform-origin": "50% 50% -" + x.size / 2 + "px", "transform-origin": "50% 50% -" + x.size / 2 + "px" }), x.params.cube.shadow)
                            if (x.isHorizontal()) a.transform("translate3d(0px, " + (x.width / 2 + x.params.cube.shadowOffset) + "px, " + -x.width / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + x.params.cube.shadowScale + ")");
                            else {
                                var g = Math.abs(t) - 90 * Math.floor(Math.abs(t) / 90),
                                    h = 1.5 - (Math.sin(2 * g * Math.PI / 360) / 2 + Math.cos(2 * g * Math.PI / 360) / 2),
                                    v = x.params.cube.shadowScale,
                                    f = x.params.cube.shadowScale / h,
                                    w = x.params.cube.shadowOffset;
                                a.transform("scale3d(" + v + ", 1, " + f + ") translate3d(0px, " + (x.height / 2 + w) + "px, " + -x.height / 2 / f + "px) rotateX(-90deg)")
                            }
                        var y = x.isSafari || x.isUiWebView ? -x.size / 2 : 0;
                        x.wrapper.transform("translate3d(0px,0," + y + "px) rotateX(" + (x.isHorizontal() ? 0 : t) + "deg) rotateY(" + (x.isHorizontal() ? -t : 0) + "deg)")
                    },
                    setTransition: function(e) { x.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), x.params.cube.shadow && !x.isHorizontal() && x.container.find(".swiper-cube-shadow").transition(e) }
                },
                coverflow: {
                    setTranslate: function() {
                        for (var a = x.translate, t = x.isHorizontal() ? -a + x.width / 2 : -a + x.height / 2, s = x.isHorizontal() ? x.params.coverflow.rotate : -x.params.coverflow.rotate, r = x.params.coverflow.depth, i = 0, n = x.slides.length; i < n; i++) {
                            var o = x.slides.eq(i),
                                l = x.slidesSizesGrid[i],
                                p = o[0].swiperSlideOffset,
                                d = (t - p - l / 2) / l * x.params.coverflow.modifier,
                                m = x.isHorizontal() ? s * d : 0,
                                u = x.isHorizontal() ? 0 : s * d,
                                c = -r * Math.abs(d),
                                g = x.isHorizontal() ? 0 : x.params.coverflow.stretch * d,
                                h = x.isHorizontal() ? x.params.coverflow.stretch * d : 0;
                            Math.abs(h) < .001 && (h = 0), Math.abs(g) < .001 && (g = 0), Math.abs(c) < .001 && (c = 0), Math.abs(m) < .001 && (m = 0), Math.abs(u) < .001 && (u = 0);
                            var v = "translate3d(" + h + "px," + g + "px," + c + "px)  rotateX(" + u + "deg) rotateY(" + m + "deg)";
                            if (o.transform(v), o[0].style.zIndex = 1 - Math.abs(Math.round(d)), x.params.coverflow.slideShadows) {
                                var f = x.isHorizontal() ? o.find(".swiper-slide-shadow-left") : o.find(".swiper-slide-shadow-top"),
                                    w = x.isHorizontal() ? o.find(".swiper-slide-shadow-right") : o.find(".swiper-slide-shadow-bottom");
                                0 === f.length && (f = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "left" : "top") + '"></div>'), o.append(f)), 0 === w.length && (w = e('<div class="swiper-slide-shadow-' + (x.isHorizontal() ? "right" : "bottom") + '"></div>'), o.append(w)), f.length && (f[0].style.opacity = d > 0 ? d : 0), w.length && (w[0].style.opacity = -d > 0 ? -d : 0)
                            }
                        }
                        if (x.browser.ie) { x.wrapper[0].style.perspectiveOrigin = t + "px 50%" }
                    },
                    setTransition: function(e) { x.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e) }
                }
            }, x.lazy = {
                initialImageLoaded: !1,
                loadImageInSlide: function(a, t) {
                    if (void 0 !== a && (void 0 === t && (t = !0), 0 !== x.slides.length)) {
                        var s = x.slides.eq(a),
                            r = s.find("." + x.params.lazyLoadingClass + ":not(." + x.params.lazyStatusLoadedClass + "):not(." + x.params.lazyStatusLoadingClass + ")");
                        !s.hasClass(x.params.lazyLoadingClass) || s.hasClass(x.params.lazyStatusLoadedClass) || s.hasClass(x.params.lazyStatusLoadingClass) || (r = r.add(s[0])), 0 !== r.length && r.each(function() {
                            var a = e(this);
                            a.addClass(x.params.lazyStatusLoadingClass);
                            var r = a.attr("data-background"),
                                i = a.attr("data-src"),
                                n = a.attr("data-srcset"),
                                o = a.attr("data-sizes");
                            x.loadImage(a[0], i || r, n, o, !1, function() {
                                if (void 0 !== x && null !== x && x) {
                                    if (r ? (a.css("background-image", 'url("' + r + '")'), a.removeAttr("data-background")) : (n && (a.attr("srcset", n), a.removeAttr("data-srcset")), o && (a.attr("sizes", o), a.removeAttr("data-sizes")), i && (a.attr("src", i), a.removeAttr("data-src"))), a.addClass(x.params.lazyStatusLoadedClass).removeClass(x.params.lazyStatusLoadingClass), s.find("." + x.params.lazyPreloaderClass + ", ." + x.params.preloaderClass).remove(), x.params.loop && t) {
                                        var e = s.attr("data-swiper-slide-index");
                                        if (s.hasClass(x.params.slideDuplicateClass)) {
                                            var l = x.wrapper.children('[data-swiper-slide-index="' + e + '"]:not(.' + x.params.slideDuplicateClass + ")");
                                            x.lazy.loadImageInSlide(l.index(), !1)
                                        } else {
                                            var p = x.wrapper.children("." + x.params.slideDuplicateClass + '[data-swiper-slide-index="' + e + '"]');
                                            x.lazy.loadImageInSlide(p.index(), !1)
                                        }
                                    }
                                    x.emit("onLazyImageReady", x, s[0], a[0])
                                }
                            }), x.emit("onLazyImageLoad", x, s[0], a[0])
                        })
                    }
                },
                load: function() {
                    var a, t = x.params.slidesPerView;
                    if ("auto" === t && (t = 0), x.lazy.initialImageLoaded || (x.lazy.initialImageLoaded = !0), x.params.watchSlidesVisibility) x.wrapper.children("." + x.params.slideVisibleClass).each(function() { x.lazy.loadImageInSlide(e(this).index()) });
                    else if (t > 1)
                        for (a = x.activeIndex; a < x.activeIndex + t; a++) x.slides[a] && x.lazy.loadImageInSlide(a);
                    else x.lazy.loadImageInSlide(x.activeIndex);
                    if (x.params.lazyLoadingInPrevNext)
                        if (t > 1 || x.params.lazyLoadingInPrevNextAmount && x.params.lazyLoadingInPrevNextAmount > 1) {
                            var s = x.params.lazyLoadingInPrevNextAmount,
                                r = t,
                                i = Math.min(x.activeIndex + r + Math.max(s, r), x.slides.length),
                                n = Math.max(x.activeIndex - Math.max(r, s), 0);
                            for (a = x.activeIndex + t; a < i; a++) x.slides[a] && x.lazy.loadImageInSlide(a);
                            for (a = n; a < x.activeIndex; a++) x.slides[a] && x.lazy.loadImageInSlide(a)
                        } else {
                            var o = x.wrapper.children("." + x.params.slideNextClass);
                            o.length > 0 && x.lazy.loadImageInSlide(o.index());
                            var l = x.wrapper.children("." + x.params.slidePrevClass);
                            l.length > 0 && x.lazy.loadImageInSlide(l.index())
                        }
                },
                onTransitionStart: function() { x.params.lazyLoading && (x.params.lazyLoadingOnTransitionStart || !x.params.lazyLoadingOnTransitionStart && !x.lazy.initialImageLoaded) && x.lazy.load() },
                onTransitionEnd: function() { x.params.lazyLoading && !x.params.lazyLoadingOnTransitionStart && x.lazy.load() }
            }, x.scrollbar = {
                isTouched: !1,
                setDragPosition: function(e) {
                    var a = x.scrollbar,
                        t = x.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX || e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY || e.clientY,
                        s = t - a.track.offset()[x.isHorizontal() ? "left" : "top"] - a.dragSize / 2,
                        r = -x.minTranslate() * a.moveDivider,
                        i = -x.maxTranslate() * a.moveDivider;
                    s < r ? s = r : s > i && (s = i), s = -s / a.moveDivider, x.updateProgress(s), x.setWrapperTranslate(s, !0)
                },
                dragStart: function(e) {
                    var a = x.scrollbar;
                    a.isTouched = !0, e.preventDefault(), e.stopPropagation(), a.setDragPosition(e), clearTimeout(a.dragTimeout), a.track.transition(0), x.params.scrollbarHide && a.track.css("opacity", 1), x.wrapper.transition(100), a.drag.transition(100), x.emit("onScrollbarDragStart", x)
                },
                dragMove: function(e) {
                    var a = x.scrollbar;
                    a.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, a.setDragPosition(e), x.wrapper.transition(0), a.track.transition(0), a.drag.transition(0), x.emit("onScrollbarDragMove", x))
                },
                dragEnd: function(e) {
                    var a = x.scrollbar;
                    a.isTouched && (a.isTouched = !1, x.params.scrollbarHide && (clearTimeout(a.dragTimeout), a.dragTimeout = setTimeout(function() { a.track.css("opacity", 0), a.track.transition(400) }, 1e3)), x.emit("onScrollbarDragEnd", x), x.params.scrollbarSnapOnRelease && x.slideReset())
                },
                draggableEvents: function() { return x.params.simulateTouch !== !1 || x.support.touch ? x.touchEvents : x.touchEventsDesktop }(),
                enableDraggable: function() {
                    var a = x.scrollbar,
                        t = x.support.touch ? a.track : document;
                    e(a.track).on(a.draggableEvents.start, a.dragStart), e(t).on(a.draggableEvents.move, a.dragMove), e(t).on(a.draggableEvents.end, a.dragEnd)
                },
                disableDraggable: function() {
                    var a = x.scrollbar,
                        t = x.support.touch ? a.track : document;
                    e(a.track).off(a.draggableEvents.start, a.dragStart), e(t).off(a.draggableEvents.move, a.dragMove), e(t).off(a.draggableEvents.end, a.dragEnd)
                },
                set: function() {
                    if (x.params.scrollbar) {
                        var a = x.scrollbar;
                        a.track = e(x.params.scrollbar), x.params.uniqueNavElements && "string" == typeof x.params.scrollbar && a.track.length > 1 && 1 === x.container.find(x.params.scrollbar).length && (a.track = x.container.find(x.params.scrollbar)), a.drag = a.track.find(".swiper-scrollbar-drag"), 0 === a.drag.length && (a.drag = e('<div class="swiper-scrollbar-drag"></div>'), a.track.append(a.drag)), a.drag[0].style.width = "", a.drag[0].style.height = "", a.trackSize = x.isHorizontal() ? a.track[0].offsetWidth : a.track[0].offsetHeight, a.divider = x.size / x.virtualSize, a.moveDivider = a.divider * (a.trackSize / x.size), a.dragSize = a.trackSize * a.divider, x.isHorizontal() ? a.drag[0].style.width = a.dragSize + "px" : a.drag[0].style.height = a.dragSize + "px", a.divider >= 1 ? a.track[0].style.display = "none" : a.track[0].style.display = "", x.params.scrollbarHide && (a.track[0].style.opacity = 0)
                    }
                },
                setTranslate: function() {
                    if (x.params.scrollbar) {
                        var e, a = x.scrollbar,
                            t = (x.translate, a.dragSize);
                        e = (a.trackSize - a.dragSize) * x.progress, x.rtl && x.isHorizontal() ? (e = -e, e > 0 ? (t = a.dragSize - e, e = 0) : -e + a.dragSize > a.trackSize && (t = a.trackSize + e)) : e < 0 ? (t = a.dragSize + e, e = 0) : e + a.dragSize > a.trackSize && (t = a.trackSize - e), x.isHorizontal() ? (x.support.transforms3d ? a.drag.transform("translate3d(" + e + "px, 0, 0)") : a.drag.transform("translateX(" + e + "px)"), a.drag[0].style.width = t + "px") : (x.support.transforms3d ? a.drag.transform("translate3d(0px, " + e + "px, 0)") : a.drag.transform("translateY(" + e + "px)"), a.drag[0].style.height = t + "px"), x.params.scrollbarHide && (clearTimeout(a.timeout), a.track[0].style.opacity = 1, a.timeout = setTimeout(function() { a.track[0].style.opacity = 0, a.track.transition(400) }, 1e3))
                    }
                },
                setTransition: function(e) { x.params.scrollbar && x.scrollbar.drag.transition(e) }
            }, x.controller = {
                LinearSpline: function(e, a) {
                    var t = function() { var e, a, t; return function(s, r) { for (a = -1, e = s.length; e - a > 1;) s[t = e + a >> 1] <= r ? a = t : e = t; return e } }();
                    this.x = e, this.y = a, this.lastIndex = e.length - 1;
                    var s, r;
                    this.x.length;
                    this.interpolate = function(e) { return e ? (r = t(this.x, e), s = r - 1, (e - this.x[s]) * (this.y[r] - this.y[s]) / (this.x[r] - this.x[s]) + this.y[s]) : 0 }
                },
                getInterpolateFunction: function(e) { x.controller.spline || (x.controller.spline = x.params.loop ? new x.controller.LinearSpline(x.slidesGrid, e.slidesGrid) : new x.controller.LinearSpline(x.snapGrid, e.snapGrid)) },
                setTranslate: function(e, t) {
                    function s(a) { e = a.rtl && "horizontal" === a.params.direction ? -x.translate : x.translate, "slide" === x.params.controlBy && (x.controller.getInterpolateFunction(a), i = -x.controller.spline.interpolate(-e)), i && "container" !== x.params.controlBy || (r = (a.maxTranslate() - a.minTranslate()) / (x.maxTranslate() - x.minTranslate()), i = (e - x.minTranslate()) * r + a.minTranslate()), x.params.controlInverse && (i = a.maxTranslate() - i), a.updateProgress(i), a.setWrapperTranslate(i, !1, x), a.updateActiveIndex() }
                    var r, i, n = x.params.control;
                    if (Array.isArray(n))
                        for (var o = 0; o < n.length; o++) n[o] !== t && n[o] instanceof a && s(n[o]);
                    else n instanceof a && t !== n && s(n)
                },
                setTransition: function(e, t) {
                    function s(a) { a.setWrapperTransition(e, x), 0 !== e && (a.onTransitionStart(), a.wrapper.transitionEnd(function() { i && (a.params.loop && "slide" === x.params.controlBy && a.fixLoop(), a.onTransitionEnd()) })) }
                    var r, i = x.params.control;
                    if (Array.isArray(i))
                        for (r = 0; r < i.length; r++) i[r] !== t && i[r] instanceof a && s(i[r]);
                    else i instanceof a && t !== i && s(i)
                }
            }, x.hashnav = {
                onHashCange: function(e, a) {
                    var t = document.location.hash.replace("#", "");
                    t !== x.slides.eq(x.activeIndex).attr("data-hash") && x.slideTo(x.wrapper.children("." + x.params.slideClass + '[data-hash="' + t + '"]').index())
                },
                attachEvents: function(a) {
                    var t = a ? "off" : "on";
                    e(window)[t]("hashchange", x.hashnav.onHashCange)
                },
                setHash: function() {
                    if (x.hashnav.initialized && x.params.hashnav)
                        if (x.params.replaceState && window.history && window.history.replaceState) window.history.replaceState(null, null, "#" + x.slides.eq(x.activeIndex).attr("data-hash") || "");
                        else {
                            var e = x.slides.eq(x.activeIndex),
                                a = e.attr("data-hash") || e.attr("data-history");
                            document.location.hash = a || ""
                        }
                },
                init: function() {
                    if (x.params.hashnav && !x.params.history) {
                        x.hashnav.initialized = !0;
                        var e = document.location.hash.replace("#", "");
                        if (e)
                            for (var a = 0, t = x.slides.length; a < t; a++) {
                                var s = x.slides.eq(a),
                                    r = s.attr("data-hash") || s.attr("data-history");
                                if (r === e && !s.hasClass(x.params.slideDuplicateClass)) {
                                    var i = s.index();
                                    x.slideTo(i, 0, x.params.runCallbacksOnInit, !0)
                                }
                            }
                        x.params.hashnavWatchState && x.hashnav.attachEvents()
                    }
                },
                destroy: function() { x.params.hashnavWatchState && x.hashnav.attachEvents(!0) }
            }, x.history = {
                init: function() {
                    if (x.params.history) {
                        if (!window.history || !window.history.pushState) return x.params.history = !1, void(x.params.hashnav = !0);
                        x.history.initialized = !0, this.paths = this.getPathValues(), (this.paths.key || this.paths.value) && (this.scrollToSlide(0, this.paths.value, x.params.runCallbacksOnInit), x.params.replaceState || window.addEventListener("popstate", this.setHistoryPopState))
                    }
                },
                setHistoryPopState: function() { x.history.paths = x.history.getPathValues(), x.history.scrollToSlide(x.params.speed, x.history.paths.value, !1) },
                getPathValues: function() {
                    var e = window.location.pathname.slice(1).split("/"),
                        a = e.length;
                    return { key: e[a - 2], value: e[a - 1] }
                },
                setHistory: function(e, a) {
                    if (x.history.initialized && x.params.history) {
                        var t = x.slides.eq(a),
                            s = this.slugify(t.attr("data-history"));
                        window.location.pathname.includes(e) || (s = e + "/" + s), x.params.replaceState ? window.history.replaceState(null, null, s) : window.history.pushState(null, null, s)
                    }
                },
                slugify: function(e) { return e.toString().toLowerCase().replace(/\s+/g, "-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "") },
                scrollToSlide: function(e, a, t) {
                    if (a)
                        for (var s = 0, r = x.slides.length; s < r; s++) {
                            var i = x.slides.eq(s),
                                n = this.slugify(i.attr("data-history"));
                            if (n === a && !i.hasClass(x.params.slideDuplicateClass)) {
                                var o = i.index();
                                x.slideTo(o, e, t)
                            }
                        } else x.slideTo(0, e, t)
                }
            }, x.disableKeyboardControl = function() { x.params.keyboardControl = !1, e(document).off("keydown", l) }, x.enableKeyboardControl = function() { x.params.keyboardControl = !0, e(document).on("keydown", l) }, x.mousewheel = { event: !1, lastScrollTime: (new window.Date).getTime() }, x.params.mousewheelControl && (x.mousewheel.event = navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : function() {
                var e = "onwheel" in document;
                if (!e) {
                    var a = document.createElement("div");
                    a.setAttribute("onwheel", "return;"), e = "function" == typeof a.onwheel
                }
                return !e && document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0 && (e = document.implementation.hasFeature("Events.wheel", "3.0")), e
            }() ? "wheel" : "mousewheel"), x.disableMousewheelControl = function() { if (!x.mousewheel.event) return !1; var a = x.container; return "container" !== x.params.mousewheelEventsTarged && (a = e(x.params.mousewheelEventsTarged)), a.off(x.mousewheel.event, d), x.params.mousewheelControl = !1, !0 }, x.enableMousewheelControl = function() { if (!x.mousewheel.event) return !1; var a = x.container; return "container" !== x.params.mousewheelEventsTarged && (a = e(x.params.mousewheelEventsTarged)), a.on(x.mousewheel.event, d), x.params.mousewheelControl = !0, !0 }, x.parallax = {
                setTranslate: function() {
                    x.container.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() { m(this, x.progress) }), x.slides.each(function() {
                        var a = e(this);
                        a.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() { m(this, Math.min(Math.max(a[0].progress, -1), 1)) })
                    })
                },
                setTransition: function(a) {
                    void 0 === a && (a = x.params.speed), x.container.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() {
                        var t = e(this),
                            s = parseInt(t.attr("data-swiper-parallax-duration"), 10) || a;
                        0 === a && (s = 0), t.transition(s)
                    })
                }
            }, x.zoom = {
                scale: 1,
                currentScale: 1,
                isScaling: !1,
                gesture: { slide: void 0, slideWidth: void 0, slideHeight: void 0, image: void 0, imageWrap: void 0, zoomMax: x.params.zoomMax },
                image: { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} },
                velocity: { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 },
                getDistanceBetweenTouches: function(e) {
                    if (e.targetTouches.length < 2) return 1;
                    var a = e.targetTouches[0].pageX,
                        t = e.targetTouches[0].pageY,
                        s = e.targetTouches[1].pageX,
                        r = e.targetTouches[1].pageY;
                    return Math.sqrt(Math.pow(s - a, 2) + Math.pow(r - t, 2))
                },
                onGestureStart: function(a) {
                    var t = x.zoom;
                    if (!x.support.gestures) {
                        if ("touchstart" !== a.type || "touchstart" === a.type && a.targetTouches.length < 2) return;
                        t.gesture.scaleStart = t.getDistanceBetweenTouches(a)
                    }
                    if (!(t.gesture.slide && t.gesture.slide.length || (t.gesture.slide = e(this), 0 === t.gesture.slide.length && (t.gesture.slide = x.slides.eq(x.activeIndex)), t.gesture.image = t.gesture.slide.find("img, svg, canvas"), t.gesture.imageWrap = t.gesture.image.parent("." + x.params.zoomContainerClass), t.gesture.zoomMax = t.gesture.imageWrap.attr("data-swiper-zoom") || x.params.zoomMax, 0 !== t.gesture.imageWrap.length))) return void(t.gesture.image = void 0);
                    t.gesture.image.transition(0), t.isScaling = !0
                },
                onGestureChange: function(e) {
                    var a = x.zoom;
                    if (!x.support.gestures) {
                        if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
                        a.gesture.scaleMove = a.getDistanceBetweenTouches(e)
                    }
                    a.gesture.image && 0 !== a.gesture.image.length && (x.support.gestures ? a.scale = e.scale * a.currentScale : a.scale = a.gesture.scaleMove / a.gesture.scaleStart * a.currentScale, a.scale > a.gesture.zoomMax && (a.scale = a.gesture.zoomMax - 1 + Math.pow(a.scale - a.gesture.zoomMax + 1, .5)), a.scale < x.params.zoomMin && (a.scale = x.params.zoomMin + 1 - Math.pow(x.params.zoomMin - a.scale + 1, .5)), a.gesture.image.transform("translate3d(0,0,0) scale(" + a.scale + ")"))
                },
                onGestureEnd: function(e) { var a = x.zoom;!x.support.gestures && ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2) || a.gesture.image && 0 !== a.gesture.image.length && (a.scale = Math.max(Math.min(a.scale, a.gesture.zoomMax), x.params.zoomMin), a.gesture.image.transition(x.params.speed).transform("translate3d(0,0,0) scale(" + a.scale + ")"), a.currentScale = a.scale, a.isScaling = !1, 1 === a.scale && (a.gesture.slide = void 0)) },
                onTouchStart: function(e, a) {
                    var t = e.zoom;
                    t.gesture.image && 0 !== t.gesture.image.length && (t.image.isTouched || ("android" === e.device.os && a.preventDefault(), t.image.isTouched = !0, t.image.touchesStart.x = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX, t.image.touchesStart.y = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY))
                },
                onTouchMove: function(e) {
                    var a = x.zoom;
                    if (a.gesture.image && 0 !== a.gesture.image.length && (x.allowClick = !1, a.image.isTouched && a.gesture.slide)) {
                        a.image.isMoved || (a.image.width = a.gesture.image[0].offsetWidth, a.image.height = a.gesture.image[0].offsetHeight, a.image.startX = x.getTranslate(a.gesture.imageWrap[0], "x") || 0, a.image.startY = x.getTranslate(a.gesture.imageWrap[0], "y") || 0, a.gesture.slideWidth = a.gesture.slide[0].offsetWidth, a.gesture.slideHeight = a.gesture.slide[0].offsetHeight, a.gesture.imageWrap.transition(0), x.rtl && (a.image.startX = -a.image.startX), x.rtl && (a.image.startY = -a.image.startY));
                        var t = a.image.width * a.scale,
                            s = a.image.height * a.scale;
                        if (!(t < a.gesture.slideWidth && s < a.gesture.slideHeight)) {
                            if (a.image.minX = Math.min(a.gesture.slideWidth / 2 - t / 2, 0), a.image.maxX = -a.image.minX, a.image.minY = Math.min(a.gesture.slideHeight / 2 - s / 2, 0), a.image.maxY = -a.image.minY, a.image.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, a.image.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !a.image.isMoved && !a.isScaling) { if (x.isHorizontal() && Math.floor(a.image.minX) === Math.floor(a.image.startX) && a.image.touchesCurrent.x < a.image.touchesStart.x || Math.floor(a.image.maxX) === Math.floor(a.image.startX) && a.image.touchesCurrent.x > a.image.touchesStart.x) return void(a.image.isTouched = !1); if (!x.isHorizontal() && Math.floor(a.image.minY) === Math.floor(a.image.startY) && a.image.touchesCurrent.y < a.image.touchesStart.y || Math.floor(a.image.maxY) === Math.floor(a.image.startY) && a.image.touchesCurrent.y > a.image.touchesStart.y) return void(a.image.isTouched = !1) }
                            e.preventDefault(), e.stopPropagation(), a.image.isMoved = !0, a.image.currentX = a.image.touchesCurrent.x - a.image.touchesStart.x + a.image.startX, a.image.currentY = a.image.touchesCurrent.y - a.image.touchesStart.y + a.image.startY, a.image.currentX < a.image.minX && (a.image.currentX = a.image.minX + 1 - Math.pow(a.image.minX - a.image.currentX + 1, .8)), a.image.currentX > a.image.maxX && (a.image.currentX = a.image.maxX - 1 + Math.pow(a.image.currentX - a.image.maxX + 1, .8)), a.image.currentY < a.image.minY && (a.image.currentY = a.image.minY + 1 - Math.pow(a.image.minY - a.image.currentY + 1, .8)), a.image.currentY > a.image.maxY && (a.image.currentY = a.image.maxY - 1 + Math.pow(a.image.currentY - a.image.maxY + 1, .8)), a.velocity.prevPositionX || (a.velocity.prevPositionX = a.image.touchesCurrent.x), a.velocity.prevPositionY || (a.velocity.prevPositionY = a.image.touchesCurrent.y), a.velocity.prevTime || (a.velocity.prevTime = Date.now()), a.velocity.x = (a.image.touchesCurrent.x - a.velocity.prevPositionX) / (Date.now() - a.velocity.prevTime) / 2, a.velocity.y = (a.image.touchesCurrent.y - a.velocity.prevPositionY) / (Date.now() - a.velocity.prevTime) / 2, Math.abs(a.image.touchesCurrent.x - a.velocity.prevPositionX) < 2 && (a.velocity.x = 0), Math.abs(a.image.touchesCurrent.y - a.velocity.prevPositionY) < 2 && (a.velocity.y = 0), a.velocity.prevPositionX = a.image.touchesCurrent.x, a.velocity.prevPositionY = a.image.touchesCurrent.y, a.velocity.prevTime = Date.now(), a.gesture.imageWrap.transform("translate3d(" + a.image.currentX + "px, " + a.image.currentY + "px,0)")
                        }
                    }
                },
                onTouchEnd: function(e, a) {
                    var t = e.zoom;
                    if (t.gesture.image && 0 !== t.gesture.image.length) {
                        if (!t.image.isTouched || !t.image.isMoved) return t.image.isTouched = !1, void(t.image.isMoved = !1);
                        t.image.isTouched = !1, t.image.isMoved = !1;
                        var s = 300,
                            r = 300,
                            i = t.velocity.x * s,
                            n = t.image.currentX + i,
                            o = t.velocity.y * r,
                            l = t.image.currentY + o;
                        0 !== t.velocity.x && (s = Math.abs((n - t.image.currentX) / t.velocity.x)), 0 !== t.velocity.y && (r = Math.abs((l - t.image.currentY) / t.velocity.y));
                        var p = Math.max(s, r);
                        t.image.currentX = n, t.image.currentY = l;
                        var d = t.image.width * t.scale,
                            m = t.image.height * t.scale;
                        t.image.minX = Math.min(t.gesture.slideWidth / 2 - d / 2, 0), t.image.maxX = -t.image.minX, t.image.minY = Math.min(t.gesture.slideHeight / 2 - m / 2, 0), t.image.maxY = -t.image.minY, t.image.currentX = Math.max(Math.min(t.image.currentX, t.image.maxX), t.image.minX), t.image.currentY = Math.max(Math.min(t.image.currentY, t.image.maxY), t.image.minY), t.gesture.imageWrap.transition(p).transform("translate3d(" + t.image.currentX + "px, " + t.image.currentY + "px,0)")
                    }
                },
                onTransitionEnd: function(e) {
                    var a = e.zoom;
                    a.gesture.slide && e.previousIndex !== e.activeIndex && (a.gesture.image.transform("translate3d(0,0,0) scale(1)"), a.gesture.imageWrap.transform("translate3d(0,0,0)"), a.gesture.slide = a.gesture.image = a.gesture.imageWrap = void 0, a.scale = a.currentScale = 1)
                },
                toggleZoom: function(a, t) {
                    var s = a.zoom;
                    if (s.gesture.slide || (s.gesture.slide = a.clickedSlide ? e(a.clickedSlide) : a.slides.eq(a.activeIndex), s.gesture.image = s.gesture.slide.find("img, svg, canvas"), s.gesture.imageWrap = s.gesture.image.parent("." + a.params.zoomContainerClass)), s.gesture.image && 0 !== s.gesture.image.length) {
                        var r, i, n, o, l, p, d, m, u, c, g, h, v, f, w, y, x, T;
                        void 0 === s.image.touchesStart.x && t ? (r = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, i = "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (r = s.image.touchesStart.x, i = s.image.touchesStart.y), s.scale && 1 !== s.scale ? (s.scale = s.currentScale = 1, s.gesture.imageWrap.transition(300).transform("translate3d(0,0,0)"), s.gesture.image.transition(300).transform("translate3d(0,0,0) scale(1)"), s.gesture.slide = void 0) : (s.scale = s.currentScale = s.gesture.imageWrap.attr("data-swiper-zoom") || a.params.zoomMax, t ? (x = s.gesture.slide[0].offsetWidth, T = s.gesture.slide[0].offsetHeight, n = s.gesture.slide.offset().left, o = s.gesture.slide.offset().top, l = n + x / 2 - r, p = o + T / 2 - i, u = s.gesture.image[0].offsetWidth, c = s.gesture.image[0].offsetHeight, g = u * s.scale, h = c * s.scale, v = Math.min(x / 2 - g / 2, 0), f = Math.min(T / 2 - h / 2, 0), w = -v, y = -f, d = l * s.scale, m = p * s.scale, d < v && (d = v), d > w && (d = w), m < f && (m = f), m > y && (m = y)) : (d = 0, m = 0), s.gesture.imageWrap.transition(300).transform("translate3d(" + d + "px, " + m + "px,0)"), s.gesture.image.transition(300).transform("translate3d(0,0,0) scale(" + s.scale + ")"))
                    }
                },
                attachEvents: function(a) {
                    var t = a ? "off" : "on";
                    if (x.params.zoom) {
                        var s = (x.slides, !("touchstart" !== x.touchEvents.start || !x.support.passiveListener || !x.params.passiveListeners) && { passive: !0, capture: !1 });
                        x.support.gestures ? (x.slides[t]("gesturestart", x.zoom.onGestureStart, s), x.slides[t]("gesturechange", x.zoom.onGestureChange, s), x.slides[t]("gestureend", x.zoom.onGestureEnd, s)) : "touchstart" === x.touchEvents.start && (x.slides[t](x.touchEvents.start, x.zoom.onGestureStart, s), x.slides[t](x.touchEvents.move, x.zoom.onGestureChange, s), x.slides[t](x.touchEvents.end, x.zoom.onGestureEnd, s)), x[t]("touchStart", x.zoom.onTouchStart), x.slides.each(function(a, s) { e(s).find("." + x.params.zoomContainerClass).length > 0 && e(s)[t](x.touchEvents.move, x.zoom.onTouchMove) }), x[t]("touchEnd", x.zoom.onTouchEnd), x[t]("transitionEnd", x.zoom.onTransitionEnd), x.params.zoomToggle && x.on("doubleTap", x.zoom.toggleZoom)
                    }
                },
                init: function() { x.zoom.attachEvents() },
                destroy: function() { x.zoom.attachEvents(!0) }
            }, x._plugins = [];
            for (var Y in x.plugins) {
                var A = x.plugins[Y](x, x.params[Y]);
                A && x._plugins.push(A)
            }
            return x.callPlugins = function(e) { for (var a = 0; a < x._plugins.length; a++) e in x._plugins[a] && x._plugins[a][e](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]) }, x.emitterEventListeners = {}, x.emit = function(e) {
                x.params[e] && x.params[e](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                var a;
                if (x.emitterEventListeners[e])
                    for (a = 0; a < x.emitterEventListeners[e].length; a++) x.emitterEventListeners[e][a](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                x.callPlugins && x.callPlugins(e, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5])
            }, x.on = function(e, a) { return e = u(e), x.emitterEventListeners[e] || (x.emitterEventListeners[e] = []), x.emitterEventListeners[e].push(a), x }, x.off = function(e, a) { var t; if (e = u(e), void 0 === a) return x.emitterEventListeners[e] = [], x; if (x.emitterEventListeners[e] && 0 !== x.emitterEventListeners[e].length) { for (t = 0; t < x.emitterEventListeners[e].length; t++) x.emitterEventListeners[e][t] === a && x.emitterEventListeners[e].splice(t, 1); return x } }, x.once = function(e, a) { e = u(e); var t = function() { a(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]), x.off(e, t) }; return x.on(e, t), x }, x.a11y = {
                makeFocusable: function(e) { return e.attr("tabIndex", "0"), e },
                addRole: function(e, a) { return e.attr("role", a), e },
                addLabel: function(e, a) { return e.attr("aria-label", a), e },
                disable: function(e) { return e.attr("aria-disabled", !0), e },
                enable: function(e) { return e.attr("aria-disabled", !1), e },
                onEnterKey: function(a) { 13 === a.keyCode && (e(a.target).is(x.params.nextButton) ? (x.onClickNext(a), x.isEnd ? x.a11y.notify(x.params.lastSlideMessage) : x.a11y.notify(x.params.nextSlideMessage)) : e(a.target).is(x.params.prevButton) && (x.onClickPrev(a), x.isBeginning ? x.a11y.notify(x.params.firstSlideMessage) : x.a11y.notify(x.params.prevSlideMessage)), e(a.target).is("." + x.params.bulletClass) && e(a.target)[0].click()) },
                liveRegion: e('<span class="' + x.params.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>'),
                notify: function(e) {
                    var a = x.a11y.liveRegion;
                    0 !== a.length && (a.html(""), a.html(e))
                },
                init: function() { x.params.nextButton && x.nextButton && x.nextButton.length > 0 && (x.a11y.makeFocusable(x.nextButton), x.a11y.addRole(x.nextButton, "button"), x.a11y.addLabel(x.nextButton, x.params.nextSlideMessage)), x.params.prevButton && x.prevButton && x.prevButton.length > 0 && (x.a11y.makeFocusable(x.prevButton), x.a11y.addRole(x.prevButton, "button"), x.a11y.addLabel(x.prevButton, x.params.prevSlideMessage)), e(x.container).append(x.a11y.liveRegion) },
                initPagination: function() {
                    x.params.pagination && x.params.paginationClickable && x.bullets && x.bullets.length && x.bullets.each(function() {
                        var a = e(this);
                        x.a11y.makeFocusable(a), x.a11y.addRole(a, "button"), x.a11y.addLabel(a, x.params.paginationBulletMessage.replace(/{{index}}/, a.index() + 1))
                    })
                },
                destroy: function() { x.a11y.liveRegion && x.a11y.liveRegion.length > 0 && x.a11y.liveRegion.remove() }
            }, x.init = function() { x.params.loop && x.createLoop(), x.updateContainerSize(), x.updateSlidesSize(), x.updatePagination(), x.params.scrollbar && x.scrollbar && (x.scrollbar.set(), x.params.scrollbarDraggable && x.scrollbar.enableDraggable()), "slide" !== x.params.effect && x.effects[x.params.effect] && (x.params.loop || x.updateProgress(), x.effects[x.params.effect].setTranslate()), x.params.loop ? x.slideTo(x.params.initialSlide + x.loopedSlides, 0, x.params.runCallbacksOnInit) : (x.slideTo(x.params.initialSlide, 0, x.params.runCallbacksOnInit), 0 === x.params.initialSlide && (x.parallax && x.params.parallax && x.parallax.setTranslate(), x.lazy && x.params.lazyLoading && (x.lazy.load(), x.lazy.initialImageLoaded = !0))), x.attachEvents(), x.params.observer && x.support.observer && x.initObservers(), x.params.preloadImages && !x.params.lazyLoading && x.preloadImages(), x.params.zoom && x.zoom && x.zoom.init(), x.params.autoplay && x.startAutoplay(), x.params.keyboardControl && x.enableKeyboardControl && x.enableKeyboardControl(), x.params.mousewheelControl && x.enableMousewheelControl && x.enableMousewheelControl(), x.params.hashnavReplaceState && (x.params.replaceState = x.params.hashnavReplaceState), x.params.history && x.history && x.history.init(), x.params.hashnav && x.hashnav && x.hashnav.init(), x.params.a11y && x.a11y && x.a11y.init(), x.emit("onInit", x) }, x.cleanupStyles = function() { x.container.removeClass(x.classNames.join(" ")).removeAttr("style"), x.wrapper.removeAttr("style"), x.slides && x.slides.length && x.slides.removeClass([x.params.slideVisibleClass, x.params.slideActiveClass, x.params.slideNextClass, x.params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-column").removeAttr("data-swiper-row"), x.paginationContainer && x.paginationContainer.length && x.paginationContainer.removeClass(x.params.paginationHiddenClass), x.bullets && x.bullets.length && x.bullets.removeClass(x.params.bulletActiveClass), x.params.prevButton && e(x.params.prevButton).removeClass(x.params.buttonDisabledClass), x.params.nextButton && e(x.params.nextButton).removeClass(x.params.buttonDisabledClass), x.params.scrollbar && x.scrollbar && (x.scrollbar.track && x.scrollbar.track.length && x.scrollbar.track.removeAttr("style"), x.scrollbar.drag && x.scrollbar.drag.length && x.scrollbar.drag.removeAttr("style")) }, x.destroy = function(e, a) { x.detachEvents(), x.stopAutoplay(), x.params.scrollbar && x.scrollbar && x.params.scrollbarDraggable && x.scrollbar.disableDraggable(), x.params.loop && x.destroyLoop(), a && x.cleanupStyles(), x.disconnectObservers(), x.params.zoom && x.zoom && x.zoom.destroy(), x.params.keyboardControl && x.disableKeyboardControl && x.disableKeyboardControl(), x.params.mousewheelControl && x.disableMousewheelControl && x.disableMousewheelControl(), x.params.a11y && x.a11y && x.a11y.destroy(), x.params.history && !x.params.replaceState && window.removeEventListener("popstate", x.history.setHistoryPopState), x.params.hashnav && x.hashnav && x.hashnav.destroy(), x.emit("onDestroy"), e !== !1 && (x = null) }, x.init(), x
        }
    };
    a.prototype = {
        isSafari: function() { var e = window.navigator.userAgent.toLowerCase(); return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0 }(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
        isArray: function(e) { return "[object Array]" === Object.prototype.toString.apply(e) },
        browser: { ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled, ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1, lteIE9: function() { var e = document.createElement("div"); return e.innerHTML = "<!--[if lte IE 9]><i></i><![endif]-->", 1 === e.getElementsByTagName("i").length }() },
        device: function() {
            var e = window.navigator.userAgent,
                a = e.match(/(Android);?[\s\/]+([\d.]+)?/),
                t = e.match(/(iPad).*OS\s([\d_]+)/),
                s = e.match(/(iPod)(.*OS\s([\d_]+))?/),
                r = !t && e.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            return { ios: t || r || s, android: a }
        }(),
        support: {
            touch: window.Modernizr && Modernizr.touch === !0 || function() { return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) }(),
            transforms3d: window.Modernizr && Modernizr.csstransforms3d === !0 || function() { var e = document.createElement("div").style; return "webkitPerspective" in e || "MozPerspective" in e || "OPerspective" in e || "MsPerspective" in e || "perspective" in e }(),
            flexbox: function() {
                for (var e = document.createElement("div").style, a = "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" "), t = 0; t < a.length; t++)
                    if (a[t] in e) return !0
            }(),
            observer: function() { return "MutationObserver" in window || "WebkitMutationObserver" in window }(),
            passiveListener: function() {
                var e = !1;
                try {
                    var a = Object.defineProperty({}, "passive", { get: function() { e = !0 } });
                    window.addEventListener("testPassiveListener", null, a)
                } catch (e) {}
                return e
            }(),
            gestures: function() { return "ongesturestart" in window }()
        },
        plugins: {}
    };
    for (var t = ["jQuery", "Zepto", "Dom7"], s = 0; s < t.length; s++) window[t[s]] && function(e) {
        e.fn.swiper = function(t) {
            var s;
            return e(this).each(function() {
                var e = new a(this, t);
                s || (s = e)
            }), s
        }
    }(window[t[s]]);
    var r;
    r = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7, r && ("transitionEnd" in r.fn || (r.fn.transitionEnd = function(e) {
        function a(i) {
            if (i.target === this)
                for (e.call(this, i), t = 0; t < s.length; t++) r.off(s[t], a)
        }
        var t, s = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"],
            r = this;
        if (e)
            for (t = 0; t < s.length; t++) r.on(s[t], a);
        return this
    }), "transform" in r.fn || (r.fn.transform = function(e) {
        for (var a = 0; a < this.length; a++) {
            var t = this[a].style;
            t.webkitTransform = t.MsTransform = t.msTransform = t.MozTransform = t.OTransform = t.transform = e
        }
        return this
    }), "transition" in r.fn || (r.fn.transition = function(e) {
        "string" != typeof e && (e += "ms");
        for (var a = 0; a < this.length; a++) {
            var t = this[a].style;
            t.webkitTransitionDuration = t.MsTransitionDuration = t.msTransitionDuration = t.MozTransitionDuration = t.OTransitionDuration = t.transitionDuration = e
        }
        return this
    }), "outerWidth" in r.fn || (r.fn.outerWidth = function(e) { return this.length > 0 ? e ? this[0].offsetWidth + parseFloat(this.css("margin-right")) + parseFloat(this.css("margin-left")) : this[0].offsetWidth : null })), window.Swiper = a
}(), "undefined" != typeof module ? module.exports = window.Swiper : "function" == typeof define && define.amd && define([], function() { "use strict"; return window.Swiper });
//# sourceMappingURL=maps/swiper.jquery.min.js.map
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjtcclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICAvLyAkKCcubWFpbkNvbnRlbnQnKS5jc3MoJ21pbi1oZWlnaHQnLCAoJCh3aW5kb3cpLm91dGVySGVpZ2h0KCkgLSAkKFwiLmZvb3RlclwiKS5vdXRlckhlaWdodCgpKSAtICQoXCIuaGVhZGVyXCIpLm91dGVySGVpZ2h0KCkpO1xyXG4gICAgY2F0YWxvZ0ZpbHRlcnMoKTtcclxuICAgIGhlYWRlck1lbnVJdGVtSG92ZXIoKTtcclxuICAgIGNhdGFsb2dDaGVja0JveCgpO1xyXG4gICAgY2F0YWxvZ0FjY29yZGlvbigpO1xyXG4gICAgY2F0YWxvZ1NvcnRpbmcoKTtcclxuICAgIHByb2R1Y3RQaG90b0dhbGVyeSgpO1xyXG4gICAgcHJvZHVjdE1vcmVUYWJsZUNvbHVtbkNvbG9yKCk7XHJcbiAgICBwcm9kdWN0TW9yZVRhYigpO1xyXG4gICAgb3JkZXJGb3JtKCk7XHJcbiAgICBmb290ZXJNZW51KCk7XHJcbiAgICAkKCdpbWcnKS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH0pO1xyXG4gICAgaFNjcm9sbCgkKCcuaGVhZGVyX19jYXRhbG9nSXRlbScpLCAkKCcuaGVhZGVyX19jYXRhbG9nJykpO1xyXG4gICAgaFNjcm9sbCgkKCcucG9ydGZvbGlvX19pdGVtJyksICQoJy5wb3J0Zm9saW9fX2l0ZW1Cb3gnKSk7XHJcblxyXG4gICAgbWVkaWFDZW50ZXIoNSwgJCgnLndoeVdlX19iZWxpZWYnKSwgJCgnLndoeVdlX19iZWxpZWZzJyksICQoJy50b3RhbFdpZHRoJykpO1xyXG4gICAgbWVkaWFDZW50ZXIoMywgJCgnLmNhdGFsb2dfX2l0ZW0nKSwgJCgnLmNhdGFsb2dfX2l0ZW1zJyksICQoJy5jYXRhbG9nX19tYWluU2VjdGlvbicpKTtcclxuICAgIG1lZGlhQ2VudGVyKDQsICQoJy5jYXRhbG9nX19pdGVtJyksICQoJy5jYXRhbG9nX19pdGVtcycpLCAkKCcuY2F0YWxvZ19fbWFpblNlY3Rpb24tLWZ1bGwnKSk7XHJcbiAgICBpZiAoJCh3aW5kb3cpLm91dGVyV2lkdGgoKSA8PSAxMDIzKSB7XHJcbiAgICAgICAgbWVkaWFDZW50ZXIoOCwgJCgnLmZvb3Rlcl9fcGF5bWVudExpbmsnKSwgJCgnLmZvb3Rlcl9fcGF5bWVudExpbmtzJykpO1xyXG4gICAgfVxyXG4gICAgdmFyIG15U3dpcGVyID0gbmV3IFN3aXBlcignLnN3aXBlcjInLCB7XHJcbiAgICAgICAgcGFnaW5hdGlvbjogJy5zd2lwZXItcGFnaW5hdGlvbicsXHJcbiAgICAgICAgcGFnaW5hdGlvbkNsaWNrYWJsZTogdHJ1ZSxcclxuICAgICAgICBwYWdpbmF0aW9uRWxlbWVudDogJ2xpJ1xyXG4gICAgfSk7XHJcbiAgICAvLyBjYXRhbG9nRmlsdGVyQm94KCk7XHJcbn0pO1xyXG5cclxuJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbigpIHtcclxuICAgIHNsaWRlcigpO1xyXG4gICAgbWVkaWFDZW50ZXIoNSwgJCgnLndoeVdlX19iZWxpZWYnKSwgJCgnLndoeVdlX19iZWxpZWZzJyksICQoJy50b3RhbFdpZHRoJykpO1xyXG4gICAgbWVkaWFDZW50ZXIoMywgJCgnLmNhdGFsb2dfX2l0ZW0nKSwgJCgnLmNhdGFsb2dfX2l0ZW1zJyksICQoJy5jYXRhbG9nX19tYWluU2VjdGlvbicpKTtcclxuICAgIG1lZGlhQ2VudGVyKDQsICQoJy5jYXRhbG9nX19pdGVtJyksICQoJy5jYXRhbG9nX19pdGVtcycpLCAkKCcuY2F0YWxvZ19fbWFpblNlY3Rpb24tLWZ1bGwnKSk7XHJcbiAgICBpZiAoJCh3aW5kb3cpLm91dGVyV2lkdGgoKSA8PSAxMDIzKSB7XHJcbiAgICAgICAgbWVkaWFDZW50ZXIoOCwgJCgnLmZvb3Rlcl9fcGF5bWVudExpbmsnKSwgJCgnLmZvb3Rlcl9fcGF5bWVudExpbmtzJykpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIHZhciBjYXRhbG9nRmlsdGVyQm94ID0gZnVuY3Rpb24oKSB7XHJcbi8vICAgICAkKCcuY2F0YWxvZ19fb3B0aW9uc0l0ZW0nKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuLy8gICAgICAgICB2YXIgdG9wID0gJCh0aGlzKS5vZmZzZXQoKS50b3AgLSAkKCcuY2F0YWxvZ19fb3B0aW9uSXRlbXMnKS5vZmZzZXQoKS50b3A7XHJcbi8vICAgICAgICAgJCgnLmNhdGFsb2dfX29wdGlvbkZpbmRQcm9kdWN0Qm94JykuYWRkQ2xhc3MoJ2NhdGFsb2dfX29wdGlvbkZpbmRQcm9kdWN0Qm94LS1hY3RpdmUnKS5jc3MoJ3RvcCcsIHRvcCk7XHJcbi8vICAgICB9KTtcclxuLy8gfTtcclxuXHJcbnZhciBtZWRpYUNlbnRlciA9IGZ1bmN0aW9uKGNvdW50LCBlbGVtLCBib3gsIGJveENvbnRyb2xTaXplKSB7XHJcbiAgICB2YXIgc2l6ZTtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IChjb3VudCArIDEpOyBpKyspIHtcclxuICAgICAgICBpZiAoYm94Q29udHJvbFNpemUpIHtcclxuICAgICAgICAgICAgc2l6ZSA9IGJveENvbnRyb2xTaXplLndpZHRoKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2l6ZSA9IGJveC53aWR0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2l6ZSA8IGVsZW0ub3V0ZXJXaWR0aCh0cnVlKSAqIGkpIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgYm94LmNzcygnbWF4LXdpZHRoJywgZWxlbS5vdXRlcldpZHRoKHRydWUpICogaSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib3guY3NzKCdtYXgtd2lkdGgnLCBlbGVtLm91dGVyV2lkdGgodHJ1ZSkgKiAoaSAtIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBoU2Nyb2xsID0gZnVuY3Rpb24oZWwsIGVsQikge1xyXG4gICAgZWwub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gJCh0aGlzKS5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICQodGhpcykub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgJCh0aGlzKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgeHggPSBlLnBhZ2VYIC0gJCh0aGlzKS5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICAgICBpZiAoeHggPCB4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyVHIgPSBlbEIuc2Nyb2xsTGVmdCgpICsgKHggLSB4eCk7XHJcbiAgICAgICAgICAgICAgICBlbEIuc2Nyb2xsTGVmdChjdXJUcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHh4ID4geCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1clRyID0gZWxCLnNjcm9sbExlZnQoKSAtICh4eCAtIHgpO1xyXG4gICAgICAgICAgICAgICAgZWxCLnNjcm9sbExlZnQoY3VyVHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWxCLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGVsLnVuYmluZCgnbW91c2Vtb3ZlJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBlbC51bmJpbmQoJ2NsaWNrJyk7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsQi5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlbC51bmJpbmQoJ21vdXNlbW92ZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG52YXIgcHJvZHVjdFBob3RvR2FsZXJ5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZmlyc3RTcmMgPSAkKCcucHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVPdGhlcicpLmVxKDApLmF0dHIoJ3NyYycpO1xyXG4gICAgJCgnLnByb2R1Y3RNb3JlX19nYWxlcnlQaWN0dXJlTWFpbicpLmF0dHIoJ3NyYycsIGZpcnN0U3JjKTtcclxuICAgICQoJy5wcm9kdWN0TW9yZV9fZ2FsZXJ5UGljdHVyZU90aGVyQ2FzZScpLmVxKDApLmFkZENsYXNzKCdwcm9kdWN0TW9yZV9fZ2FsZXJ5UGljdHVyZU90aGVyQ2FzZS0tYWN0aXZlJyk7XHJcbiAgICAkKCcucHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVPdGhlcicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgbmVlZFNyYyA9ICQodGhpcykuYXR0cignc3JjJyk7XHJcbiAgICAgICAgJCgnLnByb2R1Y3RNb3JlX19nYWxlcnlQaWN0dXJlTWFpbicpLmF0dHIoJ3NyYycsIG5lZWRTcmMpO1xyXG5cclxuICAgICAgICAkKCcucHJvZHVjdE1vcmVfX2dhbGVyeVBpY3R1cmVPdGhlckNhc2UtLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdwcm9kdWN0TW9yZV9fZ2FsZXJ5UGljdHVyZU90aGVyQ2FzZS0tYWN0aXZlJyk7XHJcblxyXG4gICAgICAgICQodGhpcykuY2xvc2VzdCgnLnByb2R1Y3RNb3JlX19nYWxlcnlQaWN0dXJlT3RoZXJDYXNlJykuYWRkQ2xhc3MoJ3Byb2R1Y3RNb3JlX19nYWxlcnlQaWN0dXJlT3RoZXJDYXNlLS1hY3RpdmUnKTtcclxuXHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBwcm9kdWN0TW9yZVRhYmxlQ29sdW1uQ29sb3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByb3dzID0gJCgnLnByb2R1Y3RNb3JlX19pbmZvQ2hhcmFjdGVyaXN0aWNzVGFibGVSb3cnKTtcclxuICAgIHZhciBmaXJzdENvbG9yID0gJyNmNGY0ZjQnO1xyXG4gICAgdmFyIHNlY29uZENvbG9yID0gJyNmZmZmZmYnO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgJSAyID09IDApIHtcclxuICAgICAgICAgICAgcm93cy5lcShpKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBmaXJzdENvbG9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByb3dzLmVxKGkpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHNlY29uZENvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgcHJvZHVjdE1vcmVUYWIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0YWJzID0gJCgnLnByb2R1Y3RNb3JlX19pbmZvVGFiJyk7XHJcbiAgICB2YXIgbGlua3MgPSAkKCcucHJvZHVjdE1vcmVfX2luZm9NZW51TGluaycpO1xyXG5cclxuICAgIGxpbmtzLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgJCgnLnByb2R1Y3RNb3JlX19pbmZvTWVudUxpbmstLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdwcm9kdWN0TW9yZV9faW5mb01lbnVMaW5rLS1hY3RpdmUnKVxyXG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3Byb2R1Y3RNb3JlX19pbmZvTWVudUxpbmstLWFjdGl2ZScpO1xyXG4gICAgICAgIHZhciBwYXRoID0gJCh0aGlzKS5hdHRyKCdocmVmJyk7XHJcbiAgICAgICAgdGFicy5lYWNoKGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmICh0YWJzLmVxKGluZGV4KS5hdHRyKCdpZCcpID09PSBwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB0YWJzLmNzcygnZGlzcGxheScsICdub25lJyk7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0YWJzLmVxKDApLmNzcygnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgdmFyIHRhYklkMCA9IHRhYnMuZXEoMCkuYXR0cignaWQnKTtcclxuXHJcbiAgICAkKCcucHJvZHVjdE1vcmVfX2luZm9NZW51TGluaycpLmVhY2goZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICBpZiAobGlua3MuZXEoaW5kZXgpLmF0dHIoJ2hyZWYnKSA9PT0gdGFiSWQwKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3Byb2R1Y3RNb3JlX19pbmZvTWVudUxpbmstLWFjdGl2ZScpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxudmFyIGNhdGFsb2dDaGVja0JveCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJCgnLmNhdGFsb2dfX29wdGlvbnNJdGVtJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCQodGhpcykuZmluZCgnaW5wdXQnKS5wcm9wKCdjaGVja2VkJykgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdjYXRhbG9nX19vcHRpb25zSXRlbS0tY2hlY2tlZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2NhdGFsb2dfX29wdGlvbnNJdGVtLS1jaGVja2VkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG52YXIgY2F0YWxvZ0FjY29yZGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJCgnLmNhdGFsb2dfX29wdGlvbicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICQodGhpcykuZmluZCgnLmFjY29yZGlvbkljb24nKS50b2dnbGVDbGFzcygnYWNjb3JkaW9uSWNvbi0tYWN0aXZlJyk7XHJcbiAgICAgICAgJCh0aGlzKS5maW5kKCcuY2F0YWxvZ19fb3B0aW9uc0l0ZW1MaXN0JykudG9nZ2xlQ2xhc3MoJ2NhdGFsb2dfX29wdGlvbnNJdGVtTGlzdC0tYWN0aXZlJyk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBjYXRhbG9nU29ydGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJCgnLmNhdGFsb2dfX3NvcnRpbmdUaXRsZUJveCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICQodGhpcykuZmluZCgnLmFjY29yZGlvbkljb24nKS50b2dnbGVDbGFzcygnYWNjb3JkaW9uSWNvbi0tYWN0aXZlJyk7XHJcbiAgICAgICAgJCh0aGlzKS5uZXh0KCkudG9nZ2xlQ2xhc3MoJ2NhdGFsb2dfX3NvcnRpbmdMaXN0LS1hY3RpdmUnKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxudmFyIG9yZGVyRm9ybSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHBob25lID0gJCgnLm9yZGVyc19fZm9ybScpLmZpbmQoJ2lucHV0W25hbWU9XCJwaG9uZVwiXScpO1xyXG4gICAgcGhvbmUubWFzayhcIis3KDk5OSkgOTk5LTk5LTk5XCIpO1xyXG5cclxuICAgIHZhciBmb3JtID0gJCgnLm9yZGVyc19fZm9ybScpO1xyXG4gICAgdmFyIHRpdGxlRXJyb3IgPSAkKCcub3JkZXJzX19mb3JtRXJyb3JUaXRsZScpO1xyXG4gICAgdmFyIHZpc2lvblRpdGxlRXJyb3IgPSB0aXRsZUVycm9yLmNzcygnZGlzcGxheScpO1xyXG5cclxuICAgIGlmICh2aXNpb25UaXRsZUVycm9yID09PSAnYmxvY2snKSB7XHJcbiAgICAgICAgZm9ybS5jc3MoJ21hcmdpbi10b3AnLCAnNTVweCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnB1dFJlcXVpcmUgPSAkKCcub3JkZXJzX19mb3JtSXRlbS0tcmVxdWlyZSA+IGlucHV0Jyk7XHJcblxyXG59O1xyXG5cclxudmFyIGhlYWRlck1lbnVJdGVtSG92ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vICQoJ2JvZHknKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgIC8vICAgICBpZiAoJCgnLmhlYWRlcl9fbWVudUxpc3QnKS5oYXNDbGFzcygnaGVhZGVyX19tZW51TGlzdC0tZnVsbCcpKSB7XHJcbiAgICAvLyAgICAgICAgICQoJy5oZWFkZXJfX21lbnVMaXN0JykucmVtb3ZlQ2xhc3MoJ2hlYWRlcl9fbWVudUxpc3QtLWZ1bGwnKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9KTtcclxuICAgICQoJy5oZWFkZXJfX2NhdGFsb2dCdG4nKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoJCgnLmhlYWRlcl9fY2F0YWxvZ0J0blRleHQnKS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICQoJy5oZWFkZXJfX21lbnVMaXN0JykudG9nZ2xlQ2xhc3MoJ2hlYWRlcl9fbWVudUxpc3QtLWZ1bGwnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKCcuaGVhZGVyX19tZW51TGlzdCcpLnRvZ2dsZUNsYXNzKCdoZWFkZXJfX21lbnVMaXN0LS1hY3RpdmUnKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgICQoJy5oZWFkZXJfX21lbnVJdGVtJykub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICgkKCcuaGVhZGVyX19tZW51TGlzdCcpLmhhc0NsYXNzKCdoZWFkZXJfX21lbnVMaXN0LS1hY3RpdmUnKSkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLmZpbmQoJy5oZWFkZXJfX21lbnVJdGVtQWZ0ZXInKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gJCh0aGlzKS5pbmRleCgpO1xyXG4gICAgICAgICAgICB2YXIgdG9wO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdG9wID0gKC01MCAqIGluZGV4KSArIDQ5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9wID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJCh0aGlzKS5maW5kKCcuaGVhZGVyX19zdWJNZW51JykuY3NzKHtcclxuICAgICAgICAgICAgICAgICdkaXNwbGF5JzogJ2ZsZXgnLFxyXG4gICAgICAgICAgICAgICAgJ3RvcCc6IHRvcFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgICQoJy5oZWFkZXJfX21lbnVJdGVtJykub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCh0aGlzKS5maW5kKCcuaGVhZGVyX19tZW51SXRlbUFmdGVyJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgICAgICAkKHRoaXMpLmZpbmQoJy5oZWFkZXJfX3N1Yk1lbnUnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG52YXIgY2F0YWxvZ0ZpbHRlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgICQoJy5maWx0ZXJzQnRuJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCgnLmNhdGFsb2dfX29wdGlvbnMnKS50b2dnbGVDbGFzcygnY2F0YWxvZ19fb3B0aW9ucy0tYWN0aXZlJyk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBmb290ZXJNZW51ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAkKCcuZm9vdGVyX19tZW51VGl0bGUnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaSA9ICQoJy5mb290ZXJfX21lbnUtLWFjdGl2ZScpLmluZGV4KCk7XHJcbiAgICAgICAgdmFyIGogPSAkKHRoaXMpLmNsb3Nlc3QoJy5mb290ZXJfX21lbnUnKS5pbmRleCgpO1xyXG4gICAgICAgIGlmIChqID09PSBpKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnLmZvb3Rlcl9fbWVudScpLnRvZ2dsZUNsYXNzKCdmb290ZXJfX21lbnUtLWFjdGl2ZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQoJy5mb290ZXJfX21lbnUtLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdmb290ZXJfX21lbnUtLWFjdGl2ZScpO1xyXG4gICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJy5mb290ZXJfX21lbnUnKS50b2dnbGVDbGFzcygnZm9vdGVyX19tZW51LS1hY3RpdmUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogU3dpcGVyIDMuNC4yXHJcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXHJcbiAqIFxyXG4gKiBodHRwOi8vd3d3LmlkYW5nZXJvLnVzL3N3aXBlci9cclxuICogXHJcbiAqIENvcHlyaWdodCAyMDE3LCBWbGFkaW1pciBLaGFybGFtcGlkaVxyXG4gKiBUaGUgaURhbmdlcm8udXNcclxuICogaHR0cDovL3d3dy5pZGFuZ2Vyby51cy9cclxuICogXHJcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxyXG4gKiBcclxuICogUmVsZWFzZWQgb246IE1hcmNoIDEwLCAyMDE3XHJcbiAqL1xyXG4hIGZ1bmN0aW9uKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICB2YXIgZSwgYSA9IGZ1bmN0aW9uKHQsIHMpIHtcclxuICAgICAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIE1hdGguZmxvb3IoZSkgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpKCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHgucGFyYW1zLmF1dG9wbGF5LFxyXG4gICAgICAgICAgICAgICAgYSA9IHguc2xpZGVzLmVxKHguYWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICBhLmF0dHIoXCJkYXRhLXN3aXBlci1hdXRvcGxheVwiKSAmJiAoZSA9IGEuYXR0cihcImRhdGEtc3dpcGVyLWF1dG9wbGF5XCIpIHx8IHgucGFyYW1zLmF1dG9wbGF5KSwgeC5hdXRvcGxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHgucGFyYW1zLmxvb3AgPyAoeC5maXhMb29wKCksIHguX3NsaWRlTmV4dCgpLCB4LmVtaXQoXCJvbkF1dG9wbGF5XCIsIHgpKSA6IHguaXNFbmQgPyBzLmF1dG9wbGF5U3RvcE9uTGFzdCA/IHguc3RvcEF1dG9wbGF5KCkgOiAoeC5fc2xpZGVUbygwKSwgeC5lbWl0KFwib25BdXRvcGxheVwiLCB4KSkgOiAoeC5fc2xpZGVOZXh0KCksIHguZW1pdChcIm9uQXV0b3BsYXlcIiwgeCkpIH0sIGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBuKGEsIHQpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBlKGEudGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKCFzLmlzKHQpKVxyXG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHMgPSBzLnBhcmVudHModCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0Lm5vZGVUeXBlKSB7IHZhciByOyByZXR1cm4gcy5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbihlLCBhKSB7IGEgPT09IHQgJiYgKHIgPSB0KSB9KSwgciA/IHQgOiB2b2lkIDAgfVxyXG4gICAgICAgICAgICBpZiAoMCAhPT0gcy5sZW5ndGgpIHJldHVybiBzWzBdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvKGUsIGEpIHtcclxuICAgICAgICAgICAgYSA9IGEgfHwge307XHJcbiAgICAgICAgICAgIHZhciB0ID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICBzID0gbmV3IHQoZnVuY3Rpb24oZSkgeyBlLmZvckVhY2goZnVuY3Rpb24oZSkgeyB4Lm9uUmVzaXplKCEwKSwgeC5lbWl0KFwib25PYnNlcnZlclVwZGF0ZVwiLCB4LCBlKSB9KSB9KTtcclxuICAgICAgICAgICAgcy5vYnNlcnZlKGUsIHsgYXR0cmlidXRlczogdm9pZCAwID09PSBhLmF0dHJpYnV0ZXMgfHwgYS5hdHRyaWJ1dGVzLCBjaGlsZExpc3Q6IHZvaWQgMCA9PT0gYS5jaGlsZExpc3QgfHwgYS5jaGlsZExpc3QsIGNoYXJhY3RlckRhdGE6IHZvaWQgMCA9PT0gYS5jaGFyYWN0ZXJEYXRhIHx8IGEuY2hhcmFjdGVyRGF0YSB9KSwgeC5vYnNlcnZlcnMucHVzaChzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbChlKSB7XHJcbiAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudCAmJiAoZSA9IGUub3JpZ2luYWxFdmVudCk7XHJcbiAgICAgICAgICAgIHZhciBhID0gZS5rZXlDb2RlIHx8IGUuY2hhckNvZGU7XHJcbiAgICAgICAgICAgIGlmICgheC5wYXJhbXMuYWxsb3dTd2lwZVRvTmV4dCAmJiAoeC5pc0hvcml6b250YWwoKSAmJiAzOSA9PT0gYSB8fCAheC5pc0hvcml6b250YWwoKSAmJiA0MCA9PT0gYSkpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgaWYgKCF4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ICYmICh4LmlzSG9yaXpvbnRhbCgpICYmIDM3ID09PSBhIHx8ICF4LmlzSG9yaXpvbnRhbCgpICYmIDM4ID09PSBhKSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBpZiAoIShlLnNoaWZ0S2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lICYmIChcImlucHV0XCIgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSB8fCBcInRleHRhcmVhXCIgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoMzcgPT09IGEgfHwgMzkgPT09IGEgfHwgMzggPT09IGEgfHwgNDAgPT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4LmNvbnRhaW5lci5wYXJlbnRzKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcykubGVuZ3RoID4gMCAmJiAwID09PSB4LmNvbnRhaW5lci5wYXJlbnRzKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzcykubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB7IGxlZnQ6IHdpbmRvdy5wYWdlWE9mZnNldCwgdG9wOiB3aW5kb3cucGFnZVlPZmZzZXQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHdpbmRvdy5pbm5lcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gd2luZG93LmlubmVySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0geC5jb250YWluZXIub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5ydGwgJiYgKG4ubGVmdCA9IG4ubGVmdCAtIHguY29udGFpbmVyWzBdLnNjcm9sbExlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbi5sZWZ0LCBuLnRvcF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbi5sZWZ0ICsgeC53aWR0aCwgbi50b3BdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW24ubGVmdCwgbi50b3AgKyB4LmhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbi5sZWZ0ICsgeC53aWR0aCwgbi50b3AgKyB4LmhlaWdodF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgbCA9IDA7IGwgPCBvLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gb1tsXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcFswXSA+PSBzLmxlZnQgJiYgcFswXSA8PSBzLmxlZnQgKyByICYmIHBbMV0gPj0gcy50b3AgJiYgcFsxXSA8PSBzLnRvcCArIGkgJiYgKHQgPSAhMClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHguaXNIb3Jpem9udGFsKCkgPyAoMzcgIT09IGEgJiYgMzkgIT09IGEgfHwgKGUucHJldmVudERlZmF1bHQgPyBlLnByZXZlbnREZWZhdWx0KCkgOiBlLnJldHVyblZhbHVlID0gITEpLCAoMzkgPT09IGEgJiYgIXgucnRsIHx8IDM3ID09PSBhICYmIHgucnRsKSAmJiB4LnNsaWRlTmV4dCgpLCAoMzcgPT09IGEgJiYgIXgucnRsIHx8IDM5ID09PSBhICYmIHgucnRsKSAmJiB4LnNsaWRlUHJldigpKSA6ICgzOCAhPT0gYSAmJiA0MCAhPT0gYSB8fCAoZS5wcmV2ZW50RGVmYXVsdCA/IGUucHJldmVudERlZmF1bHQoKSA6IGUucmV0dXJuVmFsdWUgPSAhMSksIDQwID09PSBhICYmIHguc2xpZGVOZXh0KCksIDM4ID09PSBhICYmIHguc2xpZGVQcmV2KCkpLCB4LmVtaXQoXCJvbktleVByZXNzXCIsIHgsIGEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHAoZSkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IDAsXHJcbiAgICAgICAgICAgICAgICB0ID0gMCxcclxuICAgICAgICAgICAgICAgIHMgPSAwLFxyXG4gICAgICAgICAgICAgICAgciA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBcImRldGFpbFwiIGluIGUgJiYgKHQgPSBlLmRldGFpbCksIFwid2hlZWxEZWx0YVwiIGluIGUgJiYgKHQgPSAtZS53aGVlbERlbHRhIC8gMTIwKSwgXCJ3aGVlbERlbHRhWVwiIGluIGUgJiYgKHQgPSAtZS53aGVlbERlbHRhWSAvIDEyMCksIFwid2hlZWxEZWx0YVhcIiBpbiBlICYmIChhID0gLWUud2hlZWxEZWx0YVggLyAxMjApLCBcImF4aXNcIiBpbiBlICYmIGUuYXhpcyA9PT0gZS5IT1JJWk9OVEFMX0FYSVMgJiYgKGEgPSB0LCB0ID0gMCksIHMgPSAxMCAqIGEsIHIgPSAxMCAqIHQsIFwiZGVsdGFZXCIgaW4gZSAmJiAociA9IGUuZGVsdGFZKSwgXCJkZWx0YVhcIiBpbiBlICYmIChzID0gZS5kZWx0YVgpLCAocyB8fCByKSAmJiBlLmRlbHRhTW9kZSAmJiAoMSA9PT0gZS5kZWx0YU1vZGUgPyAocyAqPSA0MCwgciAqPSA0MCkgOiAocyAqPSA4MDAsIHIgKj0gODAwKSksIHMgJiYgIWEgJiYgKGEgPSBzIDwgMSA/IC0xIDogMSksIHIgJiYgIXQgJiYgKHQgPSByIDwgMSA/IC0xIDogMSksIHsgc3Bpblg6IGEsIHNwaW5ZOiB0LCBwaXhlbFg6IHMsIHBpeGVsWTogciB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkKGUpIHtcclxuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50ICYmIChlID0gZS5vcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgdmFyIGEgPSAwLFxyXG4gICAgICAgICAgICAgICAgdCA9IHgucnRsID8gLTEgOiAxLFxyXG4gICAgICAgICAgICAgICAgcyA9IHAoZSk7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmFtcy5tb3VzZXdoZWVsRm9yY2VUb0F4aXMpXHJcbiAgICAgICAgICAgICAgICBpZiAoeC5pc0hvcml6b250YWwoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKE1hdGguYWJzKHMucGl4ZWxYKSA+IE1hdGguYWJzKHMucGl4ZWxZKSkpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBhID0gcy5waXhlbFggKiB0XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKE1hdGguYWJzKHMucGl4ZWxZKSA+IE1hdGguYWJzKHMucGl4ZWxYKSkpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBhID0gcy5waXhlbFlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBhID0gTWF0aC5hYnMocy5waXhlbFgpID4gTWF0aC5hYnMocy5waXhlbFkpID8gLXMucGl4ZWxYICogdCA6IC1zLnBpeGVsWTtcclxuICAgICAgICAgICAgaWYgKDAgIT09IGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5tb3VzZXdoZWVsSW52ZXJ0ICYmIChhID0gLWEpLCB4LnBhcmFtcy5mcmVlTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0geC5nZXRXcmFwcGVyVHJhbnNsYXRlKCkgKyBhICogeC5wYXJhbXMubW91c2V3aGVlbFNlbnNpdGl2aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0geC5pc0JlZ2lubmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHguaXNFbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPj0geC5taW5UcmFuc2xhdGUoKSAmJiAociA9IHgubWluVHJhbnNsYXRlKCkpLCByIDw9IHgubWF4VHJhbnNsYXRlKCkgJiYgKHIgPSB4Lm1heFRyYW5zbGF0ZSgpKSwgeC5zZXRXcmFwcGVyVHJhbnNpdGlvbigwKSwgeC5zZXRXcmFwcGVyVHJhbnNsYXRlKHIpLCB4LnVwZGF0ZVByb2dyZXNzKCksIHgudXBkYXRlQWN0aXZlSW5kZXgoKSwgKCFpICYmIHguaXNCZWdpbm5pbmcgfHwgIW4gJiYgeC5pc0VuZCkgJiYgeC51cGRhdGVDbGFzc2VzKCksIHgucGFyYW1zLmZyZWVNb2RlU3RpY2t5ID8gKGNsZWFyVGltZW91dCh4Lm1vdXNld2hlZWwudGltZW91dCksIHgubW91c2V3aGVlbC50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgeC5zbGlkZVJlc2V0KCkgfSwgMzAwKSkgOiB4LnBhcmFtcy5sYXp5TG9hZGluZyAmJiB4LmxhenkgJiYgeC5sYXp5LmxvYWQoKSwgeC5lbWl0KFwib25TY3JvbGxcIiwgeCwgZSksIHgucGFyYW1zLmF1dG9wbGF5ICYmIHgucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24gJiYgeC5zdG9wQXV0b3BsYXkoKSwgMCA9PT0gciB8fCByID09PSB4Lm1heFRyYW5zbGF0ZSgpKSByZXR1cm5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuZXcgd2luZG93LkRhdGUpLmdldFRpbWUoKSAtIHgubW91c2V3aGVlbC5sYXN0U2Nyb2xsVGltZSA+IDYwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pc0VuZCAmJiAheC5wYXJhbXMubG9vcCB8fCB4LmFuaW1hdGluZykgeyBpZiAoeC5wYXJhbXMubW91c2V3aGVlbFJlbGVhc2VPbkVkZ2VzKSByZXR1cm4gITAgfSBlbHNlIHguc2xpZGVOZXh0KCksIHguZW1pdChcIm9uU2Nyb2xsXCIsIHgsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHguaXNCZWdpbm5pbmcgJiYgIXgucGFyYW1zLmxvb3AgfHwgeC5hbmltYXRpbmcpIHsgaWYgKHgucGFyYW1zLm1vdXNld2hlZWxSZWxlYXNlT25FZGdlcykgcmV0dXJuICEwIH0gZWxzZSB4LnNsaWRlUHJldigpLCB4LmVtaXQoXCJvblNjcm9sbFwiLCB4LCBlKTtcclxuICAgICAgICAgICAgICAgICAgICB4Lm1vdXNld2hlZWwubGFzdFNjcm9sbFRpbWUgPSAobmV3IHdpbmRvdy5EYXRlKS5nZXRUaW1lKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExLCAhMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBtKGEsIHQpIHtcclxuICAgICAgICAgICAgYSA9IGUoYSk7XHJcbiAgICAgICAgICAgIHZhciBzLCByLCBpLCBuID0geC5ydGwgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHMgPSBhLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheFwiKSB8fCBcIjBcIiwgciA9IGEuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LXhcIiksIGkgPSBhLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC15XCIpLCByIHx8IGkgPyAociA9IHIgfHwgXCIwXCIsIGkgPSBpIHx8IFwiMFwiKSA6IHguaXNIb3Jpem9udGFsKCkgPyAociA9IHMsIGkgPSBcIjBcIikgOiAoaSA9IHMsIHIgPSBcIjBcIiksIHIgPSByLmluZGV4T2YoXCIlXCIpID49IDAgPyBwYXJzZUludChyLCAxMCkgKiB0ICogbiArIFwiJVwiIDogciAqIHQgKiBuICsgXCJweFwiLCBpID0gaS5pbmRleE9mKFwiJVwiKSA+PSAwID8gcGFyc2VJbnQoaSwgMTApICogdCArIFwiJVwiIDogaSAqIHQgKyBcInB4XCIsIGEudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIgKyByICsgXCIsIFwiICsgaSArIFwiLDBweClcIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHUoZSkgeyByZXR1cm4gMCAhPT0gZS5pbmRleE9mKFwib25cIikgJiYgKGUgPSBlWzBdICE9PSBlWzBdLnRvVXBwZXJDYXNlKCkgPyBcIm9uXCIgKyBlWzBdLnRvVXBwZXJDYXNlKCkgKyBlLnN1YnN0cmluZygxKSA6IFwib25cIiArIGUpLCBlIH1cclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYSkpIHJldHVybiBuZXcgYSh0LCBzKTtcclxuICAgICAgICB2YXIgYyA9IHsgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiwgdG91Y2hFdmVudHNUYXJnZXQ6IFwiY29udGFpbmVyXCIsIGluaXRpYWxTbGlkZTogMCwgc3BlZWQ6IDMwMCwgYXV0b3BsYXk6ICExLCBhdXRvcGxheURpc2FibGVPbkludGVyYWN0aW9uOiAhMCwgYXV0b3BsYXlTdG9wT25MYXN0OiAhMSwgaU9TRWRnZVN3aXBlRGV0ZWN0aW9uOiAhMSwgaU9TRWRnZVN3aXBlVGhyZXNob2xkOiAyMCwgZnJlZU1vZGU6ICExLCBmcmVlTW9kZU1vbWVudHVtOiAhMCwgZnJlZU1vZGVNb21lbnR1bVJhdGlvOiAxLCBmcmVlTW9kZU1vbWVudHVtQm91bmNlOiAhMCwgZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvOiAxLCBmcmVlTW9kZU1vbWVudHVtVmVsb2NpdHlSYXRpbzogMSwgZnJlZU1vZGVTdGlja3k6ICExLCBmcmVlTW9kZU1pbmltdW1WZWxvY2l0eTogLjAyLCBhdXRvSGVpZ2h0OiAhMSwgc2V0V3JhcHBlclNpemU6ICExLCB2aXJ0dWFsVHJhbnNsYXRlOiAhMSwgZWZmZWN0OiBcInNsaWRlXCIsIGNvdmVyZmxvdzogeyByb3RhdGU6IDUwLCBzdHJldGNoOiAwLCBkZXB0aDogMTAwLCBtb2RpZmllcjogMSwgc2xpZGVTaGFkb3dzOiAhMCB9LCBmbGlwOiB7IHNsaWRlU2hhZG93czogITAsIGxpbWl0Um90YXRpb246ICEwIH0sIGN1YmU6IHsgc2xpZGVTaGFkb3dzOiAhMCwgc2hhZG93OiAhMCwgc2hhZG93T2Zmc2V0OiAyMCwgc2hhZG93U2NhbGU6IC45NCB9LCBmYWRlOiB7IGNyb3NzRmFkZTogITEgfSwgcGFyYWxsYXg6ICExLCB6b29tOiAhMSwgem9vbU1heDogMywgem9vbU1pbjogMSwgem9vbVRvZ2dsZTogITAsIHNjcm9sbGJhcjogbnVsbCwgc2Nyb2xsYmFySGlkZTogITAsIHNjcm9sbGJhckRyYWdnYWJsZTogITEsIHNjcm9sbGJhclNuYXBPblJlbGVhc2U6ICExLCBrZXlib2FyZENvbnRyb2w6ICExLCBtb3VzZXdoZWVsQ29udHJvbDogITEsIG1vdXNld2hlZWxSZWxlYXNlT25FZGdlczogITEsIG1vdXNld2hlZWxJbnZlcnQ6ICExLCBtb3VzZXdoZWVsRm9yY2VUb0F4aXM6ICExLCBtb3VzZXdoZWVsU2Vuc2l0aXZpdHk6IDEsIG1vdXNld2hlZWxFdmVudHNUYXJnZWQ6IFwiY29udGFpbmVyXCIsIGhhc2huYXY6ICExLCBoYXNobmF2V2F0Y2hTdGF0ZTogITEsIGhpc3Rvcnk6ICExLCByZXBsYWNlU3RhdGU6ICExLCBicmVha3BvaW50czogdm9pZCAwLCBzcGFjZUJldHdlZW46IDAsIHNsaWRlc1BlclZpZXc6IDEsIHNsaWRlc1BlckNvbHVtbjogMSwgc2xpZGVzUGVyQ29sdW1uRmlsbDogXCJjb2x1bW5cIiwgc2xpZGVzUGVyR3JvdXA6IDEsIGNlbnRlcmVkU2xpZGVzOiAhMSwgc2xpZGVzT2Zmc2V0QmVmb3JlOiAwLCBzbGlkZXNPZmZzZXRBZnRlcjogMCwgcm91bmRMZW5ndGhzOiAhMSwgdG91Y2hSYXRpbzogMSwgdG91Y2hBbmdsZTogNDUsIHNpbXVsYXRlVG91Y2g6ICEwLCBzaG9ydFN3aXBlczogITAsIGxvbmdTd2lwZXM6ICEwLCBsb25nU3dpcGVzUmF0aW86IC41LCBsb25nU3dpcGVzTXM6IDMwMCwgZm9sbG93RmluZ2VyOiAhMCwgb25seUV4dGVybmFsOiAhMSwgdGhyZXNob2xkOiAwLCB0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246ICEwLCB0b3VjaFJlbGVhc2VPbkVkZ2VzOiAhMSwgdW5pcXVlTmF2RWxlbWVudHM6ICEwLCBwYWdpbmF0aW9uOiBudWxsLCBwYWdpbmF0aW9uRWxlbWVudDogXCJzcGFuXCIsIHBhZ2luYXRpb25DbGlja2FibGU6ICExLCBwYWdpbmF0aW9uSGlkZTogITEsIHBhZ2luYXRpb25CdWxsZXRSZW5kZXI6IG51bGwsIHBhZ2luYXRpb25Qcm9ncmVzc1JlbmRlcjogbnVsbCwgcGFnaW5hdGlvbkZyYWN0aW9uUmVuZGVyOiBudWxsLCBwYWdpbmF0aW9uQ3VzdG9tUmVuZGVyOiBudWxsLCBwYWdpbmF0aW9uVHlwZTogXCJidWxsZXRzXCIsIHJlc2lzdGFuY2U6ICEwLCByZXNpc3RhbmNlUmF0aW86IC44NSwgbmV4dEJ1dHRvbjogbnVsbCwgcHJldkJ1dHRvbjogbnVsbCwgd2F0Y2hTbGlkZXNQcm9ncmVzczogITEsIHdhdGNoU2xpZGVzVmlzaWJpbGl0eTogITEsIGdyYWJDdXJzb3I6ICExLCBwcmV2ZW50Q2xpY2tzOiAhMCwgcHJldmVudENsaWNrc1Byb3BhZ2F0aW9uOiAhMCwgc2xpZGVUb0NsaWNrZWRTbGlkZTogITEsIGxhenlMb2FkaW5nOiAhMSwgbGF6eUxvYWRpbmdJblByZXZOZXh0OiAhMSwgbGF6eUxvYWRpbmdJblByZXZOZXh0QW1vdW50OiAxLCBsYXp5TG9hZGluZ09uVHJhbnNpdGlvblN0YXJ0OiAhMSwgcHJlbG9hZEltYWdlczogITAsIHVwZGF0ZU9uSW1hZ2VzUmVhZHk6ICEwLCBsb29wOiAhMSwgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsIGxvb3BlZFNsaWRlczogbnVsbCwgY29udHJvbDogdm9pZCAwLCBjb250cm9sSW52ZXJzZTogITEsIGNvbnRyb2xCeTogXCJzbGlkZVwiLCBub3JtYWxpemVTbGlkZUluZGV4OiAhMCwgYWxsb3dTd2lwZVRvUHJldjogITAsIGFsbG93U3dpcGVUb05leHQ6ICEwLCBzd2lwZUhhbmRsZXI6IG51bGwsIG5vU3dpcGluZzogITAsIG5vU3dpcGluZ0NsYXNzOiBcInN3aXBlci1uby1zd2lwaW5nXCIsIHBhc3NpdmVMaXN0ZW5lcnM6ICEwLCBjb250YWluZXJNb2RpZmllckNsYXNzOiBcInN3aXBlci1jb250YWluZXItXCIsIHNsaWRlQ2xhc3M6IFwic3dpcGVyLXNsaWRlXCIsIHNsaWRlQWN0aXZlQ2xhc3M6IFwic3dpcGVyLXNsaWRlLWFjdGl2ZVwiLCBzbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlXCIsIHNsaWRlVmlzaWJsZUNsYXNzOiBcInN3aXBlci1zbGlkZS12aXNpYmxlXCIsIHNsaWRlRHVwbGljYXRlQ2xhc3M6IFwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZVwiLCBzbGlkZU5leHRDbGFzczogXCJzd2lwZXItc2xpZGUtbmV4dFwiLCBzbGlkZUR1cGxpY2F0ZU5leHRDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlLW5leHRcIiwgc2xpZGVQcmV2Q2xhc3M6IFwic3dpcGVyLXNsaWRlLXByZXZcIiwgc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3M6IFwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2XCIsIHdyYXBwZXJDbGFzczogXCJzd2lwZXItd3JhcHBlclwiLCBidWxsZXRDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1idWxsZXRcIiwgYnVsbGV0QWN0aXZlQ2xhc3M6IFwic3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZVwiLCBidXR0b25EaXNhYmxlZENsYXNzOiBcInN3aXBlci1idXR0b24tZGlzYWJsZWRcIiwgcGFnaW5hdGlvbkN1cnJlbnRDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1jdXJyZW50XCIsIHBhZ2luYXRpb25Ub3RhbENsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLXRvdGFsXCIsIHBhZ2luYXRpb25IaWRkZW5DbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1oaWRkZW5cIiwgcGFnaW5hdGlvblByb2dyZXNzYmFyQ2xhc3M6IFwic3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXJcIiwgcGFnaW5hdGlvbkNsaWNrYWJsZUNsYXNzOiBcInN3aXBlci1wYWdpbmF0aW9uLWNsaWNrYWJsZVwiLCBwYWdpbmF0aW9uTW9kaWZpZXJDbGFzczogXCJzd2lwZXItcGFnaW5hdGlvbi1cIiwgbGF6eUxvYWRpbmdDbGFzczogXCJzd2lwZXItbGF6eVwiLCBsYXp5U3RhdHVzTG9hZGluZ0NsYXNzOiBcInN3aXBlci1sYXp5LWxvYWRpbmdcIiwgbGF6eVN0YXR1c0xvYWRlZENsYXNzOiBcInN3aXBlci1sYXp5LWxvYWRlZFwiLCBsYXp5UHJlbG9hZGVyQ2xhc3M6IFwic3dpcGVyLWxhenktcHJlbG9hZGVyXCIsIG5vdGlmaWNhdGlvbkNsYXNzOiBcInN3aXBlci1ub3RpZmljYXRpb25cIiwgcHJlbG9hZGVyQ2xhc3M6IFwicHJlbG9hZGVyXCIsIHpvb21Db250YWluZXJDbGFzczogXCJzd2lwZXItem9vbS1jb250YWluZXJcIiwgb2JzZXJ2ZXI6ICExLCBvYnNlcnZlUGFyZW50czogITEsIGExMXk6ICExLCBwcmV2U2xpZGVNZXNzYWdlOiBcIlByZXZpb3VzIHNsaWRlXCIsIG5leHRTbGlkZU1lc3NhZ2U6IFwiTmV4dCBzbGlkZVwiLCBmaXJzdFNsaWRlTWVzc2FnZTogXCJUaGlzIGlzIHRoZSBmaXJzdCBzbGlkZVwiLCBsYXN0U2xpZGVNZXNzYWdlOiBcIlRoaXMgaXMgdGhlIGxhc3Qgc2xpZGVcIiwgcGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2U6IFwiR28gdG8gc2xpZGUge3tpbmRleH19XCIsIHJ1bkNhbGxiYWNrc09uSW5pdDogITAgfSxcclxuICAgICAgICAgICAgZyA9IHMgJiYgcy52aXJ0dWFsVHJhbnNsYXRlO1xyXG4gICAgICAgIHMgPSBzIHx8IHt9O1xyXG4gICAgICAgIHZhciBoID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgdiBpbiBzKVxyXG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2Ygc1t2XSB8fCBudWxsID09PSBzW3ZdIHx8IChzW3ZdLm5vZGVUeXBlIHx8IHNbdl0gPT09IHdpbmRvdyB8fCBzW3ZdID09PSBkb2N1bWVudCB8fCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBEb203ICYmIHNbdl0gaW5zdGFuY2VvZiBEb203IHx8IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGpRdWVyeSAmJiBzW3ZdIGluc3RhbmNlb2YgalF1ZXJ5KSkgaFt2XSA9IHNbdl07XHJcbiAgICAgICAgICAgIGVsc2UgeyBoW3ZdID0ge307IGZvciAodmFyIGYgaW4gc1t2XSkgaFt2XVtmXSA9IHNbdl1bZl0gfVxyXG4gICAgICAgIGZvciAodmFyIHcgaW4gYylcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gc1t3XSkgc1t3XSA9IGNbd107XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHNbd10pXHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgaW4gY1t3XSkgdm9pZCAwID09PSBzW3ddW3ldICYmIChzW3ddW3ldID0gY1t3XVt5XSk7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzO1xyXG4gICAgICAgIGlmICh4LnBhcmFtcyA9IHMsIHgub3JpZ2luYWxQYXJhbXMgPSBoLCB4LmNsYXNzTmFtZXMgPSBbXSwgdm9pZCAwICE9PSBlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIERvbTcgJiYgKGUgPSBEb203KSwgKHZvaWQgMCAhPT0gZSB8fCAoZSA9IFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIERvbTcgPyB3aW5kb3cuRG9tNyB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSA6IERvbTcpKSAmJiAoeC4kID0gZSwgeC5jdXJyZW50QnJlYWtwb2ludCA9IHZvaWQgMCwgeC5nZXRBY3RpdmVCcmVha3BvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXgucGFyYW1zLmJyZWFrcG9pbnRzKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSwgYSA9ICExLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoZSBpbiB4LnBhcmFtcy5icmVha3BvaW50cykgeC5wYXJhbXMuYnJlYWtwb2ludHMuaGFzT3duUHJvcGVydHkoZSkgJiYgdC5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgdC5zb3J0KGZ1bmN0aW9uKGUsIGEpIHsgcmV0dXJuIHBhcnNlSW50KGUsIDEwKSA+IHBhcnNlSW50KGEsIDEwKSB9KTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMrKykoZSA9IHRbc10pID49IHdpbmRvdy5pbm5lcldpZHRoICYmICFhICYmIChhID0gZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSB8fCBcIm1heFwiXHJcbiAgICAgICAgICAgIH0sIHguc2V0QnJlYWtwb2ludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB4LmdldEFjdGl2ZUJyZWFrcG9pbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChlICYmIHguY3VycmVudEJyZWFrcG9pbnQgIT09IGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUgaW4geC5wYXJhbXMuYnJlYWtwb2ludHMgPyB4LnBhcmFtcy5icmVha3BvaW50c1tlXSA6IHgub3JpZ2luYWxQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB4LnBhcmFtcy5sb29wICYmIGEuc2xpZGVzUGVyVmlldyAhPT0geC5wYXJhbXMuc2xpZGVzUGVyVmlldztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIGEpIHgucGFyYW1zW3NdID0gYVtzXTtcclxuICAgICAgICAgICAgICAgICAgICB4LmN1cnJlbnRCcmVha3BvaW50ID0gZSwgdCAmJiB4LmRlc3Ryb3lMb29wICYmIHgucmVMb29wKCEwKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB4LnBhcmFtcy5icmVha3BvaW50cyAmJiB4LnNldEJyZWFrcG9pbnQoKSwgeC5jb250YWluZXIgPSBlKHQpLCAwICE9PSB4LmNvbnRhaW5lci5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIGlmICh4LmNvbnRhaW5lci5sZW5ndGggPiAxKSB7IHZhciBUID0gW107IHJldHVybiB4LmNvbnRhaW5lci5lYWNoKGZ1bmN0aW9uKCkgeyBULnB1c2gobmV3IGEodGhpcywgcykpIH0pLCBUIH1cclxuICAgICAgICAgICAgeC5jb250YWluZXJbMF0uc3dpcGVyID0geCwgeC5jb250YWluZXIuZGF0YShcInN3aXBlclwiLCB4KSwgeC5jbGFzc05hbWVzLnB1c2goeC5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyArIHgucGFyYW1zLmRpcmVjdGlvbiksIHgucGFyYW1zLmZyZWVNb2RlICYmIHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcImZyZWUtbW9kZVwiKSwgeC5zdXBwb3J0LmZsZXhib3ggfHwgKHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcIm5vLWZsZXhib3hcIiksIHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbiA9IDEpLCB4LnBhcmFtcy5hdXRvSGVpZ2h0ICYmIHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcImF1dG9oZWlnaHRcIiksICh4LnBhcmFtcy5wYXJhbGxheCB8fCB4LnBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpICYmICh4LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITApLCB4LnBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzICYmICh4LnBhcmFtcy5yZXNpc3RhbmNlUmF0aW8gPSAwKSwgW1wiY3ViZVwiLCBcImNvdmVyZmxvd1wiLCBcImZsaXBcIl0uaW5kZXhPZih4LnBhcmFtcy5lZmZlY3QpID49IDAgJiYgKHguc3VwcG9ydC50cmFuc2Zvcm1zM2QgPyAoeC5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9ICEwLCB4LmNsYXNzTmFtZXMucHVzaCh4LnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgXCIzZFwiKSkgOiB4LnBhcmFtcy5lZmZlY3QgPSBcInNsaWRlXCIpLCBcInNsaWRlXCIgIT09IHgucGFyYW1zLmVmZmVjdCAmJiB4LmNsYXNzTmFtZXMucHVzaCh4LnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgeC5wYXJhbXMuZWZmZWN0KSwgXCJjdWJlXCIgPT09IHgucGFyYW1zLmVmZmVjdCAmJiAoeC5wYXJhbXMucmVzaXN0YW5jZVJhdGlvID0gMCwgeC5wYXJhbXMuc2xpZGVzUGVyVmlldyA9IDEsIHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbiA9IDEsIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwID0gMSwgeC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPSAhMSwgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuID0gMCwgeC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSA9ICEwKSwgXCJmYWRlXCIgIT09IHgucGFyYW1zLmVmZmVjdCAmJiBcImZsaXBcIiAhPT0geC5wYXJhbXMuZWZmZWN0IHx8ICh4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID0gMSwgeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID0gMSwgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPSAxLCB4LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITAsIHgucGFyYW1zLnNwYWNlQmV0d2VlbiA9IDAsIHZvaWQgMCA9PT0gZyAmJiAoeC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSA9ICEwKSksIHgucGFyYW1zLmdyYWJDdXJzb3IgJiYgeC5zdXBwb3J0LnRvdWNoICYmICh4LnBhcmFtcy5ncmFiQ3Vyc29yID0gITEpLCB4LndyYXBwZXIgPSB4LmNvbnRhaW5lci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLndyYXBwZXJDbGFzcyksIHgucGFyYW1zLnBhZ2luYXRpb24gJiYgKHgucGFnaW5hdGlvbkNvbnRhaW5lciA9IGUoeC5wYXJhbXMucGFnaW5hdGlvbiksIHgucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHgucGFyYW1zLnBhZ2luYXRpb24gJiYgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmxlbmd0aCA+IDEgJiYgMSA9PT0geC5jb250YWluZXIuZmluZCh4LnBhcmFtcy5wYWdpbmF0aW9uKS5sZW5ndGggJiYgKHgucGFnaW5hdGlvbkNvbnRhaW5lciA9IHguY29udGFpbmVyLmZpbmQoeC5wYXJhbXMucGFnaW5hdGlvbikpLCBcImJ1bGxldHNcIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUgJiYgeC5wYXJhbXMucGFnaW5hdGlvbkNsaWNrYWJsZSA/IHgucGFnaW5hdGlvbkNvbnRhaW5lci5hZGRDbGFzcyh4LnBhcmFtcy5wYWdpbmF0aW9uTW9kaWZpZXJDbGFzcyArIFwiY2xpY2thYmxlXCIpIDogeC5wYXJhbXMucGFnaW5hdGlvbkNsaWNrYWJsZSA9ICExLCB4LnBhZ2luYXRpb25Db250YWluZXIuYWRkQ2xhc3MoeC5wYXJhbXMucGFnaW5hdGlvbk1vZGlmaWVyQ2xhc3MgKyB4LnBhcmFtcy5wYWdpbmF0aW9uVHlwZSkpLCAoeC5wYXJhbXMubmV4dEJ1dHRvbiB8fCB4LnBhcmFtcy5wcmV2QnV0dG9uKSAmJiAoeC5wYXJhbXMubmV4dEJ1dHRvbiAmJiAoeC5uZXh0QnV0dG9uID0gZSh4LnBhcmFtcy5uZXh0QnV0dG9uKSwgeC5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgeC5wYXJhbXMubmV4dEJ1dHRvbiAmJiB4Lm5leHRCdXR0b24ubGVuZ3RoID4gMSAmJiAxID09PSB4LmNvbnRhaW5lci5maW5kKHgucGFyYW1zLm5leHRCdXR0b24pLmxlbmd0aCAmJiAoeC5uZXh0QnV0dG9uID0geC5jb250YWluZXIuZmluZCh4LnBhcmFtcy5uZXh0QnV0dG9uKSkpLCB4LnBhcmFtcy5wcmV2QnV0dG9uICYmICh4LnByZXZCdXR0b24gPSBlKHgucGFyYW1zLnByZXZCdXR0b24pLCB4LnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB4LnBhcmFtcy5wcmV2QnV0dG9uICYmIHgucHJldkJ1dHRvbi5sZW5ndGggPiAxICYmIDEgPT09IHguY29udGFpbmVyLmZpbmQoeC5wYXJhbXMucHJldkJ1dHRvbikubGVuZ3RoICYmICh4LnByZXZCdXR0b24gPSB4LmNvbnRhaW5lci5maW5kKHgucGFyYW1zLnByZXZCdXR0b24pKSkpLCB4LmlzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJob3Jpem9udGFsXCIgPT09IHgucGFyYW1zLmRpcmVjdGlvbiB9LCB4LnJ0bCA9IHguaXNIb3Jpem9udGFsKCkgJiYgKFwicnRsXCIgPT09IHguY29udGFpbmVyWzBdLmRpci50b0xvd2VyQ2FzZSgpIHx8IFwicnRsXCIgPT09IHguY29udGFpbmVyLmNzcyhcImRpcmVjdGlvblwiKSksIHgucnRsICYmIHguY2xhc3NOYW1lcy5wdXNoKHgucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBcInJ0bFwiKSwgeC5ydGwgJiYgKHgud3JvbmdSVEwgPSBcIi13ZWJraXQtYm94XCIgPT09IHgud3JhcHBlci5jc3MoXCJkaXNwbGF5XCIpKSwgeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSAmJiB4LmNsYXNzTmFtZXMucHVzaCh4LnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgXCJtdWx0aXJvd1wiKSwgeC5kZXZpY2UuYW5kcm9pZCAmJiB4LmNsYXNzTmFtZXMucHVzaCh4LnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzICsgXCJhbmRyb2lkXCIpLCB4LmNvbnRhaW5lci5hZGRDbGFzcyh4LmNsYXNzTmFtZXMuam9pbihcIiBcIikpLCB4LnRyYW5zbGF0ZSA9IDAsIHgucHJvZ3Jlc3MgPSAwLCB4LnZlbG9jaXR5ID0gMCwgeC5sb2NrU3dpcGVUb05leHQgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMuYWxsb3dTd2lwZVRvTmV4dCA9ICExLCB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ID09PSAhMSAmJiB4LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHgudW5zZXRHcmFiQ3Vyc29yKCkgfSwgeC5sb2NrU3dpcGVUb1ByZXYgPSBmdW5jdGlvbigpIHsgeC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiA9ICExLCB4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ID09PSAhMSAmJiB4LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHgudW5zZXRHcmFiQ3Vyc29yKCkgfSwgeC5sb2NrU3dpcGVzID0gZnVuY3Rpb24oKSB7IHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgPSB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ID0gITEsIHgucGFyYW1zLmdyYWJDdXJzb3IgJiYgeC51bnNldEdyYWJDdXJzb3IoKSB9LCB4LnVubG9ja1N3aXBlVG9OZXh0ID0gZnVuY3Rpb24oKSB7IHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgPSAhMCwgeC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiA9PT0gITAgJiYgeC5wYXJhbXMuZ3JhYkN1cnNvciAmJiB4LnNldEdyYWJDdXJzb3IoKSB9LCB4LnVubG9ja1N3aXBlVG9QcmV2ID0gZnVuY3Rpb24oKSB7IHgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgPSAhMCwgeC5wYXJhbXMuYWxsb3dTd2lwZVRvTmV4dCA9PT0gITAgJiYgeC5wYXJhbXMuZ3JhYkN1cnNvciAmJiB4LnNldEdyYWJDdXJzb3IoKSB9LCB4LnVubG9ja1N3aXBlcyA9IGZ1bmN0aW9uKCkgeyB4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ID0geC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiA9ICEwLCB4LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHguc2V0R3JhYkN1cnNvcigpIH0sIHguc2V0R3JhYkN1cnNvciA9IGZ1bmN0aW9uKGUpIHsgeC5jb250YWluZXJbMF0uc3R5bGUuY3Vyc29yID0gXCJtb3ZlXCIsIHguY29udGFpbmVyWzBdLnN0eWxlLmN1cnNvciA9IGUgPyBcIi13ZWJraXQtZ3JhYmJpbmdcIiA6IFwiLXdlYmtpdC1ncmFiXCIsIHguY29udGFpbmVyWzBdLnN0eWxlLmN1cnNvciA9IGUgPyBcIi1tb3otZ3JhYmJpblwiIDogXCItbW96LWdyYWJcIiwgeC5jb250YWluZXJbMF0uc3R5bGUuY3Vyc29yID0gZSA/IFwiZ3JhYmJpbmdcIiA6IFwiZ3JhYlwiIH0sIHgudW5zZXRHcmFiQ3Vyc29yID0gZnVuY3Rpb24oKSB7IHguY29udGFpbmVyWzBdLnN0eWxlLmN1cnNvciA9IFwiXCIgfSwgeC5wYXJhbXMuZ3JhYkN1cnNvciAmJiB4LnNldEdyYWJDdXJzb3IoKSwgeC5pbWFnZXNUb0xvYWQgPSBbXSwgeC5pbWFnZXNMb2FkZWQgPSAwLCB4LmxvYWRJbWFnZSA9IGZ1bmN0aW9uKGUsIGEsIHQsIHMsIHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oKSB7IGkgJiYgaSgpIH1cclxuICAgICAgICAgICAgICAgIHZhciBvO1xyXG4gICAgICAgICAgICAgICAgZS5jb21wbGV0ZSAmJiByID8gbigpIDogYSA/IChvID0gbmV3IHdpbmRvdy5JbWFnZSwgby5vbmxvYWQgPSBuLCBvLm9uZXJyb3IgPSBuLCBzICYmIChvLnNpemVzID0gcyksIHQgJiYgKG8uc3Jjc2V0ID0gdCksIGEgJiYgKG8uc3JjID0gYSkpIDogbigpXHJcbiAgICAgICAgICAgIH0sIHgucHJlbG9hZEltYWdlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHsgdm9pZCAwICE9PSB4ICYmIG51bGwgIT09IHggJiYgeCAmJiAodm9pZCAwICE9PSB4LmltYWdlc0xvYWRlZCAmJiB4LmltYWdlc0xvYWRlZCsrLCB4LmltYWdlc0xvYWRlZCA9PT0geC5pbWFnZXNUb0xvYWQubGVuZ3RoICYmICh4LnBhcmFtcy51cGRhdGVPbkltYWdlc1JlYWR5ICYmIHgudXBkYXRlKCksIHguZW1pdChcIm9uSW1hZ2VzUmVhZHlcIiwgeCkpKSB9XHJcbiAgICAgICAgICAgICAgICB4LmltYWdlc1RvTG9hZCA9IHguY29udGFpbmVyLmZpbmQoXCJpbWdcIik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHguaW1hZ2VzVG9Mb2FkLmxlbmd0aDsgYSsrKSB4LmxvYWRJbWFnZSh4LmltYWdlc1RvTG9hZFthXSwgeC5pbWFnZXNUb0xvYWRbYV0uY3VycmVudFNyYyB8fCB4LmltYWdlc1RvTG9hZFthXS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksIHguaW1hZ2VzVG9Mb2FkW2FdLnNyY3NldCB8fCB4LmltYWdlc1RvTG9hZFthXS5nZXRBdHRyaWJ1dGUoXCJzcmNzZXRcIiksIHguaW1hZ2VzVG9Mb2FkW2FdLnNpemVzIHx8IHguaW1hZ2VzVG9Mb2FkW2FdLmdldEF0dHJpYnV0ZShcInNpemVzXCIpLCAhMCwgZSlcclxuICAgICAgICAgICAgfSwgeC5hdXRvcGxheVRpbWVvdXRJZCA9IHZvaWQgMCwgeC5hdXRvcGxheWluZyA9ICExLCB4LmF1dG9wbGF5UGF1c2VkID0gITEsIHguc3RhcnRBdXRvcGxheSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdm9pZCAwID09PSB4LmF1dG9wbGF5VGltZW91dElkICYmICghIXgucGFyYW1zLmF1dG9wbGF5ICYmICgheC5hdXRvcGxheWluZyAmJiAoeC5hdXRvcGxheWluZyA9ICEwLCB4LmVtaXQoXCJvbkF1dG9wbGF5U3RhcnRcIiwgeCksIHZvaWQgaSgpKSkpIH0sIHguc3RvcEF1dG9wbGF5ID0gZnVuY3Rpb24oZSkgeyB4LmF1dG9wbGF5VGltZW91dElkICYmICh4LmF1dG9wbGF5VGltZW91dElkICYmIGNsZWFyVGltZW91dCh4LmF1dG9wbGF5VGltZW91dElkKSwgeC5hdXRvcGxheWluZyA9ICExLCB4LmF1dG9wbGF5VGltZW91dElkID0gdm9pZCAwLCB4LmVtaXQoXCJvbkF1dG9wbGF5U3RvcFwiLCB4KSkgfSwgeC5wYXVzZUF1dG9wbGF5ID0gZnVuY3Rpb24oZSkgeyB4LmF1dG9wbGF5UGF1c2VkIHx8ICh4LmF1dG9wbGF5VGltZW91dElkICYmIGNsZWFyVGltZW91dCh4LmF1dG9wbGF5VGltZW91dElkKSwgeC5hdXRvcGxheVBhdXNlZCA9ICEwLCAwID09PSBlID8gKHguYXV0b3BsYXlQYXVzZWQgPSAhMSwgaSgpKSA6IHgud3JhcHBlci50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uKCkgeyB4ICYmICh4LmF1dG9wbGF5UGF1c2VkID0gITEsIHguYXV0b3BsYXlpbmcgPyBpKCkgOiB4LnN0b3BBdXRvcGxheSgpKSB9KSkgfSwgeC5taW5UcmFuc2xhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIC14LnNuYXBHcmlkWzBdIH0sIHgubWF4VHJhbnNsYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiAteC5zbmFwR3JpZFt4LnNuYXBHcmlkLmxlbmd0aCAtIDFdIH0sIHgudXBkYXRlQXV0b0hlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUsIGEgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICB0ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChcImF1dG9cIiAhPT0geC5wYXJhbXMuc2xpZGVzUGVyVmlldyAmJiB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSlcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGUgPSAwOyBlIDwgTWF0aC5jZWlsKHgucGFyYW1zLnNsaWRlc1BlclZpZXcpOyBlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB4LmFjdGl2ZUluZGV4ICsgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPiB4LnNsaWRlcy5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goeC5zbGlkZXMuZXEocylbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGEucHVzaCh4LnNsaWRlcy5lcSh4LmFjdGl2ZUluZGV4KVswXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBhW2VdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gYVtlXS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSByID4gdCA/IHIgOiB0XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdCAmJiB4LndyYXBwZXIuY3NzKFwiaGVpZ2h0XCIsIHQgKyBcInB4XCIpXHJcbiAgICAgICAgICAgIH0sIHgudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUsIGE7XHJcbiAgICAgICAgICAgICAgICBlID0gdm9pZCAwICE9PSB4LnBhcmFtcy53aWR0aCA/IHgucGFyYW1zLndpZHRoIDogeC5jb250YWluZXJbMF0uY2xpZW50V2lkdGgsIGEgPSB2b2lkIDAgIT09IHgucGFyYW1zLmhlaWdodCA/IHgucGFyYW1zLmhlaWdodCA6IHguY29udGFpbmVyWzBdLmNsaWVudEhlaWdodCwgMCA9PT0gZSAmJiB4LmlzSG9yaXpvbnRhbCgpIHx8IDAgPT09IGEgJiYgIXguaXNIb3Jpem9udGFsKCkgfHwgKGUgPSBlIC0gcGFyc2VJbnQoeC5jb250YWluZXIuY3NzKFwicGFkZGluZy1sZWZ0XCIpLCAxMCkgLSBwYXJzZUludCh4LmNvbnRhaW5lci5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpLCAxMCksIGEgPSBhIC0gcGFyc2VJbnQoeC5jb250YWluZXIuY3NzKFwicGFkZGluZy10b3BcIiksIDEwKSAtIHBhcnNlSW50KHguY29udGFpbmVyLmNzcyhcInBhZGRpbmctYm90dG9tXCIpLCAxMCksIHgud2lkdGggPSBlLCB4LmhlaWdodCA9IGEsIHguc2l6ZSA9IHguaXNIb3Jpem9udGFsKCkgPyB4LndpZHRoIDogeC5oZWlnaHQpXHJcbiAgICAgICAgICAgIH0sIHgudXBkYXRlU2xpZGVzU2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgeC5zbGlkZXMgPSB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzKSwgeC5zbmFwR3JpZCA9IFtdLCB4LnNsaWRlc0dyaWQgPSBbXSwgeC5zbGlkZXNTaXplc0dyaWQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBlLCBhID0geC5wYXJhbXMuc3BhY2VCZXR3ZWVuLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSAteC5wYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlLFxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0geC5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYSAmJiBhLmluZGV4T2YoXCIlXCIpID49IDAgJiYgKGEgPSBwYXJzZUZsb2F0KGEucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwICogeC5zaXplKSwgeC52aXJ0dWFsU2l6ZSA9IC1hLCB4LnJ0bCA/IHguc2xpZGVzLmNzcyh7IG1hcmdpbkxlZnQ6IFwiXCIsIG1hcmdpblRvcDogXCJcIiB9KSA6IHguc2xpZGVzLmNzcyh7IG1hcmdpblJpZ2h0OiBcIlwiLCBtYXJnaW5Cb3R0b206IFwiXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG47XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSAmJiAobiA9IE1hdGguZmxvb3IoeC5zbGlkZXMubGVuZ3RoIC8geC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSA9PT0geC5zbGlkZXMubGVuZ3RoIC8geC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID8geC5zbGlkZXMubGVuZ3RoIDogTWF0aC5jZWlsKHguc2xpZGVzLmxlbmd0aCAvIHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbikgKiB4LnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4sIFwiYXV0b1wiICE9PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ICYmIFwicm93XCIgPT09IHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgJiYgKG4gPSBNYXRoLm1heChuLCB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ICogeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvLCBsID0geC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gbiAvIGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBwIC0gKHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbiAqIHAgLSB4LnNsaWRlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCB4LnNsaWRlcy5sZW5ndGg7IGUrKykgeyBvID0gMDsgdmFyIG0gPSB4LnNsaWRlcy5lcShlKTsgaWYgKHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDEpIHsgdmFyIHUsIGMsIGc7IFwiY29sdW1uXCIgPT09IHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPyAoYyA9IE1hdGguZmxvb3IoZSAvIGwpLCBnID0gZSAtIGMgKiBsLCAoYyA+IGQgfHwgYyA9PT0gZCAmJiBnID09PSBsIC0gMSkgJiYgKytnID49IGwgJiYgKGcgPSAwLCBjKyspLCB1ID0gYyArIGcgKiBuIC8gbCwgbS5jc3MoeyBcIi13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXBcIjogdSwgXCItbW96LWJveC1vcmRpbmFsLWdyb3VwXCI6IHUsIFwiLW1zLWZsZXgtb3JkZXJcIjogdSwgXCItd2Via2l0LW9yZGVyXCI6IHUsIG9yZGVyOiB1IH0pKSA6IChnID0gTWF0aC5mbG9vcihlIC8gcCksIGMgPSBlIC0gZyAqIHApLCBtLmNzcyhcIm1hcmdpbi1cIiArICh4LmlzSG9yaXpvbnRhbCgpID8gXCJ0b3BcIiA6IFwibGVmdFwiKSwgMCAhPT0gZyAmJiB4LnBhcmFtcy5zcGFjZUJldHdlZW4gJiYgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuICsgXCJweFwiKS5hdHRyKFwiZGF0YS1zd2lwZXItY29sdW1uXCIsIGMpLmF0dHIoXCJkYXRhLXN3aXBlci1yb3dcIiwgZykgfSBcIm5vbmVcIiAhPT0gbS5jc3MoXCJkaXNwbGF5XCIpICYmIChcImF1dG9cIiA9PT0geC5wYXJhbXMuc2xpZGVzUGVyVmlldyA/IChvID0geC5pc0hvcml6b250YWwoKSA/IG0ub3V0ZXJXaWR0aCghMCkgOiBtLm91dGVySGVpZ2h0KCEwKSwgeC5wYXJhbXMucm91bmRMZW5ndGhzICYmIChvID0gcihvKSkpIDogKG8gPSAoeC5zaXplIC0gKHgucGFyYW1zLnNsaWRlc1BlclZpZXcgLSAxKSAqIGEpIC8geC5wYXJhbXMuc2xpZGVzUGVyVmlldywgeC5wYXJhbXMucm91bmRMZW5ndGhzICYmIChvID0gcihvKSksIHguaXNIb3Jpem9udGFsKCkgPyB4LnNsaWRlc1tlXS5zdHlsZS53aWR0aCA9IG8gKyBcInB4XCIgOiB4LnNsaWRlc1tlXS5zdHlsZS5oZWlnaHQgPSBvICsgXCJweFwiKSwgeC5zbGlkZXNbZV0uc3dpcGVyU2xpZGVTaXplID0gbywgeC5zbGlkZXNTaXplc0dyaWQucHVzaChvKSwgeC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyAodCA9IHQgKyBvIC8gMiArIHMgLyAyICsgYSwgMCA9PT0gcyAmJiAwICE9PSBlICYmICh0ID0gdCAtIHguc2l6ZSAvIDIgLSBhKSwgMCA9PT0gZSAmJiAodCA9IHQgLSB4LnNpemUgLyAyIC0gYSksIE1hdGguYWJzKHQpIDwgLjAwMSAmJiAodCA9IDApLCBpICUgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT0gMCAmJiB4LnNuYXBHcmlkLnB1c2godCksIHguc2xpZGVzR3JpZC5wdXNoKHQpKSA6IChpICUgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT0gMCAmJiB4LnNuYXBHcmlkLnB1c2godCksIHguc2xpZGVzR3JpZC5wdXNoKHQpLCB0ID0gdCArIG8gKyBhKSwgeC52aXJ0dWFsU2l6ZSArPSBvICsgYSwgcyA9IG8sIGkrKykgfVxyXG4gICAgICAgICAgICAgICAgICAgIHgudmlydHVhbFNpemUgPSBNYXRoLm1heCh4LnZpcnR1YWxTaXplLCB4LnNpemUpICsgeC5wYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucnRsICYmIHgud3JvbmdSVEwgJiYgKFwic2xpZGVcIiA9PT0geC5wYXJhbXMuZWZmZWN0IHx8IFwiY292ZXJmbG93XCIgPT09IHgucGFyYW1zLmVmZmVjdCkgJiYgeC53cmFwcGVyLmNzcyh7IHdpZHRoOiB4LnZpcnR1YWxTaXplICsgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuICsgXCJweFwiIH0pLCB4LnN1cHBvcnQuZmxleGJveCAmJiAheC5wYXJhbXMuc2V0V3JhcHBlclNpemUgfHwgKHguaXNIb3Jpem9udGFsKCkgPyB4LndyYXBwZXIuY3NzKHsgd2lkdGg6IHgudmlydHVhbFNpemUgKyB4LnBhcmFtcy5zcGFjZUJldHdlZW4gKyBcInB4XCIgfSkgOiB4LndyYXBwZXIuY3NzKHsgaGVpZ2h0OiB4LnZpcnR1YWxTaXplICsgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuICsgXCJweFwiIH0pKSwgeC5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSAmJiAoeC52aXJ0dWFsU2l6ZSA9IChvICsgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuKSAqIG4sIHgudmlydHVhbFNpemUgPSBNYXRoLmNlaWwoeC52aXJ0dWFsU2l6ZSAvIHgucGFyYW1zLnNsaWRlc1BlckNvbHVtbikgLSB4LnBhcmFtcy5zcGFjZUJldHdlZW4sIHguaXNIb3Jpem9udGFsKCkgPyB4LndyYXBwZXIuY3NzKHsgd2lkdGg6IHgudmlydHVhbFNpemUgKyB4LnBhcmFtcy5zcGFjZUJldHdlZW4gKyBcInB4XCIgfSkgOiB4LndyYXBwZXIuY3NzKHsgaGVpZ2h0OiB4LnZpcnR1YWxTaXplICsgeC5wYXJhbXMuc3BhY2VCZXR3ZWVuICsgXCJweFwiIH0pLCB4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChoID0gW10sIGUgPSAwOyBlIDwgeC5zbmFwR3JpZC5sZW5ndGg7IGUrKykgeC5zbmFwR3JpZFtlXSA8IHgudmlydHVhbFNpemUgKyB4LnNuYXBHcmlkWzBdICYmIGgucHVzaCh4LnNuYXBHcmlkW2VdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5zbmFwR3JpZCA9IGhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGggPSBbXSwgZSA9IDA7IGUgPCB4LnNuYXBHcmlkLmxlbmd0aDsgZSsrKSB4LnNuYXBHcmlkW2VdIDw9IHgudmlydHVhbFNpemUgLSB4LnNpemUgJiYgaC5wdXNoKHguc25hcEdyaWRbZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LnNuYXBHcmlkID0gaCwgTWF0aC5mbG9vcih4LnZpcnR1YWxTaXplIC0geC5zaXplKSAtIE1hdGguZmxvb3IoeC5zbmFwR3JpZFt4LnNuYXBHcmlkLmxlbmd0aCAtIDFdKSA+IDEgJiYgeC5zbmFwR3JpZC5wdXNoKHgudmlydHVhbFNpemUgLSB4LnNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHguc25hcEdyaWQubGVuZ3RoICYmICh4LnNuYXBHcmlkID0gWzBdKSwgMCAhPT0geC5wYXJhbXMuc3BhY2VCZXR3ZWVuICYmICh4LmlzSG9yaXpvbnRhbCgpID8geC5ydGwgPyB4LnNsaWRlcy5jc3MoeyBtYXJnaW5MZWZ0OiBhICsgXCJweFwiIH0pIDogeC5zbGlkZXMuY3NzKHsgbWFyZ2luUmlnaHQ6IGEgKyBcInB4XCIgfSkgOiB4LnNsaWRlcy5jc3MoeyBtYXJnaW5Cb3R0b206IGEgKyBcInB4XCIgfSkpLCB4LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzICYmIHgudXBkYXRlU2xpZGVzT2Zmc2V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC51cGRhdGVTbGlkZXNPZmZzZXQgPSBmdW5jdGlvbigpIHsgZm9yICh2YXIgZSA9IDA7IGUgPCB4LnNsaWRlcy5sZW5ndGg7IGUrKykgeC5zbGlkZXNbZV0uc3dpcGVyU2xpZGVPZmZzZXQgPSB4LmlzSG9yaXpvbnRhbCgpID8geC5zbGlkZXNbZV0ub2Zmc2V0TGVmdCA6IHguc2xpZGVzW2VdLm9mZnNldFRvcCB9LCB4LmN1cnJlbnRTbGlkZXNQZXJWaWV3ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSwgYSwgdCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMuY2VudGVyZWRTbGlkZXMpIHsgdmFyIHMsIHIgPSB4LnNsaWRlc1t4LmFjdGl2ZUluZGV4XS5zd2lwZXJTbGlkZVNpemU7IGZvciAoZSA9IHguYWN0aXZlSW5kZXggKyAxOyBlIDwgeC5zbGlkZXMubGVuZ3RoOyBlKyspIHguc2xpZGVzW2VdICYmICFzICYmIChyICs9IHguc2xpZGVzW2VdLnN3aXBlclNsaWRlU2l6ZSwgdCsrLCByID4geC5zaXplICYmIChzID0gITApKTsgZm9yIChhID0geC5hY3RpdmVJbmRleCAtIDE7IGEgPj0gMDsgYS0tKSB4LnNsaWRlc1thXSAmJiAhcyAmJiAociArPSB4LnNsaWRlc1thXS5zd2lwZXJTbGlkZVNpemUsIHQrKywgciA+IHguc2l6ZSAmJiAocyA9ICEwKSkgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0geC5hY3RpdmVJbmRleCArIDE7IGUgPCB4LnNsaWRlcy5sZW5ndGg7IGUrKykgeC5zbGlkZXNHcmlkW2VdIC0geC5zbGlkZXNHcmlkW3guYWN0aXZlSW5kZXhdIDwgeC5zaXplICYmIHQrKztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0XHJcbiAgICAgICAgICAgIH0sIHgudXBkYXRlU2xpZGVzUHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBlICYmIChlID0geC50cmFuc2xhdGUgfHwgMCksIDAgIT09IHguc2xpZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0geC5zbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQgJiYgeC51cGRhdGVTbGlkZXNPZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IC1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucnRsICYmIChhID0gZSksIHguc2xpZGVzLnJlbW92ZUNsYXNzKHgucGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHguc2xpZGVzLmxlbmd0aDsgdCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0geC5zbGlkZXNbdF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gKGEgKyAoeC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyB4Lm1pblRyYW5zbGF0ZSgpIDogMCkgLSBzLnN3aXBlclNsaWRlT2Zmc2V0KSAvIChzLnN3aXBlclNsaWRlU2l6ZSArIHgucGFyYW1zLnNwYWNlQmV0d2Vlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gLShhIC0gcy5zd2lwZXJTbGlkZU9mZnNldCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGkgKyB4LnNsaWRlc1NpemVzR3JpZFt0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpID49IDAgJiYgaSA8IHguc2l6ZSB8fCBuID4gMCAmJiBuIDw9IHguc2l6ZSB8fCBpIDw9IDAgJiYgbiA+PSB4LnNpemUpICYmIHguc2xpZGVzLmVxKHQpLmFkZENsYXNzKHgucGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucHJvZ3Jlc3MgPSB4LnJ0bCA/IC1yIDogclxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC51cGRhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHgudHJhbnNsYXRlIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB4Lm1heFRyYW5zbGF0ZSgpIC0geC5taW5UcmFuc2xhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICB0ID0geC5pc0JlZ2lubmluZyxcclxuICAgICAgICAgICAgICAgICAgICBzID0geC5pc0VuZDtcclxuICAgICAgICAgICAgICAgIDAgPT09IGEgPyAoeC5wcm9ncmVzcyA9IDAsIHguaXNCZWdpbm5pbmcgPSB4LmlzRW5kID0gITApIDogKHgucHJvZ3Jlc3MgPSAoZSAtIHgubWluVHJhbnNsYXRlKCkpIC8gYSwgeC5pc0JlZ2lubmluZyA9IHgucHJvZ3Jlc3MgPD0gMCwgeC5pc0VuZCA9IHgucHJvZ3Jlc3MgPj0gMSksIHguaXNCZWdpbm5pbmcgJiYgIXQgJiYgeC5lbWl0KFwib25SZWFjaEJlZ2lubmluZ1wiLCB4KSwgeC5pc0VuZCAmJiAhcyAmJiB4LmVtaXQoXCJvblJlYWNoRW5kXCIsIHgpLCB4LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzICYmIHgudXBkYXRlU2xpZGVzUHJvZ3Jlc3MoZSksIHguZW1pdChcIm9uUHJvZ3Jlc3NcIiwgeCwgeC5wcm9ncmVzcylcclxuICAgICAgICAgICAgfSwgeC51cGRhdGVBY3RpdmVJbmRleCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUsIGEsIHQsIHMgPSB4LnJ0bCA/IHgudHJhbnNsYXRlIDogLXgudHJhbnNsYXRlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IHguc2xpZGVzR3JpZC5sZW5ndGg7IGErKykgdm9pZCAwICE9PSB4LnNsaWRlc0dyaWRbYSArIDFdID8gcyA+PSB4LnNsaWRlc0dyaWRbYV0gJiYgcyA8IHguc2xpZGVzR3JpZFthICsgMV0gLSAoeC5zbGlkZXNHcmlkW2EgKyAxXSAtIHguc2xpZGVzR3JpZFthXSkgLyAyID8gZSA9IGEgOiBzID49IHguc2xpZGVzR3JpZFthXSAmJiBzIDwgeC5zbGlkZXNHcmlkW2EgKyAxXSAmJiAoZSA9IGEgKyAxKSA6IHMgPj0geC5zbGlkZXNHcmlkW2FdICYmIChlID0gYSk7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4ICYmIChlIDwgMCB8fCB2b2lkIDAgPT09IGUpICYmIChlID0gMCksIHQgPSBNYXRoLmZsb29yKGUgLyB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCksIHQgPj0geC5zbmFwR3JpZC5sZW5ndGggJiYgKHQgPSB4LnNuYXBHcmlkLmxlbmd0aCAtIDEpLCBlICE9PSB4LmFjdGl2ZUluZGV4ICYmICh4LnNuYXBJbmRleCA9IHQsIHgucHJldmlvdXNJbmRleCA9IHguYWN0aXZlSW5kZXgsIHguYWN0aXZlSW5kZXggPSBlLCB4LnVwZGF0ZUNsYXNzZXMoKSwgeC51cGRhdGVSZWFsSW5kZXgoKSlcclxuICAgICAgICAgICAgfSwgeC51cGRhdGVSZWFsSW5kZXggPSBmdW5jdGlvbigpIHsgeC5yZWFsSW5kZXggPSBwYXJzZUludCh4LnNsaWRlcy5lcSh4LmFjdGl2ZUluZGV4KS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgfHwgeC5hY3RpdmVJbmRleCwgMTApIH0sIHgudXBkYXRlQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgeC5zbGlkZXMucmVtb3ZlQ2xhc3MoeC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzcyArIFwiIFwiICsgeC5wYXJhbXMuc2xpZGVOZXh0Q2xhc3MgKyBcIiBcIiArIHgucGFyYW1zLnNsaWRlUHJldkNsYXNzICsgXCIgXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzICsgXCIgXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyArIFwiIFwiICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB4LnNsaWRlcy5lcSh4LmFjdGl2ZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIGEuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzcyksIHMubG9vcCAmJiAoYS5oYXNDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSA/IHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlQ2xhc3MgKyBcIjpub3QoLlwiICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArICcpW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyArIHgucmVhbEluZGV4ICsgJ1wiXScpLmFkZENsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpIDogeC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArIFwiLlwiICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgeC5yZWFsSW5kZXggKyAnXCJdJykuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcykpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBhLm5leHQoXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZU5leHRDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5sb29wICYmIDAgPT09IHQubGVuZ3RoICYmICh0ID0geC5zbGlkZXMuZXEoMCksIHQuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVOZXh0Q2xhc3MpKTtcclxuICAgICAgICAgICAgICAgIHZhciByID0gYS5wcmV2KFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcykuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmxvb3AgJiYgMCA9PT0gci5sZW5ndGggJiYgKHIgPSB4LnNsaWRlcy5lcSgtMSksIHIuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVQcmV2Q2xhc3MpKSwgcy5sb29wICYmICh0Lmhhc0NsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpID8geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArIFwiOm5vdCguXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgJylbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgdC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgKyAnXCJdJykuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpIDogeC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArIFwiLlwiICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgdC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgKyAnXCJdJykuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpLCByLmhhc0NsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpID8geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArIFwiOm5vdCguXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgJylbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgci5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgKyAnXCJdJykuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpIDogeC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArIFwiLlwiICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgci5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgKyAnXCJdJykuYWRkQ2xhc3MoeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpKSwgeC5wYWdpbmF0aW9uQ29udGFpbmVyICYmIHgucGFnaW5hdGlvbkNvbnRhaW5lci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG4gPSB4LnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKCh4LnNsaWRlcy5sZW5ndGggLSAyICogeC5sb29wZWRTbGlkZXMpIC8geC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogeC5zbmFwR3JpZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmxvb3AgPyAoaSA9IE1hdGguY2VpbCgoeC5hY3RpdmVJbmRleCAtIHgubG9vcGVkU2xpZGVzKSAvIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwKSwgaSA+IHguc2xpZGVzLmxlbmd0aCAtIDEgLSAyICogeC5sb29wZWRTbGlkZXMgJiYgKGkgLT0geC5zbGlkZXMubGVuZ3RoIC0gMiAqIHgubG9vcGVkU2xpZGVzKSwgaSA+IG4gLSAxICYmIChpIC09IG4pLCBpIDwgMCAmJiBcImJ1bGxldHNcIiAhPT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUgJiYgKGkgPSBuICsgaSkpIDogaSA9IHZvaWQgMCAhPT0geC5zbmFwSW5kZXggPyB4LnNuYXBJbmRleCA6IHguYWN0aXZlSW5kZXggfHwgMCwgXCJidWxsZXRzXCIgPT09IHgucGFyYW1zLnBhZ2luYXRpb25UeXBlICYmIHguYnVsbGV0cyAmJiB4LmJ1bGxldHMubGVuZ3RoID4gMCAmJiAoeC5idWxsZXRzLnJlbW92ZUNsYXNzKHgucGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKSwgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmxlbmd0aCA+IDEgPyB4LmJ1bGxldHMuZWFjaChmdW5jdGlvbigpIHsgZSh0aGlzKS5pbmRleCgpID09PSBpICYmIGUodGhpcykuYWRkQ2xhc3MoeC5wYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpIH0pIDogeC5idWxsZXRzLmVxKGkpLmFkZENsYXNzKHgucGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKSksIFwiZnJhY3Rpb25cIiA9PT0geC5wYXJhbXMucGFnaW5hdGlvblR5cGUgJiYgKHgucGFnaW5hdGlvbkNvbnRhaW5lci5maW5kKFwiLlwiICsgeC5wYXJhbXMucGFnaW5hdGlvbkN1cnJlbnRDbGFzcykudGV4dChpICsgMSksIHgucGFnaW5hdGlvbkNvbnRhaW5lci5maW5kKFwiLlwiICsgeC5wYXJhbXMucGFnaW5hdGlvblRvdGFsQ2xhc3MpLnRleHQobikpLCBcInByb2dyZXNzXCIgPT09IHgucGFyYW1zLnBhZ2luYXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gKGkgKyAxKSAvIG4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LmlzSG9yaXpvbnRhbCgpIHx8IChwID0gbywgbCA9IDEpLCB4LnBhZ2luYXRpb25Db250YWluZXIuZmluZChcIi5cIiArIHgucGFyYW1zLnBhZ2luYXRpb25Qcm9ncmVzc2JhckNsYXNzKS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGVYKFwiICsgbCArIFwiKSBzY2FsZVkoXCIgKyBwICsgXCIpXCIpLnRyYW5zaXRpb24oeC5wYXJhbXMuc3BlZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFwiY3VzdG9tXCIgPT09IHgucGFyYW1zLnBhZ2luYXRpb25UeXBlICYmIHgucGFyYW1zLnBhZ2luYXRpb25DdXN0b21SZW5kZXIgJiYgKHgucGFnaW5hdGlvbkNvbnRhaW5lci5odG1sKHgucGFyYW1zLnBhZ2luYXRpb25DdXN0b21SZW5kZXIoeCwgaSArIDEsIG4pKSwgeC5lbWl0KFwib25QYWdpbmF0aW9uUmVuZGVyZWRcIiwgeCwgeC5wYWdpbmF0aW9uQ29udGFpbmVyWzBdKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgfHwgKHgucGFyYW1zLnByZXZCdXR0b24gJiYgeC5wcmV2QnV0dG9uICYmIHgucHJldkJ1dHRvbi5sZW5ndGggPiAwICYmICh4LmlzQmVnaW5uaW5nID8gKHgucHJldkJ1dHRvbi5hZGRDbGFzcyh4LnBhcmFtcy5idXR0b25EaXNhYmxlZENsYXNzKSwgeC5wYXJhbXMuYTExeSAmJiB4LmExMXkgJiYgeC5hMTF5LmRpc2FibGUoeC5wcmV2QnV0dG9uKSkgOiAoeC5wcmV2QnV0dG9uLnJlbW92ZUNsYXNzKHgucGFyYW1zLmJ1dHRvbkRpc2FibGVkQ2xhc3MpLCB4LnBhcmFtcy5hMTF5ICYmIHguYTExeSAmJiB4LmExMXkuZW5hYmxlKHgucHJldkJ1dHRvbikpKSwgeC5wYXJhbXMubmV4dEJ1dHRvbiAmJiB4Lm5leHRCdXR0b24gJiYgeC5uZXh0QnV0dG9uLmxlbmd0aCA+IDAgJiYgKHguaXNFbmQgPyAoeC5uZXh0QnV0dG9uLmFkZENsYXNzKHgucGFyYW1zLmJ1dHRvbkRpc2FibGVkQ2xhc3MpLCB4LnBhcmFtcy5hMTF5ICYmIHguYTExeSAmJiB4LmExMXkuZGlzYWJsZSh4Lm5leHRCdXR0b24pKSA6ICh4Lm5leHRCdXR0b24ucmVtb3ZlQ2xhc3MoeC5wYXJhbXMuYnV0dG9uRGlzYWJsZWRDbGFzcyksIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHguYTExeS5lbmFibGUoeC5uZXh0QnV0dG9uKSkpKVxyXG4gICAgICAgICAgICB9LCB4LnVwZGF0ZVBhZ2luYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5wYWdpbmF0aW9uICYmIHgucGFnaW5hdGlvbkNvbnRhaW5lciAmJiB4LnBhZ2luYXRpb25Db250YWluZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJidWxsZXRzXCIgPT09IHgucGFyYW1zLnBhZ2luYXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSB4LnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKCh4LnNsaWRlcy5sZW5ndGggLSAyICogeC5sb29wZWRTbGlkZXMpIC8geC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogeC5zbmFwR3JpZC5sZW5ndGgsIHQgPSAwOyB0IDwgYTsgdCsrKSBlICs9IHgucGFyYW1zLnBhZ2luYXRpb25CdWxsZXRSZW5kZXIgPyB4LnBhcmFtcy5wYWdpbmF0aW9uQnVsbGV0UmVuZGVyKHgsIHQsIHgucGFyYW1zLmJ1bGxldENsYXNzKSA6IFwiPFwiICsgeC5wYXJhbXMucGFnaW5hdGlvbkVsZW1lbnQgKyAnIGNsYXNzPVwiJyArIHgucGFyYW1zLmJ1bGxldENsYXNzICsgJ1wiPjwvJyArIHgucGFyYW1zLnBhZ2luYXRpb25FbGVtZW50ICsgXCI+XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgucGFnaW5hdGlvbkNvbnRhaW5lci5odG1sKGUpLCB4LmJ1bGxldHMgPSB4LnBhZ2luYXRpb25Db250YWluZXIuZmluZChcIi5cIiArIHgucGFyYW1zLmJ1bGxldENsYXNzKSwgeC5wYXJhbXMucGFnaW5hdGlvbkNsaWNrYWJsZSAmJiB4LnBhcmFtcy5hMTF5ICYmIHguYTExeSAmJiB4LmExMXkuaW5pdFBhZ2luYXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcImZyYWN0aW9uXCIgPT09IHgucGFyYW1zLnBhZ2luYXRpb25UeXBlICYmIChlID0geC5wYXJhbXMucGFnaW5hdGlvbkZyYWN0aW9uUmVuZGVyID8geC5wYXJhbXMucGFnaW5hdGlvbkZyYWN0aW9uUmVuZGVyKHgsIHgucGFyYW1zLnBhZ2luYXRpb25DdXJyZW50Q2xhc3MsIHgucGFyYW1zLnBhZ2luYXRpb25Ub3RhbENsYXNzKSA6ICc8c3BhbiBjbGFzcz1cIicgKyB4LnBhcmFtcy5wYWdpbmF0aW9uQ3VycmVudENsYXNzICsgJ1wiPjwvc3Bhbj4gLyA8c3BhbiBjbGFzcz1cIicgKyB4LnBhcmFtcy5wYWdpbmF0aW9uVG90YWxDbGFzcyArICdcIj48L3NwYW4+JywgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmh0bWwoZSkpLCBcInByb2dyZXNzXCIgPT09IHgucGFyYW1zLnBhZ2luYXRpb25UeXBlICYmIChlID0geC5wYXJhbXMucGFnaW5hdGlvblByb2dyZXNzUmVuZGVyID8geC5wYXJhbXMucGFnaW5hdGlvblByb2dyZXNzUmVuZGVyKHgsIHgucGFyYW1zLnBhZ2luYXRpb25Qcm9ncmVzc2JhckNsYXNzKSA6ICc8c3BhbiBjbGFzcz1cIicgKyB4LnBhcmFtcy5wYWdpbmF0aW9uUHJvZ3Jlc3NiYXJDbGFzcyArICdcIj48L3NwYW4+JywgeC5wYWdpbmF0aW9uQ29udGFpbmVyLmh0bWwoZSkpLCBcImN1c3RvbVwiICE9PSB4LnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAmJiB4LmVtaXQoXCJvblBhZ2luYXRpb25SZW5kZXJlZFwiLCB4LCB4LnBhZ2luYXRpb25Db250YWluZXJbMF0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHgudXBkYXRlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYSgpIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnJ0bCwgeC50cmFuc2xhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IE1hdGgubWluKE1hdGgubWF4KHgudHJhbnNsYXRlLCB4Lm1heFRyYW5zbGF0ZSgpKSwgeC5taW5UcmFuc2xhdGUoKSksIHguc2V0V3JhcHBlclRyYW5zbGF0ZSh0KSwgeC51cGRhdGVBY3RpdmVJbmRleCgpLCB4LnVwZGF0ZUNsYXNzZXMoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHgpIHsgeC51cGRhdGVDb250YWluZXJTaXplKCksIHgudXBkYXRlU2xpZGVzU2l6ZSgpLCB4LnVwZGF0ZVByb2dyZXNzKCksIHgudXBkYXRlUGFnaW5hdGlvbigpLCB4LnVwZGF0ZUNsYXNzZXMoKSwgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyLnNldCgpOyB2YXIgdDsgaWYgKGUpIHsgeC5jb250cm9sbGVyICYmIHguY29udHJvbGxlci5zcGxpbmUgJiYgKHguY29udHJvbGxlci5zcGxpbmUgPSB2b2lkIDApLCB4LnBhcmFtcy5mcmVlTW9kZSA/IChhKCksIHgucGFyYW1zLmF1dG9IZWlnaHQgJiYgeC51cGRhdGVBdXRvSGVpZ2h0KCkpIDogKChcImF1dG9cIiA9PT0geC5wYXJhbXMuc2xpZGVzUGVyVmlldyB8fCB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgeC5pc0VuZCAmJiAheC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyB4LnNsaWRlVG8oeC5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgITEsICEwKSA6IHguc2xpZGVUbyh4LmFjdGl2ZUluZGV4LCAwLCAhMSwgITApKSB8fCBhKCkgfSBlbHNlIHgucGFyYW1zLmF1dG9IZWlnaHQgJiYgeC51cGRhdGVBdXRvSGVpZ2h0KCkgfVxyXG4gICAgICAgICAgICB9LCB4Lm9uUmVzaXplID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgeC5wYXJhbXMub25CZWZvcmVSZXNpemUgJiYgeC5wYXJhbXMub25CZWZvcmVSZXNpemUoeCksIHgucGFyYW1zLmJyZWFrcG9pbnRzICYmIHguc2V0QnJlYWtwb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2LFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0O1xyXG4gICAgICAgICAgICAgICAgeC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiA9IHgucGFyYW1zLmFsbG93U3dpcGVUb05leHQgPSAhMCwgeC51cGRhdGVDb250YWluZXJTaXplKCksIHgudXBkYXRlU2xpZGVzU2l6ZSgpLCAoXCJhdXRvXCIgPT09IHgucGFyYW1zLnNsaWRlc1BlclZpZXcgfHwgeC5wYXJhbXMuZnJlZU1vZGUgfHwgZSkgJiYgeC51cGRhdGVQYWdpbmF0aW9uKCksIHgucGFyYW1zLnNjcm9sbGJhciAmJiB4LnNjcm9sbGJhciAmJiB4LnNjcm9sbGJhci5zZXQoKSwgeC5jb250cm9sbGVyICYmIHguY29udHJvbGxlci5zcGxpbmUgJiYgKHguY29udHJvbGxlci5zcGxpbmUgPSB2b2lkIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAhMTtcclxuICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5mcmVlTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5taW4oTWF0aC5tYXgoeC50cmFuc2xhdGUsIHgubWF4VHJhbnNsYXRlKCkpLCB4Lm1pblRyYW5zbGF0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB4LnNldFdyYXBwZXJUcmFuc2xhdGUociksIHgudXBkYXRlQWN0aXZlSW5kZXgoKSwgeC51cGRhdGVDbGFzc2VzKCksIHgucGFyYW1zLmF1dG9IZWlnaHQgJiYgeC51cGRhdGVBdXRvSGVpZ2h0KClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB4LnVwZGF0ZUNsYXNzZXMoKSwgcyA9IChcImF1dG9cIiA9PT0geC5wYXJhbXMuc2xpZGVzUGVyVmlldyB8fCB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgeC5pc0VuZCAmJiAheC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyB4LnNsaWRlVG8oeC5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgITEsICEwKSA6IHguc2xpZGVUbyh4LmFjdGl2ZUluZGV4LCAwLCAhMSwgITApO1xyXG4gICAgICAgICAgICAgICAgeC5wYXJhbXMubGF6eUxvYWRpbmcgJiYgIXMgJiYgeC5sYXp5ICYmIHgubGF6eS5sb2FkKCksIHgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgPSBhLCB4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ID0gdCwgeC5wYXJhbXMub25BZnRlclJlc2l6ZSAmJiB4LnBhcmFtcy5vbkFmdGVyUmVzaXplKHgpXHJcbiAgICAgICAgICAgIH0sIHgudG91Y2hFdmVudHNEZXNrdG9wID0geyBzdGFydDogXCJtb3VzZWRvd25cIiwgbW92ZTogXCJtb3VzZW1vdmVcIiwgZW5kOiBcIm1vdXNldXBcIiB9LCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkID8geC50b3VjaEV2ZW50c0Rlc2t0b3AgPSB7IHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsIG1vdmU6IFwicG9pbnRlcm1vdmVcIiwgZW5kOiBcInBvaW50ZXJ1cFwiIH0gOiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgJiYgKHgudG91Y2hFdmVudHNEZXNrdG9wID0geyBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsIG1vdmU6IFwiTVNQb2ludGVyTW92ZVwiLCBlbmQ6IFwiTVNQb2ludGVyVXBcIiB9KSwgeC50b3VjaEV2ZW50cyA9IHsgc3RhcnQ6IHguc3VwcG9ydC50b3VjaCB8fCAheC5wYXJhbXMuc2ltdWxhdGVUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogeC50b3VjaEV2ZW50c0Rlc2t0b3Auc3RhcnQsIG1vdmU6IHguc3VwcG9ydC50b3VjaCB8fCAheC5wYXJhbXMuc2ltdWxhdGVUb3VjaCA/IFwidG91Y2htb3ZlXCIgOiB4LnRvdWNoRXZlbnRzRGVza3RvcC5tb3ZlLCBlbmQ6IHguc3VwcG9ydC50b3VjaCB8fCAheC5wYXJhbXMuc2ltdWxhdGVUb3VjaCA/IFwidG91Y2hlbmRcIiA6IHgudG91Y2hFdmVudHNEZXNrdG9wLmVuZCB9LCAod2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpICYmIChcImNvbnRhaW5lclwiID09PSB4LnBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA/IHguY29udGFpbmVyIDogeC53cmFwcGVyKS5hZGRDbGFzcyhcInN3aXBlci13cDgtXCIgKyB4LnBhcmFtcy5kaXJlY3Rpb24pLCB4LmluaXRFdmVudHMgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGUgPyBcIm9mZlwiIDogXCJvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBlID8gXCJyZW1vdmVFdmVudExpc3RlbmVyXCIgOiBcImFkZEV2ZW50TGlzdGVuZXJcIixcclxuICAgICAgICAgICAgICAgICAgICByID0gXCJjb250YWluZXJcIiA9PT0geC5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPyB4LmNvbnRhaW5lclswXSA6IHgud3JhcHBlclswXSxcclxuICAgICAgICAgICAgICAgICAgICBpID0geC5zdXBwb3J0LnRvdWNoID8gciA6IGRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSAhIXgucGFyYW1zLm5lc3RlZDtcclxuICAgICAgICAgICAgICAgIGlmICh4LmJyb3dzZXIuaWUpIHJbdF0oeC50b3VjaEV2ZW50cy5zdGFydCwgeC5vblRvdWNoU3RhcnQsICExKSwgaVt0XSh4LnRvdWNoRXZlbnRzLm1vdmUsIHgub25Ub3VjaE1vdmUsIG4pLCBpW3RdKHgudG91Y2hFdmVudHMuZW5kLCB4Lm9uVG91Y2hFbmQsICExKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4LnN1cHBvcnQudG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSAhKFwidG91Y2hzdGFydFwiICE9PSB4LnRvdWNoRXZlbnRzLnN0YXJ0IHx8ICF4LnN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyIHx8ICF4LnBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzKSAmJiB7IHBhc3NpdmU6ICEwLCBjYXB0dXJlOiAhMSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByW3RdKHgudG91Y2hFdmVudHMuc3RhcnQsIHgub25Ub3VjaFN0YXJ0LCBvKSwgclt0XSh4LnRvdWNoRXZlbnRzLm1vdmUsIHgub25Ub3VjaE1vdmUsIG4pLCByW3RdKHgudG91Y2hFdmVudHMuZW5kLCB4Lm9uVG91Y2hFbmQsIG8pXHJcbiAgICAgICAgICAgICAgICAgICAgfShzLnNpbXVsYXRlVG91Y2ggJiYgIXguZGV2aWNlLmlvcyAmJiAheC5kZXZpY2UuYW5kcm9pZCB8fCBzLnNpbXVsYXRlVG91Y2ggJiYgIXguc3VwcG9ydC50b3VjaCAmJiB4LmRldmljZS5pb3MpICYmIChyW3RdKFwibW91c2Vkb3duXCIsIHgub25Ub3VjaFN0YXJ0LCAhMSksIGRvY3VtZW50W3RdKFwibW91c2Vtb3ZlXCIsIHgub25Ub3VjaE1vdmUsIG4pLCBkb2N1bWVudFt0XShcIm1vdXNldXBcIiwgeC5vblRvdWNoRW5kLCAhMSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dbdF0oXCJyZXNpemVcIiwgeC5vblJlc2l6ZSksIHgucGFyYW1zLm5leHRCdXR0b24gJiYgeC5uZXh0QnV0dG9uICYmIHgubmV4dEJ1dHRvbi5sZW5ndGggPiAwICYmICh4Lm5leHRCdXR0b25bYV0oXCJjbGlja1wiLCB4Lm9uQ2xpY2tOZXh0KSwgeC5wYXJhbXMuYTExeSAmJiB4LmExMXkgJiYgeC5uZXh0QnV0dG9uW2FdKFwia2V5ZG93blwiLCB4LmExMXkub25FbnRlcktleSkpLCB4LnBhcmFtcy5wcmV2QnV0dG9uICYmIHgucHJldkJ1dHRvbiAmJiB4LnByZXZCdXR0b24ubGVuZ3RoID4gMCAmJiAoeC5wcmV2QnV0dG9uW2FdKFwiY2xpY2tcIiwgeC5vbkNsaWNrUHJldiksIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHgucHJldkJ1dHRvblthXShcImtleWRvd25cIiwgeC5hMTF5Lm9uRW50ZXJLZXkpKSwgeC5wYXJhbXMucGFnaW5hdGlvbiAmJiB4LnBhcmFtcy5wYWdpbmF0aW9uQ2xpY2thYmxlICYmICh4LnBhZ2luYXRpb25Db250YWluZXJbYV0oXCJjbGlja1wiLCBcIi5cIiArIHgucGFyYW1zLmJ1bGxldENsYXNzLCB4Lm9uQ2xpY2tJbmRleCksIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHgucGFnaW5hdGlvbkNvbnRhaW5lclthXShcImtleWRvd25cIiwgXCIuXCIgKyB4LnBhcmFtcy5idWxsZXRDbGFzcywgeC5hMTF5Lm9uRW50ZXJLZXkpKSwgKHgucGFyYW1zLnByZXZlbnRDbGlja3MgfHwgeC5wYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uKSAmJiByW3RdKFwiY2xpY2tcIiwgeC5wcmV2ZW50Q2xpY2tzLCAhMClcclxuICAgICAgICAgICAgfSwgeC5hdHRhY2hFdmVudHMgPSBmdW5jdGlvbigpIHsgeC5pbml0RXZlbnRzKCkgfSwgeC5kZXRhY2hFdmVudHMgPSBmdW5jdGlvbigpIHsgeC5pbml0RXZlbnRzKCEwKSB9LCB4LmFsbG93Q2xpY2sgPSAhMCwgeC5wcmV2ZW50Q2xpY2tzID0gZnVuY3Rpb24oZSkgeyB4LmFsbG93Q2xpY2sgfHwgKHgucGFyYW1zLnByZXZlbnRDbGlja3MgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCB4LnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24gJiYgeC5hbmltYXRpbmcgJiYgKGUuc3RvcFByb3BhZ2F0aW9uKCksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkpKSB9LCB4Lm9uQ2xpY2tOZXh0ID0gZnVuY3Rpb24oZSkgeyBlLnByZXZlbnREZWZhdWx0KCksIHguaXNFbmQgJiYgIXgucGFyYW1zLmxvb3AgfHwgeC5zbGlkZU5leHQoKSB9LCB4Lm9uQ2xpY2tQcmV2ID0gZnVuY3Rpb24oZSkgeyBlLnByZXZlbnREZWZhdWx0KCksIHguaXNCZWdpbm5pbmcgJiYgIXgucGFyYW1zLmxvb3AgfHwgeC5zbGlkZVByZXYoKSB9LCB4Lm9uQ2xpY2tJbmRleCA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgIGEucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gZSh0aGlzKS5pbmRleCgpICogeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5sb29wICYmICh0ICs9IHgubG9vcGVkU2xpZGVzKSwgeC5zbGlkZVRvKHQpXHJcbiAgICAgICAgICAgIH0sIHgudXBkYXRlQ2xpY2tlZFNsaWRlID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBuKGEsIFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyksXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9ICExO1xyXG4gICAgICAgICAgICAgICAgaWYgKHQpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB4LnNsaWRlcy5sZW5ndGg7IHIrKykgeC5zbGlkZXNbcl0gPT09IHQgJiYgKHMgPSAhMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXQgfHwgIXMpIHJldHVybiB4LmNsaWNrZWRTbGlkZSA9IHZvaWQgMCwgdm9pZCh4LmNsaWNrZWRJbmRleCA9IHZvaWQgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5jbGlja2VkU2xpZGUgPSB0LCB4LmNsaWNrZWRJbmRleCA9IGUodCkuaW5kZXgoKSwgeC5wYXJhbXMuc2xpZGVUb0NsaWNrZWRTbGlkZSAmJiB2b2lkIDAgIT09IHguY2xpY2tlZEluZGV4ICYmIHguY2xpY2tlZEluZGV4ICE9PSB4LmFjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSB4LmNsaWNrZWRJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IFwiYXV0b1wiID09PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID8geC5jdXJyZW50U2xpZGVzUGVyVmlldygpIDogeC5wYXJhbXMuc2xpZGVzUGVyVmlldztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMubG9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5hbmltYXRpbmcpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhcnNlSW50KGUoeC5jbGlja2VkU2xpZGUpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSwgMTApLCB4LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IG8gPCB4Lmxvb3BlZFNsaWRlcyAtIGwgLyAyIHx8IG8gPiB4LnNsaWRlcy5sZW5ndGggLSB4Lmxvb3BlZFNsaWRlcyArIGwgLyAyID8gKHguZml4TG9vcCgpLCBvID0geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgaSArICdcIl06bm90KC4nICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArIFwiKVwiKS5lcSgwKS5pbmRleCgpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB4LnNsaWRlVG8obykgfSwgMCkpIDogeC5zbGlkZVRvKG8pIDogbyA+IHguc2xpZGVzLmxlbmd0aCAtIGwgPyAoeC5maXhMb29wKCksIG8gPSB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyBpICsgJ1wiXTpub3QoLicgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgXCIpXCIpLmVxKDApLmluZGV4KCksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHguc2xpZGVUbyhvKSB9LCAwKSkgOiB4LnNsaWRlVG8obylcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeC5zbGlkZVRvKG8pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBiLCBDLCBTLCB6LCBNLCBQLCBFLCBJLCBrLCBELCBMID0gXCJpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYnV0dG9uLCB2aWRlb1wiLFxyXG4gICAgICAgICAgICAgICAgQiA9IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICBIID0gW107XHJcbiAgICAgICAgICAgIHguYW5pbWF0aW5nID0gITEsIHgudG91Y2hlcyA9IHsgc3RhcnRYOiAwLCBzdGFydFk6IDAsIGN1cnJlbnRYOiAwLCBjdXJyZW50WTogMCwgZGlmZjogMCB9O1xyXG4gICAgICAgICAgICB2YXIgRywgWDtcclxuICAgICAgICAgICAgeC5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5vcmlnaW5hbEV2ZW50ICYmIChhID0gYS5vcmlnaW5hbEV2ZW50KSwgKEcgPSBcInRvdWNoc3RhcnRcIiA9PT0gYS50eXBlKSB8fCAhKFwid2hpY2hcIiBpbiBhKSB8fCAzICE9PSBhLndoaWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLm5vU3dpcGluZyAmJiBuKGEsIFwiLlwiICsgeC5wYXJhbXMubm9Td2lwaW5nQ2xhc3MpKSByZXR1cm4gdm9pZCh4LmFsbG93Q2xpY2sgPSAhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF4LnBhcmFtcy5zd2lwZUhhbmRsZXIgfHwgbihhLCB4LnBhcmFtcy5zd2lwZUhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0geC50b3VjaGVzLmN1cnJlbnRYID0gXCJ0b3VjaHN0YXJ0XCIgPT09IGEudHlwZSA/IGEudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGEucGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0geC50b3VjaGVzLmN1cnJlbnRZID0gXCJ0b3VjaHN0YXJ0XCIgPT09IGEudHlwZSA/IGEudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGEucGFnZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHguZGV2aWNlLmlvcyAmJiB4LnBhcmFtcy5pT1NFZGdlU3dpcGVEZXRlY3Rpb24gJiYgdCA8PSB4LnBhcmFtcy5pT1NFZGdlU3dpcGVUaHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA9ICEwLCBDID0gITEsIFMgPSAhMCwgTSA9IHZvaWQgMCwgWCA9IHZvaWQgMCwgeC50b3VjaGVzLnN0YXJ0WCA9IHQsIHgudG91Y2hlcy5zdGFydFkgPSBzLCB6ID0gRGF0ZS5ub3coKSwgeC5hbGxvd0NsaWNrID0gITAsIHgudXBkYXRlQ29udGFpbmVyU2l6ZSgpLCB4LnN3aXBlRGlyZWN0aW9uID0gdm9pZCAwLCB4LnBhcmFtcy50aHJlc2hvbGQgPiAwICYmIChJID0gITEpLCBcInRvdWNoc3RhcnRcIiAhPT0gYS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAhMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlKGEudGFyZ2V0KS5pcyhMKSAmJiAociA9ICExKSwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBlKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKEwpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpLCByICYmIGEucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5lbWl0KFwib25Ub3VjaFN0YXJ0XCIsIHgsIGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHgub25Ub3VjaE1vdmUgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5vcmlnaW5hbEV2ZW50ICYmIChhID0gYS5vcmlnaW5hbEV2ZW50KSwgIUcgfHwgXCJtb3VzZW1vdmVcIiAhPT0gYS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEucHJldmVudGVkQnlOZXN0ZWRTd2lwZXIpIHJldHVybiB4LnRvdWNoZXMuc3RhcnRYID0gXCJ0b3VjaG1vdmVcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogYS5wYWdlWCwgdm9pZCh4LnRvdWNoZXMuc3RhcnRZID0gXCJ0b3VjaG1vdmVcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogYS5wYWdlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLm9ubHlFeHRlcm5hbCkgcmV0dXJuIHguYWxsb3dDbGljayA9ICExLCB2b2lkKGIgJiYgKHgudG91Y2hlcy5zdGFydFggPSB4LnRvdWNoZXMuY3VycmVudFggPSBcInRvdWNobW92ZVwiID09PSBhLnR5cGUgPyBhLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBhLnBhZ2VYLCB4LnRvdWNoZXMuc3RhcnRZID0geC50b3VjaGVzLmN1cnJlbnRZID0gXCJ0b3VjaG1vdmVcIiA9PT0gYS50eXBlID8gYS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogYS5wYWdlWSwgeiA9IERhdGUubm93KCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoRyAmJiB4LnBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzICYmICF4LnBhcmFtcy5sb29wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pc0hvcml6b250YWwoKSkgeyBpZiAoeC50b3VjaGVzLmN1cnJlbnRYIDwgeC50b3VjaGVzLnN0YXJ0WCAmJiB4LnRyYW5zbGF0ZSA8PSB4Lm1heFRyYW5zbGF0ZSgpIHx8IHgudG91Y2hlcy5jdXJyZW50WCA+IHgudG91Y2hlcy5zdGFydFggJiYgeC50cmFuc2xhdGUgPj0geC5taW5UcmFuc2xhdGUoKSkgcmV0dXJuIH0gZWxzZSBpZiAoeC50b3VjaGVzLmN1cnJlbnRZIDwgeC50b3VjaGVzLnN0YXJ0WSAmJiB4LnRyYW5zbGF0ZSA8PSB4Lm1heFRyYW5zbGF0ZSgpIHx8IHgudG91Y2hlcy5jdXJyZW50WSA+IHgudG91Y2hlcy5zdGFydFkgJiYgeC50cmFuc2xhdGUgPj0geC5taW5UcmFuc2xhdGUoKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChHICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgYS50YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZShhLnRhcmdldCkuaXMoTCkpIHJldHVybiBDID0gITAsIHZvaWQoeC5hbGxvd0NsaWNrID0gITEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTICYmIHguZW1pdChcIm9uVG91Y2hNb3ZlXCIsIHgsIGEpLCAhKGEudGFyZ2V0VG91Y2hlcyAmJiBhLnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgudG91Y2hlcy5jdXJyZW50WCA9IFwidG91Y2htb3ZlXCIgPT09IGEudHlwZSA/IGEudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGEucGFnZVgsIHgudG91Y2hlcy5jdXJyZW50WSA9IFwidG91Y2htb3ZlXCIgPT09IGEudHlwZSA/IGEudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGEucGFnZVksIHZvaWQgMCA9PT0gTSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmlzSG9yaXpvbnRhbCgpICYmIHgudG91Y2hlcy5jdXJyZW50WSA9PT0geC50b3VjaGVzLnN0YXJ0WSB8fCAheC5pc0hvcml6b250YWwoKSAmJiB4LnRvdWNoZXMuY3VycmVudFggPT09IHgudG91Y2hlcy5zdGFydFggPyBNID0gITEgOiAodCA9IDE4MCAqIE1hdGguYXRhbjIoTWF0aC5hYnMoeC50b3VjaGVzLmN1cnJlbnRZIC0geC50b3VjaGVzLnN0YXJ0WSksIE1hdGguYWJzKHgudG91Y2hlcy5jdXJyZW50WCAtIHgudG91Y2hlcy5zdGFydFgpKSAvIE1hdGguUEksIE0gPSB4LmlzSG9yaXpvbnRhbCgpID8gdCA+IHgucGFyYW1zLnRvdWNoQW5nbGUgOiA5MCAtIHQgPiB4LnBhcmFtcy50b3VjaEFuZ2xlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNICYmIHguZW1pdChcIm9uVG91Y2hNb3ZlT3Bwb3NpdGVcIiwgeCwgYSksIHZvaWQgMCA9PT0gWCAmJiAoeC50b3VjaGVzLmN1cnJlbnRYID09PSB4LnRvdWNoZXMuc3RhcnRYICYmIHgudG91Y2hlcy5jdXJyZW50WSA9PT0geC50b3VjaGVzLnN0YXJ0WSB8fCAoWCA9ICEwKSksIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNKSByZXR1cm4gdm9pZChiID0gITEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmFsbG93Q2xpY2sgPSAhMSwgeC5lbWl0KFwib25TbGlkZXJNb3ZlXCIsIHgsIGEpLCBhLnByZXZlbnREZWZhdWx0KCksIHgucGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAheC5wYXJhbXMubmVzdGVkICYmIGEuc3RvcFByb3BhZ2F0aW9uKCksIEMgfHwgKHMubG9vcCAmJiB4LmZpeExvb3AoKSwgRSA9IHguZ2V0V3JhcHBlclRyYW5zbGF0ZSgpLCB4LnNldFdyYXBwZXJUcmFuc2l0aW9uKDApLCB4LmFuaW1hdGluZyAmJiB4LndyYXBwZXIudHJpZ2dlcihcIndlYmtpdFRyYW5zaXRpb25FbmQgdHJhbnNpdGlvbmVuZCBvVHJhbnNpdGlvbkVuZCBNU1RyYW5zaXRpb25FbmQgbXNUcmFuc2l0aW9uRW5kXCIpLCB4LnBhcmFtcy5hdXRvcGxheSAmJiB4LmF1dG9wbGF5aW5nICYmICh4LnBhcmFtcy5hdXRvcGxheURpc2FibGVPbkludGVyYWN0aW9uID8geC5zdG9wQXV0b3BsYXkoKSA6IHgucGF1c2VBdXRvcGxheSgpKSwgRCA9ICExLCAheC5wYXJhbXMuZ3JhYkN1cnNvciB8fCB4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ICE9PSAhMCAmJiB4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ICE9PSAhMCB8fCB4LnNldEdyYWJDdXJzb3IoITApKSwgQyA9ICEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0geC50b3VjaGVzLmRpZmYgPSB4LmlzSG9yaXpvbnRhbCgpID8geC50b3VjaGVzLmN1cnJlbnRYIC0geC50b3VjaGVzLnN0YXJ0WCA6IHgudG91Y2hlcy5jdXJyZW50WSAtIHgudG91Y2hlcy5zdGFydFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciAqPSB4LnBhcmFtcy50b3VjaFJhdGlvLCB4LnJ0bCAmJiAociA9IC1yKSwgeC5zd2lwZURpcmVjdGlvbiA9IHIgPiAwID8gXCJwcmV2XCIgOiBcIm5leHRcIiwgUCA9IHIgKyBFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gITA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPiAwICYmIFAgPiB4Lm1pblRyYW5zbGF0ZSgpID8gKGkgPSAhMSwgeC5wYXJhbXMucmVzaXN0YW5jZSAmJiAoUCA9IHgubWluVHJhbnNsYXRlKCkgLSAxICsgTWF0aC5wb3coLXgubWluVHJhbnNsYXRlKCkgKyBFICsgciwgeC5wYXJhbXMucmVzaXN0YW5jZVJhdGlvKSkpIDogciA8IDAgJiYgUCA8IHgubWF4VHJhbnNsYXRlKCkgJiYgKGkgPSAhMSwgeC5wYXJhbXMucmVzaXN0YW5jZSAmJiAoUCA9IHgubWF4VHJhbnNsYXRlKCkgKyAxIC0gTWF0aC5wb3coeC5tYXhUcmFuc2xhdGUoKSAtIEUgLSByLCB4LnBhcmFtcy5yZXNpc3RhbmNlUmF0aW8pKSksIGkgJiYgKGEucHJldmVudGVkQnlOZXN0ZWRTd2lwZXIgPSAhMCksICF4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ICYmIFwibmV4dFwiID09PSB4LnN3aXBlRGlyZWN0aW9uICYmIFAgPCBFICYmIChQID0gRSksICF4LnBhcmFtcy5hbGxvd1N3aXBlVG9QcmV2ICYmIFwicHJldlwiID09PSB4LnN3aXBlRGlyZWN0aW9uICYmIFAgPiBFICYmIChQID0gRSksIHgucGFyYW1zLnRocmVzaG9sZCA+IDApIHsgaWYgKCEoTWF0aC5hYnMocikgPiB4LnBhcmFtcy50aHJlc2hvbGQgfHwgSSkpIHJldHVybiB2b2lkKFAgPSBFKTsgaWYgKCFJKSByZXR1cm4gSSA9ICEwLCB4LnRvdWNoZXMuc3RhcnRYID0geC50b3VjaGVzLmN1cnJlbnRYLCB4LnRvdWNoZXMuc3RhcnRZID0geC50b3VjaGVzLmN1cnJlbnRZLCBQID0gRSwgdm9pZCh4LnRvdWNoZXMuZGlmZiA9IHguaXNIb3Jpem9udGFsKCkgPyB4LnRvdWNoZXMuY3VycmVudFggLSB4LnRvdWNoZXMuc3RhcnRYIDogeC50b3VjaGVzLmN1cnJlbnRZIC0geC50b3VjaGVzLnN0YXJ0WSkgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgucGFyYW1zLmZvbGxvd0ZpbmdlciAmJiAoKHgucGFyYW1zLmZyZWVNb2RlIHx8IHgucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MpICYmIHgudXBkYXRlQWN0aXZlSW5kZXgoKSwgeC5wYXJhbXMuZnJlZU1vZGUgJiYgKDAgPT09IEgubGVuZ3RoICYmIEgucHVzaCh7IHBvc2l0aW9uOiB4LnRvdWNoZXNbeC5pc0hvcml6b250YWwoKSA/IFwic3RhcnRYXCIgOiBcInN0YXJ0WVwiXSwgdGltZTogeiB9KSwgSC5wdXNoKHsgcG9zaXRpb246IHgudG91Y2hlc1t4LmlzSG9yaXpvbnRhbCgpID8gXCJjdXJyZW50WFwiIDogXCJjdXJyZW50WVwiXSwgdGltZTogKG5ldyB3aW5kb3cuRGF0ZSkuZ2V0VGltZSgpIH0pKSwgeC51cGRhdGVQcm9ncmVzcyhQKSwgeC5zZXRXcmFwcGVyVHJhbnNsYXRlKFApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB4Lm9uVG91Y2hFbmQgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5vcmlnaW5hbEV2ZW50ICYmIChhID0gYS5vcmlnaW5hbEV2ZW50KSwgUyAmJiB4LmVtaXQoXCJvblRvdWNoRW5kXCIsIHgsIGEpLCBTID0gITEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmFtcy5ncmFiQ3Vyc29yICYmIEMgJiYgYiAmJiAoeC5wYXJhbXMuYWxsb3dTd2lwZVRvTmV4dCA9PT0gITAgfHwgeC5wYXJhbXMuYWxsb3dTd2lwZVRvUHJldiA9PT0gITApICYmIHguc2V0R3JhYkN1cnNvcighMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdCAtIHo7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguYWxsb3dDbGljayAmJiAoeC51cGRhdGVDbGlja2VkU2xpZGUoYSksIHguZW1pdChcIm9uVGFwXCIsIHgsIGEpLCBzIDwgMzAwICYmIHQgLSBCID4gMzAwICYmIChrICYmIGNsZWFyVGltZW91dChrKSwgayA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHggJiYgKHgucGFyYW1zLnBhZ2luYXRpb25IaWRlICYmIHgucGFnaW5hdGlvbkNvbnRhaW5lci5sZW5ndGggPiAwICYmICFlKGEudGFyZ2V0KS5oYXNDbGFzcyh4LnBhcmFtcy5idWxsZXRDbGFzcykgJiYgeC5wYWdpbmF0aW9uQ29udGFpbmVyLnRvZ2dsZUNsYXNzKHgucGFyYW1zLnBhZ2luYXRpb25IaWRkZW5DbGFzcyksIHguZW1pdChcIm9uQ2xpY2tcIiwgeCwgYSkpIH0sIDMwMCkpLCBzIDwgMzAwICYmIHQgLSBCIDwgMzAwICYmIChrICYmIGNsZWFyVGltZW91dChrKSwgeC5lbWl0KFwib25Eb3VibGVUYXBcIiwgeCwgYSkpKSwgQiA9IERhdGUubm93KCksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHggJiYgKHguYWxsb3dDbGljayA9ICEwKSB9LCAwKSwgIWIgfHwgIUMgfHwgIXguc3dpcGVEaXJlY3Rpb24gfHwgMCA9PT0geC50b3VjaGVzLmRpZmYgfHwgUCA9PT0gRSkgcmV0dXJuIHZvaWQoYiA9IEMgPSAhMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IEMgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAociA9IHgucGFyYW1zLmZvbGxvd0ZpbmdlciA/IHgucnRsID8geC50cmFuc2xhdGUgOiAteC50cmFuc2xhdGUgOiAtUCwgeC5wYXJhbXMuZnJlZU1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPCAteC5taW5UcmFuc2xhdGUoKSkgcmV0dXJuIHZvaWQgeC5zbGlkZVRvKHguYWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+IC14Lm1heFRyYW5zbGF0ZSgpKSByZXR1cm4gdm9pZCh4LnNsaWRlcy5sZW5ndGggPCB4LnNuYXBHcmlkLmxlbmd0aCA/IHguc2xpZGVUbyh4LnNuYXBHcmlkLmxlbmd0aCAtIDEpIDogeC5zbGlkZVRvKHguc2xpZGVzLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmZyZWVNb2RlTW9tZW50dW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChILmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IEgucG9wKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBILnBvcCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gaS5wb3NpdGlvbiAtIG4ucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBpLnRpbWUgLSBuLnRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC52ZWxvY2l0eSA9IG8gLyBsLCB4LnZlbG9jaXR5ID0geC52ZWxvY2l0eSAvIDIsIE1hdGguYWJzKHgudmVsb2NpdHkpIDwgeC5wYXJhbXMuZnJlZU1vZGVNaW5pbXVtVmVsb2NpdHkgJiYgKHgudmVsb2NpdHkgPSAwKSwgKGwgPiAxNTAgfHwgKG5ldyB3aW5kb3cuRGF0ZSkuZ2V0VGltZSgpIC0gaS50aW1lID4gMzAwKSAmJiAoeC52ZWxvY2l0eSA9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeC52ZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnZlbG9jaXR5ID0geC52ZWxvY2l0eSAqIHgucGFyYW1zLmZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvLCBILmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IDFlMyAqIHgucGFyYW1zLmZyZWVNb2RlTW9tZW50dW1SYXRpbyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0geC52ZWxvY2l0eSAqIHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHgudHJhbnNsYXRlICsgZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgucnRsICYmIChtID0gLW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUsIGMgPSAhMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gMjAgKiBNYXRoLmFicyh4LnZlbG9jaXR5KSAqIHgucGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2VSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtIDwgeC5tYXhUcmFuc2xhdGUoKSkgeC5wYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZSA/IChtICsgeC5tYXhUcmFuc2xhdGUoKSA8IC1nICYmIChtID0geC5tYXhUcmFuc2xhdGUoKSAtIGcpLCB1ID0geC5tYXhUcmFuc2xhdGUoKSwgYyA9ICEwLCBEID0gITApIDogbSA9IHgubWF4VHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtID4geC5taW5UcmFuc2xhdGUoKSkgeC5wYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZSA/IChtIC0geC5taW5UcmFuc2xhdGUoKSA+IGcgJiYgKG0gPSB4Lm1pblRyYW5zbGF0ZSgpICsgZyksIHUgPSB4Lm1pblRyYW5zbGF0ZSgpLCBjID0gITAsIEQgPSAhMCkgOiBtID0geC5taW5UcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgucGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGgsIHYgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodiA9IDA7IHYgPCB4LnNuYXBHcmlkLmxlbmd0aDsgdiArPSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5zbmFwR3JpZFt2XSA+IC1tKSB7IGggPSB2OyBicmVhayB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IE1hdGguYWJzKHguc25hcEdyaWRbaF0gLSBtKSA8IE1hdGguYWJzKHguc25hcEdyaWRbaCAtIDFdIC0gbSkgfHwgXCJuZXh0XCIgPT09IHguc3dpcGVEaXJlY3Rpb24gPyB4LnNuYXBHcmlkW2hdIDogeC5zbmFwR3JpZFtoIC0gMV0sIHgucnRsIHx8IChtID0gLW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCAhPT0geC52ZWxvY2l0eSkgcCA9IHgucnRsID8gTWF0aC5hYnMoKC1tIC0geC50cmFuc2xhdGUpIC8geC52ZWxvY2l0eSkgOiBNYXRoLmFicygobSAtIHgudHJhbnNsYXRlKSAvIHgudmVsb2NpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeC5wYXJhbXMuZnJlZU1vZGVTdGlja3kpIHJldHVybiB2b2lkIHguc2xpZGVSZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5wYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZSAmJiBjID8gKHgudXBkYXRlUHJvZ3Jlc3ModSksIHguc2V0V3JhcHBlclRyYW5zaXRpb24ocCksIHguc2V0V3JhcHBlclRyYW5zbGF0ZShtKSwgeC5vblRyYW5zaXRpb25TdGFydCgpLCB4LmFuaW1hdGluZyA9ICEwLCB4LndyYXBwZXIudHJhbnNpdGlvbkVuZChmdW5jdGlvbigpIHsgeCAmJiBEICYmICh4LmVtaXQoXCJvbk1vbWVudHVtQm91bmNlXCIsIHgpLCB4LnNldFdyYXBwZXJUcmFuc2l0aW9uKHgucGFyYW1zLnNwZWVkKSwgeC5zZXRXcmFwcGVyVHJhbnNsYXRlKHUpLCB4LndyYXBwZXIudHJhbnNpdGlvbkVuZChmdW5jdGlvbigpIHsgeCAmJiB4Lm9uVHJhbnNpdGlvbkVuZCgpIH0pKSB9KSkgOiB4LnZlbG9jaXR5ID8gKHgudXBkYXRlUHJvZ3Jlc3MobSksIHguc2V0V3JhcHBlclRyYW5zaXRpb24ocCksIHguc2V0V3JhcHBlclRyYW5zbGF0ZShtKSwgeC5vblRyYW5zaXRpb25TdGFydCgpLCB4LmFuaW1hdGluZyB8fCAoeC5hbmltYXRpbmcgPSAhMCwgeC53cmFwcGVyLnRyYW5zaXRpb25FbmQoZnVuY3Rpb24oKSB7IHggJiYgeC5vblRyYW5zaXRpb25FbmQoKSB9KSkpIDogeC51cGRhdGVQcm9ncmVzcyhtKSwgeC51cGRhdGVBY3RpdmVJbmRleCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQoKCF4LnBhcmFtcy5mcmVlTW9kZU1vbWVudHVtIHx8IHMgPj0geC5wYXJhbXMubG9uZ1N3aXBlc01zKSAmJiAoeC51cGRhdGVQcm9ncmVzcygpLCB4LnVwZGF0ZUFjdGl2ZUluZGV4KCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiwgdyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB4LnNsaWRlc1NpemVzR3JpZFswXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGYgPSAwOyBmIDwgeC5zbGlkZXNHcmlkLmxlbmd0aDsgZiArPSB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgdm9pZCAwICE9PSB4LnNsaWRlc0dyaWRbZiArIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwXSA/IHIgPj0geC5zbGlkZXNHcmlkW2ZdICYmIHIgPCB4LnNsaWRlc0dyaWRbZiArIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwXSAmJiAodyA9IGYsIHkgPSB4LnNsaWRlc0dyaWRbZiArIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwXSAtIHguc2xpZGVzR3JpZFtmXSkgOiByID49IHguc2xpZGVzR3JpZFtmXSAmJiAodyA9IGYsIHkgPSB4LnNsaWRlc0dyaWRbeC5zbGlkZXNHcmlkLmxlbmd0aCAtIDFdIC0geC5zbGlkZXNHcmlkW3guc2xpZGVzR3JpZC5sZW5ndGggLSAyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIFQgPSAociAtIHguc2xpZGVzR3JpZFt3XSkgLyB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzID4geC5wYXJhbXMubG9uZ1N3aXBlc01zKSB7IGlmICgheC5wYXJhbXMubG9uZ1N3aXBlcykgcmV0dXJuIHZvaWQgeC5zbGlkZVRvKHguYWN0aXZlSW5kZXgpOyBcIm5leHRcIiA9PT0geC5zd2lwZURpcmVjdGlvbiAmJiAoVCA+PSB4LnBhcmFtcy5sb25nU3dpcGVzUmF0aW8gPyB4LnNsaWRlVG8odyArIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHguc2xpZGVUbyh3KSksIFwicHJldlwiID09PSB4LnN3aXBlRGlyZWN0aW9uICYmIChUID4gMSAtIHgucGFyYW1zLmxvbmdTd2lwZXNSYXRpbyA/IHguc2xpZGVUbyh3ICsgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogeC5zbGlkZVRvKHcpKSB9IGVsc2UgeyBpZiAoIXgucGFyYW1zLnNob3J0U3dpcGVzKSByZXR1cm4gdm9pZCB4LnNsaWRlVG8oeC5hY3RpdmVJbmRleCk7IFwibmV4dFwiID09PSB4LnN3aXBlRGlyZWN0aW9uICYmIHguc2xpZGVUbyh3ICsgeC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApLCBcInByZXZcIiA9PT0geC5zd2lwZURpcmVjdGlvbiAmJiB4LnNsaWRlVG8odykgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB4Ll9zbGlkZVRvID0gZnVuY3Rpb24oZSwgYSkgeyByZXR1cm4geC5zbGlkZVRvKGUsIGEsICEwLCAhMCkgfSwgeC5zbGlkZVRvID0gZnVuY3Rpb24oZSwgYSwgdCwgcykge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gITApLCB2b2lkIDAgPT09IGUgJiYgKGUgPSAwKSwgZSA8IDAgJiYgKGUgPSAwKSwgeC5zbmFwSW5kZXggPSBNYXRoLmZsb29yKGUgLyB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCksIHguc25hcEluZGV4ID49IHguc25hcEdyaWQubGVuZ3RoICYmICh4LnNuYXBJbmRleCA9IHguc25hcEdyaWQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IC14LnNuYXBHcmlkW3guc25hcEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5hdXRvcGxheSAmJiB4LmF1dG9wbGF5aW5nICYmIChzIHx8ICF4LnBhcmFtcy5hdXRvcGxheURpc2FibGVPbkludGVyYWN0aW9uID8geC5wYXVzZUF1dG9wbGF5KGEpIDogeC5zdG9wQXV0b3BsYXkoKSksIHgudXBkYXRlUHJvZ3Jlc3MociksIHgucGFyYW1zLm5vcm1hbGl6ZVNsaWRlSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4LnNsaWRlc0dyaWQubGVuZ3RoOyBpKyspIC0gTWF0aC5mbG9vcigxMDAgKiByKSA+PSBNYXRoLmZsb29yKDEwMCAqIHguc2xpZGVzR3JpZFtpXSkgJiYgKGUgPSBpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKCF4LnBhcmFtcy5hbGxvd1N3aXBlVG9OZXh0ICYmIHIgPCB4LnRyYW5zbGF0ZSAmJiByIDwgeC5taW5UcmFuc2xhdGUoKSkgJiYgKCEoIXgucGFyYW1zLmFsbG93U3dpcGVUb1ByZXYgJiYgciA+IHgudHJhbnNsYXRlICYmIHIgPiB4Lm1heFRyYW5zbGF0ZSgpICYmICh4LmFjdGl2ZUluZGV4IHx8IDApICE9PSBlKSAmJiAodm9pZCAwID09PSBhICYmIChhID0geC5wYXJhbXMuc3BlZWQpLCB4LnByZXZpb3VzSW5kZXggPSB4LmFjdGl2ZUluZGV4IHx8IDAsIHguYWN0aXZlSW5kZXggPSBlLCB4LnVwZGF0ZVJlYWxJbmRleCgpLCB4LnJ0bCAmJiAtciA9PT0geC50cmFuc2xhdGUgfHwgIXgucnRsICYmIHIgPT09IHgudHJhbnNsYXRlID8gKHgucGFyYW1zLmF1dG9IZWlnaHQgJiYgeC51cGRhdGVBdXRvSGVpZ2h0KCksIHgudXBkYXRlQ2xhc3NlcygpLCBcInNsaWRlXCIgIT09IHgucGFyYW1zLmVmZmVjdCAmJiB4LnNldFdyYXBwZXJUcmFuc2xhdGUociksICExKSA6ICh4LnVwZGF0ZUNsYXNzZXMoKSwgeC5vblRyYW5zaXRpb25TdGFydCh0KSwgMCA9PT0gYSB8fCB4LmJyb3dzZXIubHRlSUU5ID8gKHguc2V0V3JhcHBlclRyYW5zbGF0ZShyKSwgeC5zZXRXcmFwcGVyVHJhbnNpdGlvbigwKSwgeC5vblRyYW5zaXRpb25FbmQodCkpIDogKHguc2V0V3JhcHBlclRyYW5zbGF0ZShyKSwgeC5zZXRXcmFwcGVyVHJhbnNpdGlvbihhKSwgeC5hbmltYXRpbmcgfHwgKHguYW5pbWF0aW5nID0gITAsIHgud3JhcHBlci50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uKCkgeyB4ICYmIHgub25UcmFuc2l0aW9uRW5kKHQpIH0pKSksICEwKSkpXHJcbiAgICAgICAgICAgIH0sIHgub25UcmFuc2l0aW9uU3RhcnQgPSBmdW5jdGlvbihlKSB7IHZvaWQgMCA9PT0gZSAmJiAoZSA9ICEwKSwgeC5wYXJhbXMuYXV0b0hlaWdodCAmJiB4LnVwZGF0ZUF1dG9IZWlnaHQoKSwgeC5sYXp5ICYmIHgubGF6eS5vblRyYW5zaXRpb25TdGFydCgpLCBlICYmICh4LmVtaXQoXCJvblRyYW5zaXRpb25TdGFydFwiLCB4KSwgeC5hY3RpdmVJbmRleCAhPT0geC5wcmV2aW91c0luZGV4ICYmICh4LmVtaXQoXCJvblNsaWRlQ2hhbmdlU3RhcnRcIiwgeCksIHguYWN0aXZlSW5kZXggPiB4LnByZXZpb3VzSW5kZXggPyB4LmVtaXQoXCJvblNsaWRlTmV4dFN0YXJ0XCIsIHgpIDogeC5lbWl0KFwib25TbGlkZVByZXZTdGFydFwiLCB4KSkpIH0sIHgub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZSkgeyB4LmFuaW1hdGluZyA9ICExLCB4LnNldFdyYXBwZXJUcmFuc2l0aW9uKDApLCB2b2lkIDAgPT09IGUgJiYgKGUgPSAhMCksIHgubGF6eSAmJiB4Lmxhenkub25UcmFuc2l0aW9uRW5kKCksIGUgJiYgKHguZW1pdChcIm9uVHJhbnNpdGlvbkVuZFwiLCB4KSwgeC5hY3RpdmVJbmRleCAhPT0geC5wcmV2aW91c0luZGV4ICYmICh4LmVtaXQoXCJvblNsaWRlQ2hhbmdlRW5kXCIsIHgpLCB4LmFjdGl2ZUluZGV4ID4geC5wcmV2aW91c0luZGV4ID8geC5lbWl0KFwib25TbGlkZU5leHRFbmRcIiwgeCkgOiB4LmVtaXQoXCJvblNsaWRlUHJldkVuZFwiLCB4KSkpLCB4LnBhcmFtcy5oaXN0b3J5ICYmIHguaGlzdG9yeSAmJiB4Lmhpc3Rvcnkuc2V0SGlzdG9yeSh4LnBhcmFtcy5oaXN0b3J5LCB4LmFjdGl2ZUluZGV4KSwgeC5wYXJhbXMuaGFzaG5hdiAmJiB4Lmhhc2huYXYgJiYgeC5oYXNobmF2LnNldEhhc2goKSB9LCB4LnNsaWRlTmV4dCA9IGZ1bmN0aW9uKGUsIGEsIHQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5sb29wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguYW5pbWF0aW5nKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5maXhMb29wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jb250YWluZXJbMF0uY2xpZW50TGVmdDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5zbGlkZVRvKHguYWN0aXZlSW5kZXggKyB4LnBhcmFtcy5zbGlkZXNQZXJHcm91cCwgYSwgZSwgdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnNsaWRlVG8oeC5hY3RpdmVJbmRleCArIHgucGFyYW1zLnNsaWRlc1Blckdyb3VwLCBhLCBlLCB0KVxyXG4gICAgICAgICAgICB9LCB4Ll9zbGlkZU5leHQgPSBmdW5jdGlvbihlKSB7IHJldHVybiB4LnNsaWRlTmV4dCghMCwgZSwgITApIH0sIHguc2xpZGVQcmV2ID0gZnVuY3Rpb24oZSwgYSwgdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5hbmltYXRpbmcpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgICAgICB4LmZpeExvb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB4LmNvbnRhaW5lclswXS5jbGllbnRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnNsaWRlVG8oeC5hY3RpdmVJbmRleCAtIDEsIGEsIGUsIHQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5zbGlkZVRvKHguYWN0aXZlSW5kZXggLSAxLCBhLCBlLCB0KVxyXG4gICAgICAgICAgICB9LCB4Ll9zbGlkZVByZXYgPSBmdW5jdGlvbihlKSB7IHJldHVybiB4LnNsaWRlUHJldighMCwgZSwgITApIH0sIHguc2xpZGVSZXNldCA9IGZ1bmN0aW9uKGUsIGEsIHQpIHsgcmV0dXJuIHguc2xpZGVUbyh4LmFjdGl2ZUluZGV4LCBhLCBlKSB9LCB4LmRpc2FibGVUb3VjaENvbnRyb2wgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHgucGFyYW1zLm9ubHlFeHRlcm5hbCA9ICEwLCAhMCB9LCB4LmVuYWJsZVRvdWNoQ29udHJvbCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4geC5wYXJhbXMub25seUV4dGVybmFsID0gITEsICEwIH0sIHguc2V0V3JhcHBlclRyYW5zaXRpb24gPSBmdW5jdGlvbihlLCBhKSB7IHgud3JhcHBlci50cmFuc2l0aW9uKGUpLCBcInNsaWRlXCIgIT09IHgucGFyYW1zLmVmZmVjdCAmJiB4LmVmZmVjdHNbeC5wYXJhbXMuZWZmZWN0XSAmJiB4LmVmZmVjdHNbeC5wYXJhbXMuZWZmZWN0XS5zZXRUcmFuc2l0aW9uKGUpLCB4LnBhcmFtcy5wYXJhbGxheCAmJiB4LnBhcmFsbGF4ICYmIHgucGFyYWxsYXguc2V0VHJhbnNpdGlvbihlKSwgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyLnNldFRyYW5zaXRpb24oZSksIHgucGFyYW1zLmNvbnRyb2wgJiYgeC5jb250cm9sbGVyICYmIHguY29udHJvbGxlci5zZXRUcmFuc2l0aW9uKGUsIGEpLCB4LmVtaXQoXCJvblNldFRyYW5zaXRpb25cIiwgeCwgZSkgfSwgeC5zZXRXcmFwcGVyVHJhbnNsYXRlID0gZnVuY3Rpb24oZSwgYSwgdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgeC5pc0hvcml6b250YWwoKSA/IHMgPSB4LnJ0bCA/IC1lIDogZSA6IGkgPSBlLCB4LnBhcmFtcy5yb3VuZExlbmd0aHMgJiYgKHMgPSByKHMpLCBpID0gcihpKSksIHgucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgfHwgKHguc3VwcG9ydC50cmFuc2Zvcm1zM2QgPyB4LndyYXBwZXIudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIgKyBzICsgXCJweCwgXCIgKyBpICsgXCJweCwgMHB4KVwiKSA6IHgud3JhcHBlci50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUoXCIgKyBzICsgXCJweCwgXCIgKyBpICsgXCJweClcIikpLCB4LnRyYW5zbGF0ZSA9IHguaXNIb3Jpem9udGFsKCkgPyBzIDogaTtcclxuICAgICAgICAgICAgICAgIHZhciBuLCBvID0geC5tYXhUcmFuc2xhdGUoKSAtIHgubWluVHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBuID0gMCA9PT0gbyA/IDAgOiAoZSAtIHgubWluVHJhbnNsYXRlKCkpIC8gbywgbiAhPT0geC5wcm9ncmVzcyAmJiB4LnVwZGF0ZVByb2dyZXNzKGUpLCBhICYmIHgudXBkYXRlQWN0aXZlSW5kZXgoKSwgXCJzbGlkZVwiICE9PSB4LnBhcmFtcy5lZmZlY3QgJiYgeC5lZmZlY3RzW3gucGFyYW1zLmVmZmVjdF0gJiYgeC5lZmZlY3RzW3gucGFyYW1zLmVmZmVjdF0uc2V0VHJhbnNsYXRlKHgudHJhbnNsYXRlKSwgeC5wYXJhbXMucGFyYWxsYXggJiYgeC5wYXJhbGxheCAmJiB4LnBhcmFsbGF4LnNldFRyYW5zbGF0ZSh4LnRyYW5zbGF0ZSksIHgucGFyYW1zLnNjcm9sbGJhciAmJiB4LnNjcm9sbGJhciAmJiB4LnNjcm9sbGJhci5zZXRUcmFuc2xhdGUoeC50cmFuc2xhdGUpLCB4LnBhcmFtcy5jb250cm9sICYmIHguY29udHJvbGxlciAmJiB4LmNvbnRyb2xsZXIuc2V0VHJhbnNsYXRlKHgudHJhbnNsYXRlLCB0KSwgeC5lbWl0KFwib25TZXRUcmFuc2xhdGVcIiwgeCwgeC50cmFuc2xhdGUpXHJcbiAgICAgICAgICAgIH0sIHguZ2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oZSwgYSkgeyB2YXIgdCwgcywgciwgaTsgcmV0dXJuIHZvaWQgMCA9PT0gYSAmJiAoYSA9IFwieFwiKSwgeC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSA/IHgucnRsID8gLXgudHJhbnNsYXRlIDogeC50cmFuc2xhdGUgOiAociA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsIG51bGwpLCB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4ID8gKHMgPSByLnRyYW5zZm9ybSB8fCByLndlYmtpdFRyYW5zZm9ybSwgcy5zcGxpdChcIixcIikubGVuZ3RoID4gNiAmJiAocyA9IHMuc3BsaXQoXCIsIFwiKS5tYXAoZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5yZXBsYWNlKFwiLFwiLCBcIi5cIikgfSkuam9pbihcIiwgXCIpKSwgaSA9IG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KFwibm9uZVwiID09PSBzID8gXCJcIiA6IHMpKSA6IChpID0gci5Nb3pUcmFuc2Zvcm0gfHwgci5PVHJhbnNmb3JtIHx8IHIuTXNUcmFuc2Zvcm0gfHwgci5tc1RyYW5zZm9ybSB8fCByLnRyYW5zZm9ybSB8fCByLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIikucmVwbGFjZShcInRyYW5zbGF0ZShcIiwgXCJtYXRyaXgoMSwgMCwgMCwgMSxcIiksIHQgPSBpLnRvU3RyaW5nKCkuc3BsaXQoXCIsXCIpKSwgXCJ4XCIgPT09IGEgJiYgKHMgPSB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4ID8gaS5tNDEgOiAxNiA9PT0gdC5sZW5ndGggPyBwYXJzZUZsb2F0KHRbMTJdKSA6IHBhcnNlRmxvYXQodFs0XSkpLCBcInlcIiA9PT0gYSAmJiAocyA9IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggPyBpLm00MiA6IDE2ID09PSB0Lmxlbmd0aCA/IHBhcnNlRmxvYXQodFsxM10pIDogcGFyc2VGbG9hdCh0WzVdKSksIHgucnRsICYmIHMgJiYgKHMgPSAtcyksIHMgfHwgMCkgfSwgeC5nZXRXcmFwcGVyVHJhbnNsYXRlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gdm9pZCAwID09PSBlICYmIChlID0geC5pc0hvcml6b250YWwoKSA/IFwieFwiIDogXCJ5XCIpLCB4LmdldFRyYW5zbGF0ZSh4LndyYXBwZXJbMF0sIGUpIH0sIHgub2JzZXJ2ZXJzID0gW10sIHguaW5pdE9ic2VydmVycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLm9ic2VydmVQYXJlbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSB4LmNvbnRhaW5lci5wYXJlbnRzKCksIGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKykgbyhlW2FdKTtcclxuICAgICAgICAgICAgICAgIG8oeC5jb250YWluZXJbMF0sIHsgY2hpbGRMaXN0OiAhMSB9KSwgbyh4LndyYXBwZXJbMF0sIHsgYXR0cmlidXRlczogITEgfSlcclxuICAgICAgICAgICAgfSwgeC5kaXNjb25uZWN0T2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHgub2JzZXJ2ZXJzLmxlbmd0aDsgZSsrKSB4Lm9ic2VydmVyc1tlXS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB4Lm9ic2VydmVycyA9IFtdXHJcbiAgICAgICAgICAgIH0sIHguY3JlYXRlTG9vcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgeC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArIFwiLlwiICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgXCJhdXRvXCIgIT09IHgucGFyYW1zLnNsaWRlc1BlclZpZXcgfHwgeC5wYXJhbXMubG9vcGVkU2xpZGVzIHx8ICh4LnBhcmFtcy5sb29wZWRTbGlkZXMgPSBhLmxlbmd0aCksIHgubG9vcGVkU2xpZGVzID0gcGFyc2VJbnQoeC5wYXJhbXMubG9vcGVkU2xpZGVzIHx8IHgucGFyYW1zLnNsaWRlc1BlclZpZXcsIDEwKSwgeC5sb29wZWRTbGlkZXMgPSB4Lmxvb3BlZFNsaWRlcyArIHgucGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzLCB4Lmxvb3BlZFNsaWRlcyA+IGEubGVuZ3RoICYmICh4Lmxvb3BlZFNsaWRlcyA9IGEubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0LCBzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChhLmVhY2goZnVuY3Rpb24odCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPCB4Lmxvb3BlZFNsaWRlcyAmJiByLnB1c2goaSksIHQgPCBhLmxlbmd0aCAmJiB0ID49IGEubGVuZ3RoIC0geC5sb29wZWRTbGlkZXMgJiYgcy5wdXNoKGkpLCBuLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiLCB0KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHgud3JhcHBlci5hcHBlbmQoZShyW3RdLmNsb25lTm9kZSghMCkpLmFkZENsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcclxuICAgICAgICAgICAgICAgIGZvciAodCA9IHMubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pIHgud3JhcHBlci5wcmVwZW5kKGUoc1t0XS5jbG9uZU5vZGUoITApKS5hZGRDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSlcclxuICAgICAgICAgICAgfSwgeC5kZXN0cm95TG9vcCA9IGZ1bmN0aW9uKCkgeyB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUNsYXNzICsgXCIuXCIgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKS5yZW1vdmUoKSwgeC5zbGlkZXMucmVtb3ZlQXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpIH0sIHgucmVMb29wID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB4LmFjdGl2ZUluZGV4IC0geC5sb29wZWRTbGlkZXM7XHJcbiAgICAgICAgICAgICAgICB4LmRlc3Ryb3lMb29wKCksIHguY3JlYXRlTG9vcCgpLCB4LnVwZGF0ZVNsaWRlc1NpemUoKSwgZSAmJiB4LnNsaWRlVG8oYSArIHgubG9vcGVkU2xpZGVzLCAwLCAhMSlcclxuICAgICAgICAgICAgfSwgeC5maXhMb29wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgIHguYWN0aXZlSW5kZXggPCB4Lmxvb3BlZFNsaWRlcyA/IChlID0geC5zbGlkZXMubGVuZ3RoIC0gMyAqIHgubG9vcGVkU2xpZGVzICsgeC5hY3RpdmVJbmRleCwgZSArPSB4Lmxvb3BlZFNsaWRlcywgeC5zbGlkZVRvKGUsIDAsICExLCAhMCkpIDogKFwiYXV0b1wiID09PSB4LnBhcmFtcy5zbGlkZXNQZXJWaWV3ICYmIHguYWN0aXZlSW5kZXggPj0gMiAqIHgubG9vcGVkU2xpZGVzIHx8IHguYWN0aXZlSW5kZXggPiB4LnNsaWRlcy5sZW5ndGggLSAyICogeC5wYXJhbXMuc2xpZGVzUGVyVmlldykgJiYgKGUgPSAteC5zbGlkZXMubGVuZ3RoICsgeC5hY3RpdmVJbmRleCArIHgubG9vcGVkU2xpZGVzLCBlICs9IHgubG9vcGVkU2xpZGVzLCB4LnNsaWRlVG8oZSwgMCwgITEsICEwKSlcclxuICAgICAgICAgICAgfSwgeC5hcHBlbmRTbGlkZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5sb29wICYmIHguZGVzdHJveUxvb3AoKSwgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIGVbYV0gJiYgeC53cmFwcGVyLmFwcGVuZChlW2FdKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgeC53cmFwcGVyLmFwcGVuZChlKTtcclxuICAgICAgICAgICAgICAgIHgucGFyYW1zLmxvb3AgJiYgeC5jcmVhdGVMb29wKCksIHgucGFyYW1zLm9ic2VydmVyICYmIHguc3VwcG9ydC5vYnNlcnZlciB8fCB4LnVwZGF0ZSghMClcclxuICAgICAgICAgICAgfSwgeC5wcmVwZW5kU2xpZGUgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5sb29wICYmIHguZGVzdHJveUxvb3AoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0geC5hY3RpdmVJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykgZVt0XSAmJiB4LndyYXBwZXIucHJlcGVuZChlW3RdKTtcclxuICAgICAgICAgICAgICAgICAgICBhID0geC5hY3RpdmVJbmRleCArIGUubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeC53cmFwcGVyLnByZXBlbmQoZSk7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5sb29wICYmIHguY3JlYXRlTG9vcCgpLCB4LnBhcmFtcy5vYnNlcnZlciAmJiB4LnN1cHBvcnQub2JzZXJ2ZXIgfHwgeC51cGRhdGUoITApLCB4LnNsaWRlVG8oYSwgMCwgITEpXHJcbiAgICAgICAgICAgIH0sIHgucmVtb3ZlU2xpZGUgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5sb29wICYmICh4LmRlc3Ryb3lMb29wKCksIHguc2xpZGVzID0geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcykpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEsIHQgPSB4LmFjdGl2ZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGUubGVuZ3RoOyBzKyspIGEgPSBlW3NdLCB4LnNsaWRlc1thXSAmJiB4LnNsaWRlcy5lcShhKS5yZW1vdmUoKSwgYSA8IHQgJiYgdC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBNYXRoLm1heCh0LCAwKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGEgPSBlLCB4LnNsaWRlc1thXSAmJiB4LnNsaWRlcy5lcShhKS5yZW1vdmUoKSwgYSA8IHQgJiYgdC0tLCB0ID0gTWF0aC5tYXgodCwgMCk7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtcy5sb29wICYmIHguY3JlYXRlTG9vcCgpLCB4LnBhcmFtcy5vYnNlcnZlciAmJiB4LnN1cHBvcnQub2JzZXJ2ZXIgfHwgeC51cGRhdGUoITApLCB4LnBhcmFtcy5sb29wID8geC5zbGlkZVRvKHQgKyB4Lmxvb3BlZFNsaWRlcywgMCwgITEpIDogeC5zbGlkZVRvKHQsIDAsICExKVxyXG4gICAgICAgICAgICB9LCB4LnJlbW92ZUFsbFNsaWRlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IFtdLCBhID0gMDsgYSA8IHguc2xpZGVzLmxlbmd0aDsgYSsrKSBlLnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICB4LnJlbW92ZVNsaWRlKGUpXHJcbiAgICAgICAgICAgIH0sIHguZWZmZWN0cyA9IHtcclxuICAgICAgICAgICAgICAgIGZhZGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHguc2xpZGVzLmxlbmd0aDsgZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHguc2xpZGVzLmVxKGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBhWzBdLnN3aXBlclNsaWRlT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAtdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgfHwgKHMgLT0geC50cmFuc2xhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5pc0hvcml6b250YWwoKSB8fCAociA9IHMsIHMgPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0geC5wYXJhbXMuZmFkZS5jcm9zc0ZhZGUgPyBNYXRoLm1heCgxIC0gTWF0aC5hYnMoYVswXS5wcm9ncmVzcyksIDApIDogMSArIE1hdGgubWluKE1hdGgubWF4KGFbMF0ucHJvZ3Jlc3MsIC0xKSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmNzcyh7IG9wYWNpdHk6IGkgfSkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIgKyBzICsgXCJweCwgXCIgKyByICsgXCJweCwgMHB4KVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LnNsaWRlcy50cmFuc2l0aW9uKGUpLCB4LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIDAgIT09IGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnNsaWRlcy50cmFuc2l0aW9uRW5kKGZ1bmN0aW9uKCkgeyBpZiAoIWEgJiYgeCkgeyBhID0gITAsIHguYW5pbWF0aW5nID0gITE7IGZvciAodmFyIGUgPSBbXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvbmVuZFwiLCBcIm9UcmFuc2l0aW9uRW5kXCIsIFwiTVNUcmFuc2l0aW9uRW5kXCIsIFwibXNUcmFuc2l0aW9uRW5kXCJdLCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHgud3JhcHBlci50cmlnZ2VyKGVbdF0pIH0gfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmbGlwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB4LnNsaWRlcy5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB4LnNsaWRlcy5lcShhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gdFswXS5wcm9ncmVzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgucGFyYW1zLmZsaXAubGltaXRSb3RhdGlvbiAmJiAocyA9IE1hdGgubWF4KE1hdGgubWluKHRbMF0ucHJvZ3Jlc3MsIDEpLCAtMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0WzBdLnN3aXBlclNsaWRlT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAtMTgwICogcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gLXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pc0hvcml6b250YWwoKSA/IHgucnRsICYmIChuID0gLW4pIDogKHAgPSBsLCBsID0gMCwgbyA9IC1uLCBuID0gMCksIHRbMF0uc3R5bGUuekluZGV4ID0gLU1hdGguYWJzKE1hdGgucm91bmQocykpICsgeC5zbGlkZXMubGVuZ3RoLCB4LnBhcmFtcy5mbGlwLnNsaWRlU2hhZG93cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0geC5pc0hvcml6b250YWwoKSA/IHQuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikgOiB0LmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB4LmlzSG9yaXpvbnRhbCgpID8gdC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIikgOiB0LmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gZC5sZW5ndGggJiYgKGQgPSBlKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nICsgKHguaXNIb3Jpem9udGFsKCkgPyBcImxlZnRcIiA6IFwidG9wXCIpICsgJ1wiPjwvZGl2PicpLCB0LmFwcGVuZChkKSksIDAgPT09IG0ubGVuZ3RoICYmIChtID0gZSgnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJyArICh4LmlzSG9yaXpvbnRhbCgpID8gXCJyaWdodFwiIDogXCJib3R0b21cIikgKyAnXCI+PC9kaXY+JyksIHQuYXBwZW5kKG0pKSwgZC5sZW5ndGggJiYgKGRbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KC1zLCAwKSksIG0ubGVuZ3RoICYmIChtWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heChzLCAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIgKyBsICsgXCJweCwgXCIgKyBwICsgXCJweCwgMHB4KSByb3RhdGVYKFwiICsgbyArIFwiZGVnKSByb3RhdGVZKFwiICsgbiArIFwiZGVnKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LnNsaWRlcy50cmFuc2l0aW9uKGEpLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikudHJhbnNpdGlvbihhKSwgeC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSAmJiAwICE9PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5zbGlkZXMuZXEoeC5hY3RpdmVJbmRleCkudHJhbnNpdGlvbkVuZChmdW5jdGlvbigpIHsgaWYgKCF0ICYmIHggJiYgZSh0aGlzKS5oYXNDbGFzcyh4LnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKSkgeyB0ID0gITAsIHguYW5pbWF0aW5nID0gITE7IGZvciAodmFyIGEgPSBbXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvbmVuZFwiLCBcIm9UcmFuc2l0aW9uRW5kXCIsIFwiTVNUcmFuc2l0aW9uRW5kXCIsIFwibXNUcmFuc2l0aW9uRW5kXCJdLCBzID0gMDsgcyA8IGEubGVuZ3RoOyBzKyspIHgud3JhcHBlci50cmlnZ2VyKGFbc10pIH0gfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjdWJlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEsIHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LnBhcmFtcy5jdWJlLnNoYWRvdyAmJiAoeC5pc0hvcml6b250YWwoKSA/IChhID0geC53cmFwcGVyLmZpbmQoXCIuc3dpcGVyLWN1YmUtc2hhZG93XCIpLCAwID09PSBhLmxlbmd0aCAmJiAoYSA9IGUoJzxkaXYgY2xhc3M9XCJzd2lwZXItY3ViZS1zaGFkb3dcIj48L2Rpdj4nKSwgeC53cmFwcGVyLmFwcGVuZChhKSksIGEuY3NzKHsgaGVpZ2h0OiB4LndpZHRoICsgXCJweFwiIH0pKSA6IChhID0geC5jb250YWluZXIuZmluZChcIi5zd2lwZXItY3ViZS1zaGFkb3dcIiksIDAgPT09IGEubGVuZ3RoICYmIChhID0gZSgnPGRpdiBjbGFzcz1cInN3aXBlci1jdWJlLXNoYWRvd1wiPjwvZGl2PicpLCB4LmNvbnRhaW5lci5hcHBlbmQoYSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgeC5zbGlkZXMubGVuZ3RoOyBzKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0geC5zbGlkZXMuZXEocyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDkwICogcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gTWF0aC5mbG9vcihpIC8gMzYwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgucnRsICYmIChpID0gLWksIG4gPSBNYXRoLmZsb29yKC1pIC8gMzYwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IE1hdGgubWF4KE1hdGgubWluKHJbMF0ucHJvZ3Jlc3MsIDEpLCAtMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICUgNCA9PSAwID8gKGwgPSA0ICogLW4gKiB4LnNpemUsIGQgPSAwKSA6IChzIC0gMSkgJSA0ID09IDAgPyAobCA9IDAsIGQgPSA0ICogLW4gKiB4LnNpemUpIDogKHMgLSAyKSAlIDQgPT0gMCA/IChsID0geC5zaXplICsgNCAqIG4gKiB4LnNpemUsIGQgPSB4LnNpemUpIDogKHMgLSAzKSAlIDQgPT0gMCAmJiAobCA9IC14LnNpemUsIGQgPSAzICogeC5zaXplICsgNCAqIHguc2l6ZSAqIG4pLCB4LnJ0bCAmJiAobCA9IC1sKSwgeC5pc0hvcml6b250YWwoKSB8fCAocCA9IGwsIGwgPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gXCJyb3RhdGVYKFwiICsgKHguaXNIb3Jpem9udGFsKCkgPyAwIDogLWkpICsgXCJkZWcpIHJvdGF0ZVkoXCIgKyAoeC5pc0hvcml6b250YWwoKSA/IGkgOiAwKSArIFwiZGVnKSB0cmFuc2xhdGUzZChcIiArIGwgKyBcInB4LCBcIiArIHAgKyBcInB4LCBcIiArIGQgKyBcInB4KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gPD0gMSAmJiBvID4gLTEgJiYgKHQgPSA5MCAqIHMgKyA5MCAqIG8sIHgucnRsICYmICh0ID0gOTAgKiAtcyAtIDkwICogbykpLCByLnRyYW5zZm9ybShtKSwgeC5wYXJhbXMuY3ViZS5zbGlkZVNoYWRvd3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHguaXNIb3Jpem9udGFsKCkgPyByLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpIDogci5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0geC5pc0hvcml6b250YWwoKSA/IHIuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0XCIpIDogci5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IHUubGVuZ3RoICYmICh1ID0gZSgnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJyArICh4LmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiKSArICdcIj48L2Rpdj4nKSwgci5hcHBlbmQodSkpLCAwID09PSBjLmxlbmd0aCAmJiAoYyA9IGUoJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScgKyAoeC5pc0hvcml6b250YWwoKSA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCIpICsgJ1wiPjwvZGl2PicpLCByLmFwcGVuZChjKSksIHUubGVuZ3RoICYmICh1WzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCgtbywgMCkpLCBjLmxlbmd0aCAmJiAoY1swXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgobywgMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgud3JhcHBlci5jc3MoeyBcIi13ZWJraXQtdHJhbnNmb3JtLW9yaWdpblwiOiBcIjUwJSA1MCUgLVwiICsgeC5zaXplIC8gMiArIFwicHhcIiwgXCItbW96LXRyYW5zZm9ybS1vcmlnaW5cIjogXCI1MCUgNTAlIC1cIiArIHguc2l6ZSAvIDIgKyBcInB4XCIsIFwiLW1zLXRyYW5zZm9ybS1vcmlnaW5cIjogXCI1MCUgNTAlIC1cIiArIHguc2l6ZSAvIDIgKyBcInB4XCIsIFwidHJhbnNmb3JtLW9yaWdpblwiOiBcIjUwJSA1MCUgLVwiICsgeC5zaXplIC8gMiArIFwicHhcIiB9KSwgeC5wYXJhbXMuY3ViZS5zaGFkb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5pc0hvcml6b250YWwoKSkgYS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwcHgsIFwiICsgKHgud2lkdGggLyAyICsgeC5wYXJhbXMuY3ViZS5zaGFkb3dPZmZzZXQpICsgXCJweCwgXCIgKyAteC53aWR0aCAvIDIgKyBcInB4KSByb3RhdGVYKDkwZGVnKSByb3RhdGVaKDBkZWcpIHNjYWxlKFwiICsgeC5wYXJhbXMuY3ViZS5zaGFkb3dTY2FsZSArIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gTWF0aC5hYnModCkgLSA5MCAqIE1hdGguZmxvb3IoTWF0aC5hYnModCkgLyA5MCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSAxLjUgLSAoTWF0aC5zaW4oMiAqIGcgKiBNYXRoLlBJIC8gMzYwKSAvIDIgKyBNYXRoLmNvcygyICogZyAqIE1hdGguUEkgLyAzNjApIC8gMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB4LnBhcmFtcy5jdWJlLnNoYWRvd1NjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0geC5wYXJhbXMuY3ViZS5zaGFkb3dTY2FsZSAvIGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcgPSB4LnBhcmFtcy5jdWJlLnNoYWRvd09mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnRyYW5zZm9ybShcInNjYWxlM2QoXCIgKyB2ICsgXCIsIDEsIFwiICsgZiArIFwiKSB0cmFuc2xhdGUzZCgwcHgsIFwiICsgKHguaGVpZ2h0IC8gMiArIHcpICsgXCJweCwgXCIgKyAteC5oZWlnaHQgLyAyIC8gZiArIFwicHgpIHJvdGF0ZVgoLTkwZGVnKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHguaXNTYWZhcmkgfHwgeC5pc1VpV2ViVmlldyA/IC14LnNpemUgLyAyIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC53cmFwcGVyLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDBweCwwLFwiICsgeSArIFwicHgpIHJvdGF0ZVgoXCIgKyAoeC5pc0hvcml6b250YWwoKSA/IDAgOiB0KSArIFwiZGVnKSByb3RhdGVZKFwiICsgKHguaXNIb3Jpem9udGFsKCkgPyAtdCA6IDApICsgXCJkZWcpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbihlKSB7IHguc2xpZGVzLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGUpLCB4LnBhcmFtcy5jdWJlLnNoYWRvdyAmJiAheC5pc0hvcml6b250YWwoKSAmJiB4LmNvbnRhaW5lci5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKS50cmFuc2l0aW9uKGUpIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjb3ZlcmZsb3c6IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0geC50cmFuc2xhdGUsIHQgPSB4LmlzSG9yaXpvbnRhbCgpID8gLWEgKyB4LndpZHRoIC8gMiA6IC1hICsgeC5oZWlnaHQgLyAyLCBzID0geC5pc0hvcml6b250YWwoKSA/IHgucGFyYW1zLmNvdmVyZmxvdy5yb3RhdGUgOiAteC5wYXJhbXMuY292ZXJmbG93LnJvdGF0ZSwgciA9IHgucGFyYW1zLmNvdmVyZmxvdy5kZXB0aCwgaSA9IDAsIG4gPSB4LnNsaWRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0geC5zbGlkZXMuZXEoaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHguc2xpZGVzU2l6ZXNHcmlkW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBvWzBdLnN3aXBlclNsaWRlT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAodCAtIHAgLSBsIC8gMikgLyBsICogeC5wYXJhbXMuY292ZXJmbG93Lm1vZGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB4LmlzSG9yaXpvbnRhbCgpID8gcyAqIGQgOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB4LmlzSG9yaXpvbnRhbCgpID8gMCA6IHMgKiBkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAtciAqIE1hdGguYWJzKGQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSB4LmlzSG9yaXpvbnRhbCgpID8gMCA6IHgucGFyYW1zLmNvdmVyZmxvdy5zdHJldGNoICogZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0geC5pc0hvcml6b250YWwoKSA/IHgucGFyYW1zLmNvdmVyZmxvdy5zdHJldGNoICogZCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhoKSA8IC4wMDEgJiYgKGggPSAwKSwgTWF0aC5hYnMoZykgPCAuMDAxICYmIChnID0gMCksIE1hdGguYWJzKGMpIDwgLjAwMSAmJiAoYyA9IDApLCBNYXRoLmFicyhtKSA8IC4wMDEgJiYgKG0gPSAwKSwgTWF0aC5hYnModSkgPCAuMDAxICYmICh1ID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IFwidHJhbnNsYXRlM2QoXCIgKyBoICsgXCJweCxcIiArIGcgKyBcInB4LFwiICsgYyArIFwicHgpICByb3RhdGVYKFwiICsgdSArIFwiZGVnKSByb3RhdGVZKFwiICsgbSArIFwiZGVnKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8udHJhbnNmb3JtKHYpLCBvWzBdLnN0eWxlLnpJbmRleCA9IDEgLSBNYXRoLmFicyhNYXRoLnJvdW5kKGQpKSwgeC5wYXJhbXMuY292ZXJmbG93LnNsaWRlU2hhZG93cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0geC5pc0hvcml6b250YWwoKSA/IG8uZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikgOiBvLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcgPSB4LmlzSG9yaXpvbnRhbCgpID8gby5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIikgOiBvLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gZi5sZW5ndGggJiYgKGYgPSBlKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nICsgKHguaXNIb3Jpem9udGFsKCkgPyBcImxlZnRcIiA6IFwidG9wXCIpICsgJ1wiPjwvZGl2PicpLCBvLmFwcGVuZChmKSksIDAgPT09IHcubGVuZ3RoICYmICh3ID0gZSgnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJyArICh4LmlzSG9yaXpvbnRhbCgpID8gXCJyaWdodFwiIDogXCJib3R0b21cIikgKyAnXCI+PC9kaXY+JyksIG8uYXBwZW5kKHcpKSwgZi5sZW5ndGggJiYgKGZbMF0uc3R5bGUub3BhY2l0eSA9IGQgPiAwID8gZCA6IDApLCB3Lmxlbmd0aCAmJiAod1swXS5zdHlsZS5vcGFjaXR5ID0gLWQgPiAwID8gLWQgOiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmJyb3dzZXIuaWUpIHsgeC53cmFwcGVyWzBdLnN0eWxlLnBlcnNwZWN0aXZlT3JpZ2luID0gdCArIFwicHggNTAlXCIgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24oZSkgeyB4LnNsaWRlcy50cmFuc2l0aW9uKGUpLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikudHJhbnNpdGlvbihlKSB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHgubGF6eSA9IHtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxJbWFnZUxvYWRlZDogITEsXHJcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VJblNsaWRlOiBmdW5jdGlvbihhLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSAmJiAodm9pZCAwID09PSB0ICYmICh0ID0gITApLCAwICE9PSB4LnNsaWRlcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0geC5zbGlkZXMuZXEoYSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gcy5maW5kKFwiLlwiICsgeC5wYXJhbXMubGF6eUxvYWRpbmdDbGFzcyArIFwiOm5vdCguXCIgKyB4LnBhcmFtcy5sYXp5U3RhdHVzTG9hZGVkQ2xhc3MgKyBcIik6bm90KC5cIiArIHgucGFyYW1zLmxhenlTdGF0dXNMb2FkaW5nQ2xhc3MgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFzLmhhc0NsYXNzKHgucGFyYW1zLmxhenlMb2FkaW5nQ2xhc3MpIHx8IHMuaGFzQ2xhc3MoeC5wYXJhbXMubGF6eVN0YXR1c0xvYWRlZENsYXNzKSB8fCBzLmhhc0NsYXNzKHgucGFyYW1zLmxhenlTdGF0dXNMb2FkaW5nQ2xhc3MpIHx8IChyID0gci5hZGQoc1swXSkpLCAwICE9PSByLmxlbmd0aCAmJiByLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmFkZENsYXNzKHgucGFyYW1zLmxhenlTdGF0dXNMb2FkaW5nQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBhLmF0dHIoXCJkYXRhLWJhY2tncm91bmRcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGEuYXR0cihcImRhdGEtc3JjXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBhLmF0dHIoXCJkYXRhLXNyY3NldFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gYS5hdHRyKFwiZGF0YS1zaXplc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgubG9hZEltYWdlKGFbMF0sIGkgfHwgciwgbiwgbywgITEsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHggJiYgbnVsbCAhPT0geCAmJiB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID8gKGEuY3NzKFwiYmFja2dyb3VuZC1pbWFnZVwiLCAndXJsKFwiJyArIHIgKyAnXCIpJyksIGEucmVtb3ZlQXR0cihcImRhdGEtYmFja2dyb3VuZFwiKSkgOiAobiAmJiAoYS5hdHRyKFwic3Jjc2V0XCIsIG4pLCBhLnJlbW92ZUF0dHIoXCJkYXRhLXNyY3NldFwiKSksIG8gJiYgKGEuYXR0cihcInNpemVzXCIsIG8pLCBhLnJlbW92ZUF0dHIoXCJkYXRhLXNpemVzXCIpKSwgaSAmJiAoYS5hdHRyKFwic3JjXCIsIGkpLCBhLnJlbW92ZUF0dHIoXCJkYXRhLXNyY1wiKSkpLCBhLmFkZENsYXNzKHgucGFyYW1zLmxhenlTdGF0dXNMb2FkZWRDbGFzcykucmVtb3ZlQ2xhc3MoeC5wYXJhbXMubGF6eVN0YXR1c0xvYWRpbmdDbGFzcyksIHMuZmluZChcIi5cIiArIHgucGFyYW1zLmxhenlQcmVsb2FkZXJDbGFzcyArIFwiLCAuXCIgKyB4LnBhcmFtcy5wcmVsb2FkZXJDbGFzcykucmVtb3ZlKCksIHgucGFyYW1zLmxvb3AgJiYgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBzLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLmhhc0NsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB4LndyYXBwZXIuY2hpbGRyZW4oJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicgKyBlICsgJ1wiXTpub3QoLicgKyB4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgubGF6eS5sb2FkSW1hZ2VJblNsaWRlKGwuaW5kZXgoKSwgITEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0geC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcyArICdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInICsgZSArICdcIl0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmxhenkubG9hZEltYWdlSW5TbGlkZShwLmluZGV4KCksICExKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZW1pdChcIm9uTGF6eUltYWdlUmVhZHlcIiwgeCwgc1swXSwgYVswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgeC5lbWl0KFwib25MYXp5SW1hZ2VMb2FkXCIsIHgsIHNbMF0sIGFbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhLCB0ID0geC5wYXJhbXMuc2xpZGVzUGVyVmlldztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJhdXRvXCIgPT09IHQgJiYgKHQgPSAwKSwgeC5sYXp5LmluaXRpYWxJbWFnZUxvYWRlZCB8fCAoeC5sYXp5LmluaXRpYWxJbWFnZUxvYWRlZCA9ICEwKSwgeC5wYXJhbXMud2F0Y2hTbGlkZXNWaXNpYmlsaXR5KSB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZVZpc2libGVDbGFzcykuZWFjaChmdW5jdGlvbigpIHsgeC5sYXp5LmxvYWRJbWFnZUluU2xpZGUoZSh0aGlzKS5pbmRleCgpKSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID4gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhID0geC5hY3RpdmVJbmRleDsgYSA8IHguYWN0aXZlSW5kZXggKyB0OyBhKyspIHguc2xpZGVzW2FdICYmIHgubGF6eS5sb2FkSW1hZ2VJblNsaWRlKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeC5sYXp5LmxvYWRJbWFnZUluU2xpZGUoeC5hY3RpdmVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmxhenlMb2FkaW5nSW5QcmV2TmV4dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiAxIHx8IHgucGFyYW1zLmxhenlMb2FkaW5nSW5QcmV2TmV4dEFtb3VudCAmJiB4LnBhcmFtcy5sYXp5TG9hZGluZ0luUHJldk5leHRBbW91bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHgucGFyYW1zLmxhenlMb2FkaW5nSW5QcmV2TmV4dEFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5taW4oeC5hY3RpdmVJbmRleCArIHIgKyBNYXRoLm1heChzLCByKSwgeC5zbGlkZXMubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gTWF0aC5tYXgoeC5hY3RpdmVJbmRleCAtIE1hdGgubWF4KHIsIHMpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IHguYWN0aXZlSW5kZXggKyB0OyBhIDwgaTsgYSsrKSB4LnNsaWRlc1thXSAmJiB4LmxhenkubG9hZEltYWdlSW5TbGlkZShhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IG47IGEgPCB4LmFjdGl2ZUluZGV4OyBhKyspIHguc2xpZGVzW2FdICYmIHgubGF6eS5sb2FkSW1hZ2VJblNsaWRlKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHgud3JhcHBlci5jaGlsZHJlbihcIi5cIiArIHgucGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ubGVuZ3RoID4gMCAmJiB4LmxhenkubG9hZEltYWdlSW5TbGlkZShvLmluZGV4KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB4LndyYXBwZXIuY2hpbGRyZW4oXCIuXCIgKyB4LnBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLmxlbmd0aCA+IDAgJiYgeC5sYXp5LmxvYWRJbWFnZUluU2xpZGUobC5pbmRleCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25UcmFuc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkgeyB4LnBhcmFtcy5sYXp5TG9hZGluZyAmJiAoeC5wYXJhbXMubGF6eUxvYWRpbmdPblRyYW5zaXRpb25TdGFydCB8fCAheC5wYXJhbXMubGF6eUxvYWRpbmdPblRyYW5zaXRpb25TdGFydCAmJiAheC5sYXp5LmluaXRpYWxJbWFnZUxvYWRlZCkgJiYgeC5sYXp5LmxvYWQoKSB9LFxyXG4gICAgICAgICAgICAgICAgb25UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbigpIHsgeC5wYXJhbXMubGF6eUxvYWRpbmcgJiYgIXgucGFyYW1zLmxhenlMb2FkaW5nT25UcmFuc2l0aW9uU3RhcnQgJiYgeC5sYXp5LmxvYWQoKSB9XHJcbiAgICAgICAgICAgIH0sIHguc2Nyb2xsYmFyID0ge1xyXG4gICAgICAgICAgICAgICAgaXNUb3VjaGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIHNldERyYWdQb3NpdGlvbjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0geC5zY3JvbGxiYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB4LmlzSG9yaXpvbnRhbCgpID8gXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSB8fCBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYIHx8IGUuY2xpZW50WCA6IFwidG91Y2hzdGFydFwiID09PSBlLnR5cGUgfHwgXCJ0b3VjaG1vdmVcIiA9PT0gZS50eXBlID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWSB8fCBlLmNsaWVudFksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0IC0gYS50cmFjay5vZmZzZXQoKVt4LmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiXSAtIGEuZHJhZ1NpemUgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gLXgubWluVHJhbnNsYXRlKCkgKiBhLm1vdmVEaXZpZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gLXgubWF4VHJhbnNsYXRlKCkgKiBhLm1vdmVEaXZpZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPCByID8gcyA9IHIgOiBzID4gaSAmJiAocyA9IGkpLCBzID0gLXMgLyBhLm1vdmVEaXZpZGVyLCB4LnVwZGF0ZVByb2dyZXNzKHMpLCB4LnNldFdyYXBwZXJUcmFuc2xhdGUocywgITApXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4LnNjcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICBhLmlzVG91Y2hlZCA9ICEwLCBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIGEuc2V0RHJhZ1Bvc2l0aW9uKGUpLCBjbGVhclRpbWVvdXQoYS5kcmFnVGltZW91dCksIGEudHJhY2sudHJhbnNpdGlvbigwKSwgeC5wYXJhbXMuc2Nyb2xsYmFySGlkZSAmJiBhLnRyYWNrLmNzcyhcIm9wYWNpdHlcIiwgMSksIHgud3JhcHBlci50cmFuc2l0aW9uKDEwMCksIGEuZHJhZy50cmFuc2l0aW9uKDEwMCksIHguZW1pdChcIm9uU2Nyb2xsYmFyRHJhZ1N0YXJ0XCIsIHgpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZHJhZ01vdmU6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHguc2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaXNUb3VjaGVkICYmIChlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExLCBhLnNldERyYWdQb3NpdGlvbihlKSwgeC53cmFwcGVyLnRyYW5zaXRpb24oMCksIGEudHJhY2sudHJhbnNpdGlvbigwKSwgYS5kcmFnLnRyYW5zaXRpb24oMCksIHguZW1pdChcIm9uU2Nyb2xsYmFyRHJhZ01vdmVcIiwgeCkpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZHJhZ0VuZDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0geC5zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5pc1RvdWNoZWQgJiYgKGEuaXNUb3VjaGVkID0gITEsIHgucGFyYW1zLnNjcm9sbGJhckhpZGUgJiYgKGNsZWFyVGltZW91dChhLmRyYWdUaW1lb3V0KSwgYS5kcmFnVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGEudHJhY2suY3NzKFwib3BhY2l0eVwiLCAwKSwgYS50cmFjay50cmFuc2l0aW9uKDQwMCkgfSwgMWUzKSksIHguZW1pdChcIm9uU2Nyb2xsYmFyRHJhZ0VuZFwiLCB4KSwgeC5wYXJhbXMuc2Nyb2xsYmFyU25hcE9uUmVsZWFzZSAmJiB4LnNsaWRlUmVzZXQoKSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGVFdmVudHM6IGZ1bmN0aW9uKCkgeyByZXR1cm4geC5wYXJhbXMuc2ltdWxhdGVUb3VjaCAhPT0gITEgfHwgeC5zdXBwb3J0LnRvdWNoID8geC50b3VjaEV2ZW50cyA6IHgudG91Y2hFdmVudHNEZXNrdG9wIH0oKSxcclxuICAgICAgICAgICAgICAgIGVuYWJsZURyYWdnYWJsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4LnNjcm9sbGJhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHguc3VwcG9ydC50b3VjaCA/IGEudHJhY2sgOiBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICBlKGEudHJhY2spLm9uKGEuZHJhZ2dhYmxlRXZlbnRzLnN0YXJ0LCBhLmRyYWdTdGFydCksIGUodCkub24oYS5kcmFnZ2FibGVFdmVudHMubW92ZSwgYS5kcmFnTW92ZSksIGUodCkub24oYS5kcmFnZ2FibGVFdmVudHMuZW5kLCBhLmRyYWdFbmQpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZURyYWdnYWJsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4LnNjcm9sbGJhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHguc3VwcG9ydC50b3VjaCA/IGEudHJhY2sgOiBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICBlKGEudHJhY2spLm9mZihhLmRyYWdnYWJsZUV2ZW50cy5zdGFydCwgYS5kcmFnU3RhcnQpLCBlKHQpLm9mZihhLmRyYWdnYWJsZUV2ZW50cy5tb3ZlLCBhLmRyYWdNb3ZlKSwgZSh0KS5vZmYoYS5kcmFnZ2FibGVFdmVudHMuZW5kLCBhLmRyYWdFbmQpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5wYXJhbXMuc2Nyb2xsYmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0geC5zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEudHJhY2sgPSBlKHgucGFyYW1zLnNjcm9sbGJhciksIHgucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHgucGFyYW1zLnNjcm9sbGJhciAmJiBhLnRyYWNrLmxlbmd0aCA+IDEgJiYgMSA9PT0geC5jb250YWluZXIuZmluZCh4LnBhcmFtcy5zY3JvbGxiYXIpLmxlbmd0aCAmJiAoYS50cmFjayA9IHguY29udGFpbmVyLmZpbmQoeC5wYXJhbXMuc2Nyb2xsYmFyKSksIGEuZHJhZyA9IGEudHJhY2suZmluZChcIi5zd2lwZXItc2Nyb2xsYmFyLWRyYWdcIiksIDAgPT09IGEuZHJhZy5sZW5ndGggJiYgKGEuZHJhZyA9IGUoJzxkaXYgY2xhc3M9XCJzd2lwZXItc2Nyb2xsYmFyLWRyYWdcIj48L2Rpdj4nKSwgYS50cmFjay5hcHBlbmQoYS5kcmFnKSksIGEuZHJhZ1swXS5zdHlsZS53aWR0aCA9IFwiXCIsIGEuZHJhZ1swXS5zdHlsZS5oZWlnaHQgPSBcIlwiLCBhLnRyYWNrU2l6ZSA9IHguaXNIb3Jpem9udGFsKCkgPyBhLnRyYWNrWzBdLm9mZnNldFdpZHRoIDogYS50cmFja1swXS5vZmZzZXRIZWlnaHQsIGEuZGl2aWRlciA9IHguc2l6ZSAvIHgudmlydHVhbFNpemUsIGEubW92ZURpdmlkZXIgPSBhLmRpdmlkZXIgKiAoYS50cmFja1NpemUgLyB4LnNpemUpLCBhLmRyYWdTaXplID0gYS50cmFja1NpemUgKiBhLmRpdmlkZXIsIHguaXNIb3Jpem9udGFsKCkgPyBhLmRyYWdbMF0uc3R5bGUud2lkdGggPSBhLmRyYWdTaXplICsgXCJweFwiIDogYS5kcmFnWzBdLnN0eWxlLmhlaWdodCA9IGEuZHJhZ1NpemUgKyBcInB4XCIsIGEuZGl2aWRlciA+PSAxID8gYS50cmFja1swXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIgOiBhLnRyYWNrWzBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiLCB4LnBhcmFtcy5zY3JvbGxiYXJIaWRlICYmIChhLnRyYWNrWzBdLnN0eWxlLm9wYWNpdHkgPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5zY3JvbGxiYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUsIGEgPSB4LnNjcm9sbGJhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoeC50cmFuc2xhdGUsIGEuZHJhZ1NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gKGEudHJhY2tTaXplIC0gYS5kcmFnU2l6ZSkgKiB4LnByb2dyZXNzLCB4LnJ0bCAmJiB4LmlzSG9yaXpvbnRhbCgpID8gKGUgPSAtZSwgZSA+IDAgPyAodCA9IGEuZHJhZ1NpemUgLSBlLCBlID0gMCkgOiAtZSArIGEuZHJhZ1NpemUgPiBhLnRyYWNrU2l6ZSAmJiAodCA9IGEudHJhY2tTaXplICsgZSkpIDogZSA8IDAgPyAodCA9IGEuZHJhZ1NpemUgKyBlLCBlID0gMCkgOiBlICsgYS5kcmFnU2l6ZSA+IGEudHJhY2tTaXplICYmICh0ID0gYS50cmFja1NpemUgLSBlKSwgeC5pc0hvcml6b250YWwoKSA/ICh4LnN1cHBvcnQudHJhbnNmb3JtczNkID8gYS5kcmFnLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiICsgZSArIFwicHgsIDAsIDApXCIpIDogYS5kcmFnLnRyYW5zZm9ybShcInRyYW5zbGF0ZVgoXCIgKyBlICsgXCJweClcIiksIGEuZHJhZ1swXS5zdHlsZS53aWR0aCA9IHQgKyBcInB4XCIpIDogKHguc3VwcG9ydC50cmFuc2Zvcm1zM2QgPyBhLmRyYWcudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMHB4LCBcIiArIGUgKyBcInB4LCAwKVwiKSA6IGEuZHJhZy50cmFuc2Zvcm0oXCJ0cmFuc2xhdGVZKFwiICsgZSArIFwicHgpXCIpLCBhLmRyYWdbMF0uc3R5bGUuaGVpZ2h0ID0gdCArIFwicHhcIiksIHgucGFyYW1zLnNjcm9sbGJhckhpZGUgJiYgKGNsZWFyVGltZW91dChhLnRpbWVvdXQpLCBhLnRyYWNrWzBdLnN0eWxlLm9wYWNpdHkgPSAxLCBhLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBhLnRyYWNrWzBdLnN0eWxlLm9wYWNpdHkgPSAwLCBhLnRyYWNrLnRyYW5zaXRpb24oNDAwKSB9LCAxZTMpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbihlKSB7IHgucGFyYW1zLnNjcm9sbGJhciAmJiB4LnNjcm9sbGJhci5kcmFnLnRyYW5zaXRpb24oZSkgfVxyXG4gICAgICAgICAgICB9LCB4LmNvbnRyb2xsZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBMaW5lYXJTcGxpbmU6IGZ1bmN0aW9uKGUsIGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkgeyB2YXIgZSwgYSwgdDsgcmV0dXJuIGZ1bmN0aW9uKHMsIHIpIHsgZm9yIChhID0gLTEsIGUgPSBzLmxlbmd0aDsgZSAtIGEgPiAxOykgc1t0ID0gZSArIGEgPj4gMV0gPD0gciA/IGEgPSB0IDogZSA9IHQ7IHJldHVybiBlIH0gfSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IGUsIHRoaXMueSA9IGEsIHRoaXMubGFzdEluZGV4ID0gZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzLCByO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgPyAociA9IHQodGhpcy54LCBlKSwgcyA9IHIgLSAxLCAoZSAtIHRoaXMueFtzXSkgKiAodGhpcy55W3JdIC0gdGhpcy55W3NdKSAvICh0aGlzLnhbcl0gLSB0aGlzLnhbc10pICsgdGhpcy55W3NdKSA6IDAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldEludGVycG9sYXRlRnVuY3Rpb246IGZ1bmN0aW9uKGUpIHsgeC5jb250cm9sbGVyLnNwbGluZSB8fCAoeC5jb250cm9sbGVyLnNwbGluZSA9IHgucGFyYW1zLmxvb3AgPyBuZXcgeC5jb250cm9sbGVyLkxpbmVhclNwbGluZSh4LnNsaWRlc0dyaWQsIGUuc2xpZGVzR3JpZCkgOiBuZXcgeC5jb250cm9sbGVyLkxpbmVhclNwbGluZSh4LnNuYXBHcmlkLCBlLnNuYXBHcmlkKSkgfSxcclxuICAgICAgICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoYSkgeyBlID0gYS5ydGwgJiYgXCJob3Jpem9udGFsXCIgPT09IGEucGFyYW1zLmRpcmVjdGlvbiA/IC14LnRyYW5zbGF0ZSA6IHgudHJhbnNsYXRlLCBcInNsaWRlXCIgPT09IHgucGFyYW1zLmNvbnRyb2xCeSAmJiAoeC5jb250cm9sbGVyLmdldEludGVycG9sYXRlRnVuY3Rpb24oYSksIGkgPSAteC5jb250cm9sbGVyLnNwbGluZS5pbnRlcnBvbGF0ZSgtZSkpLCBpICYmIFwiY29udGFpbmVyXCIgIT09IHgucGFyYW1zLmNvbnRyb2xCeSB8fCAociA9IChhLm1heFRyYW5zbGF0ZSgpIC0gYS5taW5UcmFuc2xhdGUoKSkgLyAoeC5tYXhUcmFuc2xhdGUoKSAtIHgubWluVHJhbnNsYXRlKCkpLCBpID0gKGUgLSB4Lm1pblRyYW5zbGF0ZSgpKSAqIHIgKyBhLm1pblRyYW5zbGF0ZSgpKSwgeC5wYXJhbXMuY29udHJvbEludmVyc2UgJiYgKGkgPSBhLm1heFRyYW5zbGF0ZSgpIC0gaSksIGEudXBkYXRlUHJvZ3Jlc3MoaSksIGEuc2V0V3JhcHBlclRyYW5zbGF0ZShpLCAhMSwgeCksIGEudXBkYXRlQWN0aXZlSW5kZXgoKSB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIsIGksIG4gPSB4LnBhcmFtcy5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspIG5bb10gIT09IHQgJiYgbltvXSBpbnN0YW5jZW9mIGEgJiYgcyhuW29dKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIG4gaW5zdGFuY2VvZiBhICYmIHQgIT09IG4gJiYgcyhuKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGEpIHsgYS5zZXRXcmFwcGVyVHJhbnNpdGlvbihlLCB4KSwgMCAhPT0gZSAmJiAoYS5vblRyYW5zaXRpb25TdGFydCgpLCBhLndyYXBwZXIudHJhbnNpdGlvbkVuZChmdW5jdGlvbigpIHsgaSAmJiAoYS5wYXJhbXMubG9vcCAmJiBcInNsaWRlXCIgPT09IHgucGFyYW1zLmNvbnRyb2xCeSAmJiBhLmZpeExvb3AoKSwgYS5vblRyYW5zaXRpb25FbmQoKSkgfSkpIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgciwgaSA9IHgucGFyYW1zLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSBpW3JdICE9PSB0ICYmIGlbcl0gaW5zdGFuY2VvZiBhICYmIHMoaVtyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpIGluc3RhbmNlb2YgYSAmJiB0ICE9PSBpICYmIHMoaSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC5oYXNobmF2ID0ge1xyXG4gICAgICAgICAgICAgICAgb25IYXNoQ2FuZ2U6IGZ1bmN0aW9uKGUsIGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZShcIiNcIiwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdCAhPT0geC5zbGlkZXMuZXEoeC5hY3RpdmVJbmRleCkuYXR0cihcImRhdGEtaGFzaFwiKSAmJiB4LnNsaWRlVG8oeC53cmFwcGVyLmNoaWxkcmVuKFwiLlwiICsgeC5wYXJhbXMuc2xpZGVDbGFzcyArICdbZGF0YS1oYXNoPVwiJyArIHQgKyAnXCJdJykuaW5kZXgoKSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdHRhY2hFdmVudHM6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGEgPyBcIm9mZlwiIDogXCJvblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGUod2luZG93KVt0XShcImhhc2hjaGFuZ2VcIiwgeC5oYXNobmF2Lm9uSGFzaENhbmdlKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldEhhc2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Lmhhc2huYXYuaW5pdGlhbGl6ZWQgJiYgeC5wYXJhbXMuaGFzaG5hdilcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLnJlcGxhY2VTdGF0ZSAmJiB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBcIiNcIiArIHguc2xpZGVzLmVxKHguYWN0aXZlSW5kZXgpLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB4LnNsaWRlcy5lcSh4LmFjdGl2ZUluZGV4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gZS5hdHRyKFwiZGF0YS1oYXNoXCIpIHx8IGUuYXR0cihcImRhdGEtaGlzdG9yeVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmhhc2ggPSBhIHx8IFwiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4LnBhcmFtcy5oYXNobmF2ICYmICF4LnBhcmFtcy5oaXN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHguaGFzaG5hdi5pbml0aWFsaXplZCA9ICEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZShcIiNcIiwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDAsIHQgPSB4LnNsaWRlcy5sZW5ndGg7IGEgPCB0OyBhKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHguc2xpZGVzLmVxKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gcy5hdHRyKFwiZGF0YS1oYXNoXCIpIHx8IHMuYXR0cihcImRhdGEtaGlzdG9yeVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9PT0gZSAmJiAhcy5oYXNDbGFzcyh4LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHMuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5zbGlkZVRvKGksIDAsIHgucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgITApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LnBhcmFtcy5oYXNobmF2V2F0Y2hTdGF0ZSAmJiB4Lmhhc2huYXYuYXR0YWNoRXZlbnRzKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7IHgucGFyYW1zLmhhc2huYXZXYXRjaFN0YXRlICYmIHguaGFzaG5hdi5hdHRhY2hFdmVudHMoITApIH1cclxuICAgICAgICAgICAgfSwgeC5oaXN0b3J5ID0ge1xyXG4gICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLmhpc3RvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuaGlzdG9yeSB8fCAhd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSByZXR1cm4geC5wYXJhbXMuaGlzdG9yeSA9ICExLCB2b2lkKHgucGFyYW1zLmhhc2huYXYgPSAhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHguaGlzdG9yeS5pbml0aWFsaXplZCA9ICEwLCB0aGlzLnBhdGhzID0gdGhpcy5nZXRQYXRoVmFsdWVzKCksICh0aGlzLnBhdGhzLmtleSB8fCB0aGlzLnBhdGhzLnZhbHVlKSAmJiAodGhpcy5zY3JvbGxUb1NsaWRlKDAsIHRoaXMucGF0aHMudmFsdWUsIHgucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCksIHgucGFyYW1zLnJlcGxhY2VTdGF0ZSB8fCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMuc2V0SGlzdG9yeVBvcFN0YXRlKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0SGlzdG9yeVBvcFN0YXRlOiBmdW5jdGlvbigpIHsgeC5oaXN0b3J5LnBhdGhzID0geC5oaXN0b3J5LmdldFBhdGhWYWx1ZXMoKSwgeC5oaXN0b3J5LnNjcm9sbFRvU2xpZGUoeC5wYXJhbXMuc3BlZWQsIHguaGlzdG9yeS5wYXRocy52YWx1ZSwgITEpIH0sXHJcbiAgICAgICAgICAgICAgICBnZXRQYXRoVmFsdWVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zbGljZSgxKS5zcGxpdChcIi9cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBrZXk6IGVbYSAtIDJdLCB2YWx1ZTogZVthIC0gMV0gfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldEhpc3Rvcnk6IGZ1bmN0aW9uKGUsIGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC5oaXN0b3J5LmluaXRpYWxpemVkICYmIHgucGFyYW1zLmhpc3RvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB4LnNsaWRlcy5lcShhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLnNsdWdpZnkodC5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLmluY2x1ZGVzKGUpIHx8IChzID0gZSArIFwiL1wiICsgcyksIHgucGFyYW1zLnJlcGxhY2VTdGF0ZSA/IHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBzKSA6IHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCBzKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzbHVnaWZ5OiBmdW5jdGlvbihlKSB7IHJldHVybiBlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csIFwiLVwiKS5yZXBsYWNlKC9bXlxcd1xcLV0rL2csIFwiXCIpLnJlcGxhY2UoL1xcLVxcLSsvZywgXCItXCIpLnJlcGxhY2UoL14tKy8sIFwiXCIpLnJlcGxhY2UoLy0rJC8sIFwiXCIpIH0sXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxUb1NsaWRlOiBmdW5jdGlvbihlLCBhLCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwLCByID0geC5zbGlkZXMubGVuZ3RoOyBzIDwgcjsgcysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHguc2xpZGVzLmVxKHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLnNsdWdpZnkoaS5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID09PSBhICYmICFpLmhhc0NsYXNzKHgucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBpLmluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5zbGlkZVRvKG8sIGUsIHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB4LnNsaWRlVG8oMCwgZSwgdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeC5kaXNhYmxlS2V5Ym9hcmRDb250cm9sID0gZnVuY3Rpb24oKSB7IHgucGFyYW1zLmtleWJvYXJkQ29udHJvbCA9ICExLCBlKGRvY3VtZW50KS5vZmYoXCJrZXlkb3duXCIsIGwpIH0sIHguZW5hYmxlS2V5Ym9hcmRDb250cm9sID0gZnVuY3Rpb24oKSB7IHgucGFyYW1zLmtleWJvYXJkQ29udHJvbCA9ICEwLCBlKGRvY3VtZW50KS5vbihcImtleWRvd25cIiwgbCkgfSwgeC5tb3VzZXdoZWVsID0geyBldmVudDogITEsIGxhc3RTY3JvbGxUaW1lOiAobmV3IHdpbmRvdy5EYXRlKS5nZXRUaW1lKCkgfSwgeC5wYXJhbXMubW91c2V3aGVlbENvbnRyb2wgJiYgKHgubW91c2V3aGVlbC5ldmVudCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImZpcmVmb3hcIikgPiAtMSA/IFwiRE9NTW91c2VTY3JvbGxcIiA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBcIm9ud2hlZWxcIiBpbiBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBhLnNldEF0dHJpYnV0ZShcIm9ud2hlZWxcIiwgXCJyZXR1cm47XCIpLCBlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBhLm9ud2hlZWxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAhZSAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJcIiwgXCJcIikgIT09ICEwICYmIChlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkV2ZW50cy53aGVlbFwiLCBcIjMuMFwiKSksIGVcclxuICAgICAgICAgICAgfSgpID8gXCJ3aGVlbFwiIDogXCJtb3VzZXdoZWVsXCIpLCB4LmRpc2FibGVNb3VzZXdoZWVsQ29udHJvbCA9IGZ1bmN0aW9uKCkgeyBpZiAoIXgubW91c2V3aGVlbC5ldmVudCkgcmV0dXJuICExOyB2YXIgYSA9IHguY29udGFpbmVyOyByZXR1cm4gXCJjb250YWluZXJcIiAhPT0geC5wYXJhbXMubW91c2V3aGVlbEV2ZW50c1RhcmdlZCAmJiAoYSA9IGUoeC5wYXJhbXMubW91c2V3aGVlbEV2ZW50c1RhcmdlZCkpLCBhLm9mZih4Lm1vdXNld2hlZWwuZXZlbnQsIGQpLCB4LnBhcmFtcy5tb3VzZXdoZWVsQ29udHJvbCA9ICExLCAhMCB9LCB4LmVuYWJsZU1vdXNld2hlZWxDb250cm9sID0gZnVuY3Rpb24oKSB7IGlmICgheC5tb3VzZXdoZWVsLmV2ZW50KSByZXR1cm4gITE7IHZhciBhID0geC5jb250YWluZXI7IHJldHVybiBcImNvbnRhaW5lclwiICE9PSB4LnBhcmFtcy5tb3VzZXdoZWVsRXZlbnRzVGFyZ2VkICYmIChhID0gZSh4LnBhcmFtcy5tb3VzZXdoZWVsRXZlbnRzVGFyZ2VkKSksIGEub24oeC5tb3VzZXdoZWVsLmV2ZW50LCBkKSwgeC5wYXJhbXMubW91c2V3aGVlbENvbnRyb2wgPSAhMCwgITAgfSwgeC5wYXJhbGxheCA9IHtcclxuICAgICAgICAgICAgICAgIHNldFRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jb250YWluZXIuY2hpbGRyZW4oXCJbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XVwiKS5lYWNoKGZ1bmN0aW9uKCkgeyBtKHRoaXMsIHgucHJvZ3Jlc3MpIH0pLCB4LnNsaWRlcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZmluZChcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldXCIpLmVhY2goZnVuY3Rpb24oKSB7IG0odGhpcywgTWF0aC5taW4oTWF0aC5tYXgoYVswXS5wcm9ncmVzcywgLTEpLCAxKSkgfSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSB4LnBhcmFtcy5zcGVlZCksIHguY29udGFpbmVyLmZpbmQoXCJbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XVwiKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gcGFyc2VJbnQodC5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgtZHVyYXRpb25cIiksIDEwKSB8fCBhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSBhICYmIChzID0gMCksIHQudHJhbnNpdGlvbihzKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHguem9vbSA9IHtcclxuICAgICAgICAgICAgICAgIHNjYWxlOiAxLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjYWxlOiAxLFxyXG4gICAgICAgICAgICAgICAgaXNTY2FsaW5nOiAhMSxcclxuICAgICAgICAgICAgICAgIGdlc3R1cmU6IHsgc2xpZGU6IHZvaWQgMCwgc2xpZGVXaWR0aDogdm9pZCAwLCBzbGlkZUhlaWdodDogdm9pZCAwLCBpbWFnZTogdm9pZCAwLCBpbWFnZVdyYXA6IHZvaWQgMCwgem9vbU1heDogeC5wYXJhbXMuem9vbU1heCB9LFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHsgaXNUb3VjaGVkOiB2b2lkIDAsIGlzTW92ZWQ6IHZvaWQgMCwgY3VycmVudFg6IHZvaWQgMCwgY3VycmVudFk6IHZvaWQgMCwgbWluWDogdm9pZCAwLCBtaW5ZOiB2b2lkIDAsIG1heFg6IHZvaWQgMCwgbWF4WTogdm9pZCAwLCB3aWR0aDogdm9pZCAwLCBoZWlnaHQ6IHZvaWQgMCwgc3RhcnRYOiB2b2lkIDAsIHN0YXJ0WTogdm9pZCAwLCB0b3VjaGVzU3RhcnQ6IHt9LCB0b3VjaGVzQ3VycmVudDoge30gfSxcclxuICAgICAgICAgICAgICAgIHZlbG9jaXR5OiB7IHg6IHZvaWQgMCwgeTogdm9pZCAwLCBwcmV2UG9zaXRpb25YOiB2b2lkIDAsIHByZXZQb3NpdGlvblk6IHZvaWQgMCwgcHJldlRpbWU6IHZvaWQgMCB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlczogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBlLnRhcmdldFRvdWNoZXNbMV0ucGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBlLnRhcmdldFRvdWNoZXNbMV0ucGFnZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhzIC0gYSwgMikgKyBNYXRoLnBvdyhyIC0gdCwgMikpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25HZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguem9vbTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXguc3VwcG9ydC5nZXN0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0b3VjaHN0YXJ0XCIgIT09IGEudHlwZSB8fCBcInRvdWNoc3RhcnRcIiA9PT0gYS50eXBlICYmIGEudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuZ2VzdHVyZS5zY2FsZVN0YXJ0ID0gdC5nZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQuZ2VzdHVyZS5zbGlkZSAmJiB0Lmdlc3R1cmUuc2xpZGUubGVuZ3RoIHx8ICh0Lmdlc3R1cmUuc2xpZGUgPSBlKHRoaXMpLCAwID09PSB0Lmdlc3R1cmUuc2xpZGUubGVuZ3RoICYmICh0Lmdlc3R1cmUuc2xpZGUgPSB4LnNsaWRlcy5lcSh4LmFjdGl2ZUluZGV4KSksIHQuZ2VzdHVyZS5pbWFnZSA9IHQuZ2VzdHVyZS5zbGlkZS5maW5kKFwiaW1nLCBzdmcsIGNhbnZhc1wiKSwgdC5nZXN0dXJlLmltYWdlV3JhcCA9IHQuZ2VzdHVyZS5pbWFnZS5wYXJlbnQoXCIuXCIgKyB4LnBhcmFtcy56b29tQ29udGFpbmVyQ2xhc3MpLCB0Lmdlc3R1cmUuem9vbU1heCA9IHQuZ2VzdHVyZS5pbWFnZVdyYXAuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIikgfHwgeC5wYXJhbXMuem9vbU1heCwgMCAhPT0gdC5nZXN0dXJlLmltYWdlV3JhcC5sZW5ndGgpKSkgcmV0dXJuIHZvaWQodC5nZXN0dXJlLmltYWdlID0gdm9pZCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB0Lmdlc3R1cmUuaW1hZ2UudHJhbnNpdGlvbigwKSwgdC5pc1NjYWxpbmcgPSAhMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uR2VzdHVyZUNoYW5nZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0geC56b29tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgheC5zdXBwb3J0Lmdlc3R1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInRvdWNobW92ZVwiICE9PSBlLnR5cGUgfHwgXCJ0b3VjaG1vdmVcIiA9PT0gZS50eXBlICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZ2VzdHVyZS5zY2FsZU1vdmUgPSBhLmdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYS5nZXN0dXJlLmltYWdlICYmIDAgIT09IGEuZ2VzdHVyZS5pbWFnZS5sZW5ndGggJiYgKHguc3VwcG9ydC5nZXN0dXJlcyA/IGEuc2NhbGUgPSBlLnNjYWxlICogYS5jdXJyZW50U2NhbGUgOiBhLnNjYWxlID0gYS5nZXN0dXJlLnNjYWxlTW92ZSAvIGEuZ2VzdHVyZS5zY2FsZVN0YXJ0ICogYS5jdXJyZW50U2NhbGUsIGEuc2NhbGUgPiBhLmdlc3R1cmUuem9vbU1heCAmJiAoYS5zY2FsZSA9IGEuZ2VzdHVyZS56b29tTWF4IC0gMSArIE1hdGgucG93KGEuc2NhbGUgLSBhLmdlc3R1cmUuem9vbU1heCArIDEsIC41KSksIGEuc2NhbGUgPCB4LnBhcmFtcy56b29tTWluICYmIChhLnNjYWxlID0geC5wYXJhbXMuem9vbU1pbiArIDEgLSBNYXRoLnBvdyh4LnBhcmFtcy56b29tTWluIC0gYS5zY2FsZSArIDEsIC41KSksIGEuZ2VzdHVyZS5pbWFnZS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoXCIgKyBhLnNjYWxlICsgXCIpXCIpKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uR2VzdHVyZUVuZDogZnVuY3Rpb24oZSkgeyB2YXIgYSA9IHguem9vbTsheC5zdXBwb3J0Lmdlc3R1cmVzICYmIChcInRvdWNoZW5kXCIgIT09IGUudHlwZSB8fCBcInRvdWNoZW5kXCIgPT09IGUudHlwZSAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA8IDIpIHx8IGEuZ2VzdHVyZS5pbWFnZSAmJiAwICE9PSBhLmdlc3R1cmUuaW1hZ2UubGVuZ3RoICYmIChhLnNjYWxlID0gTWF0aC5tYXgoTWF0aC5taW4oYS5zY2FsZSwgYS5nZXN0dXJlLnpvb21NYXgpLCB4LnBhcmFtcy56b29tTWluKSwgYS5nZXN0dXJlLmltYWdlLnRyYW5zaXRpb24oeC5wYXJhbXMuc3BlZWQpLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZShcIiArIGEuc2NhbGUgKyBcIilcIiksIGEuY3VycmVudFNjYWxlID0gYS5zY2FsZSwgYS5pc1NjYWxpbmcgPSAhMSwgMSA9PT0gYS5zY2FsZSAmJiAoYS5nZXN0dXJlLnNsaWRlID0gdm9pZCAwKSkgfSxcclxuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydDogZnVuY3Rpb24oZSwgYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS56b29tO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuZ2VzdHVyZS5pbWFnZSAmJiAwICE9PSB0Lmdlc3R1cmUuaW1hZ2UubGVuZ3RoICYmICh0LmltYWdlLmlzVG91Y2hlZCB8fCAoXCJhbmRyb2lkXCIgPT09IGUuZGV2aWNlLm9zICYmIGEucHJldmVudERlZmF1bHQoKSwgdC5pbWFnZS5pc1RvdWNoZWQgPSAhMCwgdC5pbWFnZS50b3VjaGVzU3RhcnQueCA9IFwidG91Y2hzdGFydFwiID09PSBhLnR5cGUgPyBhLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBhLnBhZ2VYLCB0LmltYWdlLnRvdWNoZXNTdGFydC55ID0gXCJ0b3VjaHN0YXJ0XCIgPT09IGEudHlwZSA/IGEudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGEucGFnZVkpKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uVG91Y2hNb3ZlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4Lnpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuZ2VzdHVyZS5pbWFnZSAmJiAwICE9PSBhLmdlc3R1cmUuaW1hZ2UubGVuZ3RoICYmICh4LmFsbG93Q2xpY2sgPSAhMSwgYS5pbWFnZS5pc1RvdWNoZWQgJiYgYS5nZXN0dXJlLnNsaWRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmltYWdlLmlzTW92ZWQgfHwgKGEuaW1hZ2Uud2lkdGggPSBhLmdlc3R1cmUuaW1hZ2VbMF0ub2Zmc2V0V2lkdGgsIGEuaW1hZ2UuaGVpZ2h0ID0gYS5nZXN0dXJlLmltYWdlWzBdLm9mZnNldEhlaWdodCwgYS5pbWFnZS5zdGFydFggPSB4LmdldFRyYW5zbGF0ZShhLmdlc3R1cmUuaW1hZ2VXcmFwWzBdLCBcInhcIikgfHwgMCwgYS5pbWFnZS5zdGFydFkgPSB4LmdldFRyYW5zbGF0ZShhLmdlc3R1cmUuaW1hZ2VXcmFwWzBdLCBcInlcIikgfHwgMCwgYS5nZXN0dXJlLnNsaWRlV2lkdGggPSBhLmdlc3R1cmUuc2xpZGVbMF0ub2Zmc2V0V2lkdGgsIGEuZ2VzdHVyZS5zbGlkZUhlaWdodCA9IGEuZ2VzdHVyZS5zbGlkZVswXS5vZmZzZXRIZWlnaHQsIGEuZ2VzdHVyZS5pbWFnZVdyYXAudHJhbnNpdGlvbigwKSwgeC5ydGwgJiYgKGEuaW1hZ2Uuc3RhcnRYID0gLWEuaW1hZ2Uuc3RhcnRYKSwgeC5ydGwgJiYgKGEuaW1hZ2Uuc3RhcnRZID0gLWEuaW1hZ2Uuc3RhcnRZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYS5pbWFnZS53aWR0aCAqIGEuc2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gYS5pbWFnZS5oZWlnaHQgKiBhLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0IDwgYS5nZXN0dXJlLnNsaWRlV2lkdGggJiYgcyA8IGEuZ2VzdHVyZS5zbGlkZUhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmltYWdlLm1pblggPSBNYXRoLm1pbihhLmdlc3R1cmUuc2xpZGVXaWR0aCAvIDIgLSB0IC8gMiwgMCksIGEuaW1hZ2UubWF4WCA9IC1hLmltYWdlLm1pblgsIGEuaW1hZ2UubWluWSA9IE1hdGgubWluKGEuZ2VzdHVyZS5zbGlkZUhlaWdodCAvIDIgLSBzIC8gMiwgMCksIGEuaW1hZ2UubWF4WSA9IC1hLmltYWdlLm1pblksIGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA9IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVgsIGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA9IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVksICFhLmltYWdlLmlzTW92ZWQgJiYgIWEuaXNTY2FsaW5nKSB7IGlmICh4LmlzSG9yaXpvbnRhbCgpICYmIE1hdGguZmxvb3IoYS5pbWFnZS5taW5YKSA9PT0gTWF0aC5mbG9vcihhLmltYWdlLnN0YXJ0WCkgJiYgYS5pbWFnZS50b3VjaGVzQ3VycmVudC54IDwgYS5pbWFnZS50b3VjaGVzU3RhcnQueCB8fCBNYXRoLmZsb29yKGEuaW1hZ2UubWF4WCkgPT09IE1hdGguZmxvb3IoYS5pbWFnZS5zdGFydFgpICYmIGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA+IGEuaW1hZ2UudG91Y2hlc1N0YXJ0LngpIHJldHVybiB2b2lkKGEuaW1hZ2UuaXNUb3VjaGVkID0gITEpOyBpZiAoIXguaXNIb3Jpem9udGFsKCkgJiYgTWF0aC5mbG9vcihhLmltYWdlLm1pblkpID09PSBNYXRoLmZsb29yKGEuaW1hZ2Uuc3RhcnRZKSAmJiBhLmltYWdlLnRvdWNoZXNDdXJyZW50LnkgPCBhLmltYWdlLnRvdWNoZXNTdGFydC55IHx8IE1hdGguZmxvb3IoYS5pbWFnZS5tYXhZKSA9PT0gTWF0aC5mbG9vcihhLmltYWdlLnN0YXJ0WSkgJiYgYS5pbWFnZS50b3VjaGVzQ3VycmVudC55ID4gYS5pbWFnZS50b3VjaGVzU3RhcnQueSkgcmV0dXJuIHZvaWQoYS5pbWFnZS5pc1RvdWNoZWQgPSAhMSkgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCBhLmltYWdlLmlzTW92ZWQgPSAhMCwgYS5pbWFnZS5jdXJyZW50WCA9IGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIGEuaW1hZ2UudG91Y2hlc1N0YXJ0LnggKyBhLmltYWdlLnN0YXJ0WCwgYS5pbWFnZS5jdXJyZW50WSA9IGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueSAtIGEuaW1hZ2UudG91Y2hlc1N0YXJ0LnkgKyBhLmltYWdlLnN0YXJ0WSwgYS5pbWFnZS5jdXJyZW50WCA8IGEuaW1hZ2UubWluWCAmJiAoYS5pbWFnZS5jdXJyZW50WCA9IGEuaW1hZ2UubWluWCArIDEgLSBNYXRoLnBvdyhhLmltYWdlLm1pblggLSBhLmltYWdlLmN1cnJlbnRYICsgMSwgLjgpKSwgYS5pbWFnZS5jdXJyZW50WCA+IGEuaW1hZ2UubWF4WCAmJiAoYS5pbWFnZS5jdXJyZW50WCA9IGEuaW1hZ2UubWF4WCAtIDEgKyBNYXRoLnBvdyhhLmltYWdlLmN1cnJlbnRYIC0gYS5pbWFnZS5tYXhYICsgMSwgLjgpKSwgYS5pbWFnZS5jdXJyZW50WSA8IGEuaW1hZ2UubWluWSAmJiAoYS5pbWFnZS5jdXJyZW50WSA9IGEuaW1hZ2UubWluWSArIDEgLSBNYXRoLnBvdyhhLmltYWdlLm1pblkgLSBhLmltYWdlLmN1cnJlbnRZICsgMSwgLjgpKSwgYS5pbWFnZS5jdXJyZW50WSA+IGEuaW1hZ2UubWF4WSAmJiAoYS5pbWFnZS5jdXJyZW50WSA9IGEuaW1hZ2UubWF4WSAtIDEgKyBNYXRoLnBvdyhhLmltYWdlLmN1cnJlbnRZIC0gYS5pbWFnZS5tYXhZICsgMSwgLjgpKSwgYS52ZWxvY2l0eS5wcmV2UG9zaXRpb25YIHx8IChhLnZlbG9jaXR5LnByZXZQb3NpdGlvblggPSBhLmltYWdlLnRvdWNoZXNDdXJyZW50LngpLCBhLnZlbG9jaXR5LnByZXZQb3NpdGlvblkgfHwgKGEudmVsb2NpdHkucHJldlBvc2l0aW9uWSA9IGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueSksIGEudmVsb2NpdHkucHJldlRpbWUgfHwgKGEudmVsb2NpdHkucHJldlRpbWUgPSBEYXRlLm5vdygpKSwgYS52ZWxvY2l0eS54ID0gKGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIGEudmVsb2NpdHkucHJldlBvc2l0aW9uWCkgLyAoRGF0ZS5ub3coKSAtIGEudmVsb2NpdHkucHJldlRpbWUpIC8gMiwgYS52ZWxvY2l0eS55ID0gKGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueSAtIGEudmVsb2NpdHkucHJldlBvc2l0aW9uWSkgLyAoRGF0ZS5ub3coKSAtIGEudmVsb2NpdHkucHJldlRpbWUpIC8gMiwgTWF0aC5hYnMoYS5pbWFnZS50b3VjaGVzQ3VycmVudC54IC0gYS52ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSA8IDIgJiYgKGEudmVsb2NpdHkueCA9IDApLCBNYXRoLmFicyhhLmltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSBhLnZlbG9jaXR5LnByZXZQb3NpdGlvblkpIDwgMiAmJiAoYS52ZWxvY2l0eS55ID0gMCksIGEudmVsb2NpdHkucHJldlBvc2l0aW9uWCA9IGEuaW1hZ2UudG91Y2hlc0N1cnJlbnQueCwgYS52ZWxvY2l0eS5wcmV2UG9zaXRpb25ZID0gYS5pbWFnZS50b3VjaGVzQ3VycmVudC55LCBhLnZlbG9jaXR5LnByZXZUaW1lID0gRGF0ZS5ub3coKSwgYS5nZXN0dXJlLmltYWdlV3JhcC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIGEuaW1hZ2UuY3VycmVudFggKyBcInB4LCBcIiArIGEuaW1hZ2UuY3VycmVudFkgKyBcInB4LDApXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25Ub3VjaEVuZDogZnVuY3Rpb24oZSwgYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS56b29tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0Lmdlc3R1cmUuaW1hZ2UgJiYgMCAhPT0gdC5nZXN0dXJlLmltYWdlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQuaW1hZ2UuaXNUb3VjaGVkIHx8ICF0LmltYWdlLmlzTW92ZWQpIHJldHVybiB0LmltYWdlLmlzVG91Y2hlZCA9ICExLCB2b2lkKHQuaW1hZ2UuaXNNb3ZlZCA9ICExKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5pbWFnZS5pc1RvdWNoZWQgPSAhMSwgdC5pbWFnZS5pc01vdmVkID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gMzAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IDMwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0LnZlbG9jaXR5LnggKiBzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHQuaW1hZ2UuY3VycmVudFggKyBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHQudmVsb2NpdHkueSAqIHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdC5pbWFnZS5jdXJyZW50WSArIG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgIT09IHQudmVsb2NpdHkueCAmJiAocyA9IE1hdGguYWJzKChuIC0gdC5pbWFnZS5jdXJyZW50WCkgLyB0LnZlbG9jaXR5LngpKSwgMCAhPT0gdC52ZWxvY2l0eS55ICYmIChyID0gTWF0aC5hYnMoKGwgLSB0LmltYWdlLmN1cnJlbnRZKSAvIHQudmVsb2NpdHkueSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE1hdGgubWF4KHMsIHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmltYWdlLmN1cnJlbnRYID0gbiwgdC5pbWFnZS5jdXJyZW50WSA9IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gdC5pbWFnZS53aWR0aCAqIHQuc2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gdC5pbWFnZS5oZWlnaHQgKiB0LnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmltYWdlLm1pblggPSBNYXRoLm1pbih0Lmdlc3R1cmUuc2xpZGVXaWR0aCAvIDIgLSBkIC8gMiwgMCksIHQuaW1hZ2UubWF4WCA9IC10LmltYWdlLm1pblgsIHQuaW1hZ2UubWluWSA9IE1hdGgubWluKHQuZ2VzdHVyZS5zbGlkZUhlaWdodCAvIDIgLSBtIC8gMiwgMCksIHQuaW1hZ2UubWF4WSA9IC10LmltYWdlLm1pblksIHQuaW1hZ2UuY3VycmVudFggPSBNYXRoLm1heChNYXRoLm1pbih0LmltYWdlLmN1cnJlbnRYLCB0LmltYWdlLm1heFgpLCB0LmltYWdlLm1pblgpLCB0LmltYWdlLmN1cnJlbnRZID0gTWF0aC5tYXgoTWF0aC5taW4odC5pbWFnZS5jdXJyZW50WSwgdC5pbWFnZS5tYXhZKSwgdC5pbWFnZS5taW5ZKSwgdC5nZXN0dXJlLmltYWdlV3JhcC50cmFuc2l0aW9uKHApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiICsgdC5pbWFnZS5jdXJyZW50WCArIFwicHgsIFwiICsgdC5pbWFnZS5jdXJyZW50WSArIFwicHgsMClcIilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlLnpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgYS5nZXN0dXJlLnNsaWRlICYmIGUucHJldmlvdXNJbmRleCAhPT0gZS5hY3RpdmVJbmRleCAmJiAoYS5nZXN0dXJlLmltYWdlLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKVwiKSwgYS5nZXN0dXJlLmltYWdlV3JhcC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMClcIiksIGEuZ2VzdHVyZS5zbGlkZSA9IGEuZ2VzdHVyZS5pbWFnZSA9IGEuZ2VzdHVyZS5pbWFnZVdyYXAgPSB2b2lkIDAsIGEuc2NhbGUgPSBhLmN1cnJlbnRTY2FsZSA9IDEpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlWm9vbTogZnVuY3Rpb24oYSwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gYS56b29tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmdlc3R1cmUuc2xpZGUgfHwgKHMuZ2VzdHVyZS5zbGlkZSA9IGEuY2xpY2tlZFNsaWRlID8gZShhLmNsaWNrZWRTbGlkZSkgOiBhLnNsaWRlcy5lcShhLmFjdGl2ZUluZGV4KSwgcy5nZXN0dXJlLmltYWdlID0gcy5nZXN0dXJlLnNsaWRlLmZpbmQoXCJpbWcsIHN2ZywgY2FudmFzXCIpLCBzLmdlc3R1cmUuaW1hZ2VXcmFwID0gcy5nZXN0dXJlLmltYWdlLnBhcmVudChcIi5cIiArIGEucGFyYW1zLnpvb21Db250YWluZXJDbGFzcykpLCBzLmdlc3R1cmUuaW1hZ2UgJiYgMCAhPT0gcy5nZXN0dXJlLmltYWdlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciwgaSwgbiwgbywgbCwgcCwgZCwgbSwgdSwgYywgZywgaCwgdiwgZiwgdywgeSwgeCwgVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBzLmltYWdlLnRvdWNoZXNTdGFydC54ICYmIHQgPyAociA9IFwidG91Y2hlbmRcIiA9PT0gdC50eXBlID8gdC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCA6IHQucGFnZVgsIGkgPSBcInRvdWNoZW5kXCIgPT09IHQudHlwZSA/IHQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgOiB0LnBhZ2VZKSA6IChyID0gcy5pbWFnZS50b3VjaGVzU3RhcnQueCwgaSA9IHMuaW1hZ2UudG91Y2hlc1N0YXJ0LnkpLCBzLnNjYWxlICYmIDEgIT09IHMuc2NhbGUgPyAocy5zY2FsZSA9IHMuY3VycmVudFNjYWxlID0gMSwgcy5nZXN0dXJlLmltYWdlV3JhcC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApXCIpLCBzLmdlc3R1cmUuaW1hZ2UudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKVwiKSwgcy5nZXN0dXJlLnNsaWRlID0gdm9pZCAwKSA6IChzLnNjYWxlID0gcy5jdXJyZW50U2NhbGUgPSBzLmdlc3R1cmUuaW1hZ2VXcmFwLmF0dHIoXCJkYXRhLXN3aXBlci16b29tXCIpIHx8IGEucGFyYW1zLnpvb21NYXgsIHQgPyAoeCA9IHMuZ2VzdHVyZS5zbGlkZVswXS5vZmZzZXRXaWR0aCwgVCA9IHMuZ2VzdHVyZS5zbGlkZVswXS5vZmZzZXRIZWlnaHQsIG4gPSBzLmdlc3R1cmUuc2xpZGUub2Zmc2V0KCkubGVmdCwgbyA9IHMuZ2VzdHVyZS5zbGlkZS5vZmZzZXQoKS50b3AsIGwgPSBuICsgeCAvIDIgLSByLCBwID0gbyArIFQgLyAyIC0gaSwgdSA9IHMuZ2VzdHVyZS5pbWFnZVswXS5vZmZzZXRXaWR0aCwgYyA9IHMuZ2VzdHVyZS5pbWFnZVswXS5vZmZzZXRIZWlnaHQsIGcgPSB1ICogcy5zY2FsZSwgaCA9IGMgKiBzLnNjYWxlLCB2ID0gTWF0aC5taW4oeCAvIDIgLSBnIC8gMiwgMCksIGYgPSBNYXRoLm1pbihUIC8gMiAtIGggLyAyLCAwKSwgdyA9IC12LCB5ID0gLWYsIGQgPSBsICogcy5zY2FsZSwgbSA9IHAgKiBzLnNjYWxlLCBkIDwgdiAmJiAoZCA9IHYpLCBkID4gdyAmJiAoZCA9IHcpLCBtIDwgZiAmJiAobSA9IGYpLCBtID4geSAmJiAobSA9IHkpKSA6IChkID0gMCwgbSA9IDApLCBzLmdlc3R1cmUuaW1hZ2VXcmFwLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIiArIGQgKyBcInB4LCBcIiArIG0gKyBcInB4LDApXCIpLCBzLmdlc3R1cmUuaW1hZ2UudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZShcIiArIHMuc2NhbGUgKyBcIilcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50czogZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYSA/IFwib2ZmXCIgOiBcIm9uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgucGFyYW1zLnpvb20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAoeC5zbGlkZXMsICEoXCJ0b3VjaHN0YXJ0XCIgIT09IHgudG91Y2hFdmVudHMuc3RhcnQgfHwgIXguc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgfHwgIXgucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHsgcGFzc2l2ZTogITAsIGNhcHR1cmU6ICExIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LnN1cHBvcnQuZ2VzdHVyZXMgPyAoeC5zbGlkZXNbdF0oXCJnZXN0dXJlc3RhcnRcIiwgeC56b29tLm9uR2VzdHVyZVN0YXJ0LCBzKSwgeC5zbGlkZXNbdF0oXCJnZXN0dXJlY2hhbmdlXCIsIHguem9vbS5vbkdlc3R1cmVDaGFuZ2UsIHMpLCB4LnNsaWRlc1t0XShcImdlc3R1cmVlbmRcIiwgeC56b29tLm9uR2VzdHVyZUVuZCwgcykpIDogXCJ0b3VjaHN0YXJ0XCIgPT09IHgudG91Y2hFdmVudHMuc3RhcnQgJiYgKHguc2xpZGVzW3RdKHgudG91Y2hFdmVudHMuc3RhcnQsIHguem9vbS5vbkdlc3R1cmVTdGFydCwgcyksIHguc2xpZGVzW3RdKHgudG91Y2hFdmVudHMubW92ZSwgeC56b29tLm9uR2VzdHVyZUNoYW5nZSwgcyksIHguc2xpZGVzW3RdKHgudG91Y2hFdmVudHMuZW5kLCB4Lnpvb20ub25HZXN0dXJlRW5kLCBzKSksIHhbdF0oXCJ0b3VjaFN0YXJ0XCIsIHguem9vbS5vblRvdWNoU3RhcnQpLCB4LnNsaWRlcy5lYWNoKGZ1bmN0aW9uKGEsIHMpIHsgZShzKS5maW5kKFwiLlwiICsgeC5wYXJhbXMuem9vbUNvbnRhaW5lckNsYXNzKS5sZW5ndGggPiAwICYmIGUocylbdF0oeC50b3VjaEV2ZW50cy5tb3ZlLCB4Lnpvb20ub25Ub3VjaE1vdmUpIH0pLCB4W3RdKFwidG91Y2hFbmRcIiwgeC56b29tLm9uVG91Y2hFbmQpLCB4W3RdKFwidHJhbnNpdGlvbkVuZFwiLCB4Lnpvb20ub25UcmFuc2l0aW9uRW5kKSwgeC5wYXJhbXMuem9vbVRvZ2dsZSAmJiB4Lm9uKFwiZG91YmxlVGFwXCIsIHguem9vbS50b2dnbGVab29tKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHsgeC56b29tLmF0dGFjaEV2ZW50cygpIH0sXHJcbiAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHsgeC56b29tLmF0dGFjaEV2ZW50cyghMCkgfVxyXG4gICAgICAgICAgICB9LCB4Ll9wbHVnaW5zID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIFkgaW4geC5wbHVnaW5zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgQSA9IHgucGx1Z2luc1tZXSh4LCB4LnBhcmFtc1tZXSk7XHJcbiAgICAgICAgICAgICAgICBBICYmIHguX3BsdWdpbnMucHVzaChBKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB4LmNhbGxQbHVnaW5zID0gZnVuY3Rpb24oZSkgeyBmb3IgKHZhciBhID0gMDsgYSA8IHguX3BsdWdpbnMubGVuZ3RoOyBhKyspIGUgaW4geC5fcGx1Z2luc1thXSAmJiB4Ll9wbHVnaW5zW2FdW2VdKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKSB9LCB4LmVtaXR0ZXJFdmVudExpc3RlbmVycyA9IHt9LCB4LmVtaXQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmFtc1tlXSAmJiB4LnBhcmFtc1tlXShhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0sIGFyZ3VtZW50c1s1XSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgICAgIGlmICh4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXSlcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgeC5lbWl0dGVyRXZlbnRMaXN0ZW5lcnNbZV0ubGVuZ3RoOyBhKyspIHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdW2FdKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKTtcclxuICAgICAgICAgICAgICAgIHguY2FsbFBsdWdpbnMgJiYgeC5jYWxsUGx1Z2lucyhlLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0sIGFyZ3VtZW50c1s1XSlcclxuICAgICAgICAgICAgfSwgeC5vbiA9IGZ1bmN0aW9uKGUsIGEpIHsgcmV0dXJuIGUgPSB1KGUpLCB4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXSB8fCAoeC5lbWl0dGVyRXZlbnRMaXN0ZW5lcnNbZV0gPSBbXSksIHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdLnB1c2goYSksIHggfSwgeC5vZmYgPSBmdW5jdGlvbihlLCBhKSB7IHZhciB0OyBpZiAoZSA9IHUoZSksIHZvaWQgMCA9PT0gYSkgcmV0dXJuIHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdID0gW10sIHg7IGlmICh4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXSAmJiAwICE9PSB4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXS5sZW5ndGgpIHsgZm9yICh0ID0gMDsgdCA8IHguZW1pdHRlckV2ZW50TGlzdGVuZXJzW2VdLmxlbmd0aDsgdCsrKSB4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXVt0XSA9PT0gYSAmJiB4LmVtaXR0ZXJFdmVudExpc3RlbmVyc1tlXS5zcGxpY2UodCwgMSk7IHJldHVybiB4IH0gfSwgeC5vbmNlID0gZnVuY3Rpb24oZSwgYSkgeyBlID0gdShlKTsgdmFyIHQgPSBmdW5jdGlvbigpIHsgYShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSksIHgub2ZmKGUsIHQpIH07IHJldHVybiB4Lm9uKGUsIHQpLCB4IH0sIHguYTExeSA9IHtcclxuICAgICAgICAgICAgICAgIG1ha2VGb2N1c2FibGU6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuYXR0cihcInRhYkluZGV4XCIsIFwiMFwiKSwgZSB9LFxyXG4gICAgICAgICAgICAgICAgYWRkUm9sZTogZnVuY3Rpb24oZSwgYSkgeyByZXR1cm4gZS5hdHRyKFwicm9sZVwiLCBhKSwgZSB9LFxyXG4gICAgICAgICAgICAgICAgYWRkTGFiZWw6IGZ1bmN0aW9uKGUsIGEpIHsgcmV0dXJuIGUuYXR0cihcImFyaWEtbGFiZWxcIiwgYSksIGUgfSxcclxuICAgICAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITApLCBlIH0sXHJcbiAgICAgICAgICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITEpLCBlIH0sXHJcbiAgICAgICAgICAgICAgICBvbkVudGVyS2V5OiBmdW5jdGlvbihhKSB7IDEzID09PSBhLmtleUNvZGUgJiYgKGUoYS50YXJnZXQpLmlzKHgucGFyYW1zLm5leHRCdXR0b24pID8gKHgub25DbGlja05leHQoYSksIHguaXNFbmQgPyB4LmExMXkubm90aWZ5KHgucGFyYW1zLmxhc3RTbGlkZU1lc3NhZ2UpIDogeC5hMTF5Lm5vdGlmeSh4LnBhcmFtcy5uZXh0U2xpZGVNZXNzYWdlKSkgOiBlKGEudGFyZ2V0KS5pcyh4LnBhcmFtcy5wcmV2QnV0dG9uKSAmJiAoeC5vbkNsaWNrUHJldihhKSwgeC5pc0JlZ2lubmluZyA/IHguYTExeS5ub3RpZnkoeC5wYXJhbXMuZmlyc3RTbGlkZU1lc3NhZ2UpIDogeC5hMTF5Lm5vdGlmeSh4LnBhcmFtcy5wcmV2U2xpZGVNZXNzYWdlKSksIGUoYS50YXJnZXQpLmlzKFwiLlwiICsgeC5wYXJhbXMuYnVsbGV0Q2xhc3MpICYmIGUoYS50YXJnZXQpWzBdLmNsaWNrKCkpIH0sXHJcbiAgICAgICAgICAgICAgICBsaXZlUmVnaW9uOiBlKCc8c3BhbiBjbGFzcz1cIicgKyB4LnBhcmFtcy5ub3RpZmljYXRpb25DbGFzcyArICdcIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIiBhcmlhLWF0b21pYz1cInRydWVcIj48L3NwYW4+JyksXHJcbiAgICAgICAgICAgICAgICBub3RpZnk6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHguYTExeS5saXZlUmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIDAgIT09IGEubGVuZ3RoICYmIChhLmh0bWwoXCJcIiksIGEuaHRtbChlKSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHsgeC5wYXJhbXMubmV4dEJ1dHRvbiAmJiB4Lm5leHRCdXR0b24gJiYgeC5uZXh0QnV0dG9uLmxlbmd0aCA+IDAgJiYgKHguYTExeS5tYWtlRm9jdXNhYmxlKHgubmV4dEJ1dHRvbiksIHguYTExeS5hZGRSb2xlKHgubmV4dEJ1dHRvbiwgXCJidXR0b25cIiksIHguYTExeS5hZGRMYWJlbCh4Lm5leHRCdXR0b24sIHgucGFyYW1zLm5leHRTbGlkZU1lc3NhZ2UpKSwgeC5wYXJhbXMucHJldkJ1dHRvbiAmJiB4LnByZXZCdXR0b24gJiYgeC5wcmV2QnV0dG9uLmxlbmd0aCA+IDAgJiYgKHguYTExeS5tYWtlRm9jdXNhYmxlKHgucHJldkJ1dHRvbiksIHguYTExeS5hZGRSb2xlKHgucHJldkJ1dHRvbiwgXCJidXR0b25cIiksIHguYTExeS5hZGRMYWJlbCh4LnByZXZCdXR0b24sIHgucGFyYW1zLnByZXZTbGlkZU1lc3NhZ2UpKSwgZSh4LmNvbnRhaW5lcikuYXBwZW5kKHguYTExeS5saXZlUmVnaW9uKSB9LFxyXG4gICAgICAgICAgICAgICAgaW5pdFBhZ2luYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyYW1zLnBhZ2luYXRpb24gJiYgeC5wYXJhbXMucGFnaW5hdGlvbkNsaWNrYWJsZSAmJiB4LmJ1bGxldHMgJiYgeC5idWxsZXRzLmxlbmd0aCAmJiB4LmJ1bGxldHMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LmExMXkubWFrZUZvY3VzYWJsZShhKSwgeC5hMTF5LmFkZFJvbGUoYSwgXCJidXR0b25cIiksIHguYTExeS5hZGRMYWJlbChhLCB4LnBhcmFtcy5wYWdpbmF0aW9uQnVsbGV0TWVzc2FnZS5yZXBsYWNlKC97e2luZGV4fX0vLCBhLmluZGV4KCkgKyAxKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkgeyB4LmExMXkubGl2ZVJlZ2lvbiAmJiB4LmExMXkubGl2ZVJlZ2lvbi5sZW5ndGggPiAwICYmIHguYTExeS5saXZlUmVnaW9uLnJlbW92ZSgpIH1cclxuICAgICAgICAgICAgfSwgeC5pbml0ID0gZnVuY3Rpb24oKSB7IHgucGFyYW1zLmxvb3AgJiYgeC5jcmVhdGVMb29wKCksIHgudXBkYXRlQ29udGFpbmVyU2l6ZSgpLCB4LnVwZGF0ZVNsaWRlc1NpemUoKSwgeC51cGRhdGVQYWdpbmF0aW9uKCksIHgucGFyYW1zLnNjcm9sbGJhciAmJiB4LnNjcm9sbGJhciAmJiAoeC5zY3JvbGxiYXIuc2V0KCksIHgucGFyYW1zLnNjcm9sbGJhckRyYWdnYWJsZSAmJiB4LnNjcm9sbGJhci5lbmFibGVEcmFnZ2FibGUoKSksIFwic2xpZGVcIiAhPT0geC5wYXJhbXMuZWZmZWN0ICYmIHguZWZmZWN0c1t4LnBhcmFtcy5lZmZlY3RdICYmICh4LnBhcmFtcy5sb29wIHx8IHgudXBkYXRlUHJvZ3Jlc3MoKSwgeC5lZmZlY3RzW3gucGFyYW1zLmVmZmVjdF0uc2V0VHJhbnNsYXRlKCkpLCB4LnBhcmFtcy5sb29wID8geC5zbGlkZVRvKHgucGFyYW1zLmluaXRpYWxTbGlkZSArIHgubG9vcGVkU2xpZGVzLCAwLCB4LnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpIDogKHguc2xpZGVUbyh4LnBhcmFtcy5pbml0aWFsU2xpZGUsIDAsIHgucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCksIDAgPT09IHgucGFyYW1zLmluaXRpYWxTbGlkZSAmJiAoeC5wYXJhbGxheCAmJiB4LnBhcmFtcy5wYXJhbGxheCAmJiB4LnBhcmFsbGF4LnNldFRyYW5zbGF0ZSgpLCB4LmxhenkgJiYgeC5wYXJhbXMubGF6eUxvYWRpbmcgJiYgKHgubGF6eS5sb2FkKCksIHgubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQgPSAhMCkpKSwgeC5hdHRhY2hFdmVudHMoKSwgeC5wYXJhbXMub2JzZXJ2ZXIgJiYgeC5zdXBwb3J0Lm9ic2VydmVyICYmIHguaW5pdE9ic2VydmVycygpLCB4LnBhcmFtcy5wcmVsb2FkSW1hZ2VzICYmICF4LnBhcmFtcy5sYXp5TG9hZGluZyAmJiB4LnByZWxvYWRJbWFnZXMoKSwgeC5wYXJhbXMuem9vbSAmJiB4Lnpvb20gJiYgeC56b29tLmluaXQoKSwgeC5wYXJhbXMuYXV0b3BsYXkgJiYgeC5zdGFydEF1dG9wbGF5KCksIHgucGFyYW1zLmtleWJvYXJkQ29udHJvbCAmJiB4LmVuYWJsZUtleWJvYXJkQ29udHJvbCAmJiB4LmVuYWJsZUtleWJvYXJkQ29udHJvbCgpLCB4LnBhcmFtcy5tb3VzZXdoZWVsQ29udHJvbCAmJiB4LmVuYWJsZU1vdXNld2hlZWxDb250cm9sICYmIHguZW5hYmxlTW91c2V3aGVlbENvbnRyb2woKSwgeC5wYXJhbXMuaGFzaG5hdlJlcGxhY2VTdGF0ZSAmJiAoeC5wYXJhbXMucmVwbGFjZVN0YXRlID0geC5wYXJhbXMuaGFzaG5hdlJlcGxhY2VTdGF0ZSksIHgucGFyYW1zLmhpc3RvcnkgJiYgeC5oaXN0b3J5ICYmIHguaGlzdG9yeS5pbml0KCksIHgucGFyYW1zLmhhc2huYXYgJiYgeC5oYXNobmF2ICYmIHguaGFzaG5hdi5pbml0KCksIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHguYTExeS5pbml0KCksIHguZW1pdChcIm9uSW5pdFwiLCB4KSB9LCB4LmNsZWFudXBTdHlsZXMgPSBmdW5jdGlvbigpIHsgeC5jb250YWluZXIucmVtb3ZlQ2xhc3MoeC5jbGFzc05hbWVzLmpvaW4oXCIgXCIpKS5yZW1vdmVBdHRyKFwic3R5bGVcIiksIHgud3JhcHBlci5yZW1vdmVBdHRyKFwic3R5bGVcIiksIHguc2xpZGVzICYmIHguc2xpZGVzLmxlbmd0aCAmJiB4LnNsaWRlcy5yZW1vdmVDbGFzcyhbeC5wYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MsIHgucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MsIHgucGFyYW1zLnNsaWRlTmV4dENsYXNzLCB4LnBhcmFtcy5zbGlkZVByZXZDbGFzc10uam9pbihcIiBcIikpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKS5yZW1vdmVBdHRyKFwiZGF0YS1zd2lwZXItY29sdW1uXCIpLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1yb3dcIiksIHgucGFnaW5hdGlvbkNvbnRhaW5lciAmJiB4LnBhZ2luYXRpb25Db250YWluZXIubGVuZ3RoICYmIHgucGFnaW5hdGlvbkNvbnRhaW5lci5yZW1vdmVDbGFzcyh4LnBhcmFtcy5wYWdpbmF0aW9uSGlkZGVuQ2xhc3MpLCB4LmJ1bGxldHMgJiYgeC5idWxsZXRzLmxlbmd0aCAmJiB4LmJ1bGxldHMucmVtb3ZlQ2xhc3MoeC5wYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpLCB4LnBhcmFtcy5wcmV2QnV0dG9uICYmIGUoeC5wYXJhbXMucHJldkJ1dHRvbikucmVtb3ZlQ2xhc3MoeC5wYXJhbXMuYnV0dG9uRGlzYWJsZWRDbGFzcyksIHgucGFyYW1zLm5leHRCdXR0b24gJiYgZSh4LnBhcmFtcy5uZXh0QnV0dG9uKS5yZW1vdmVDbGFzcyh4LnBhcmFtcy5idXR0b25EaXNhYmxlZENsYXNzKSwgeC5wYXJhbXMuc2Nyb2xsYmFyICYmIHguc2Nyb2xsYmFyICYmICh4LnNjcm9sbGJhci50cmFjayAmJiB4LnNjcm9sbGJhci50cmFjay5sZW5ndGggJiYgeC5zY3JvbGxiYXIudHJhY2sucmVtb3ZlQXR0cihcInN0eWxlXCIpLCB4LnNjcm9sbGJhci5kcmFnICYmIHguc2Nyb2xsYmFyLmRyYWcubGVuZ3RoICYmIHguc2Nyb2xsYmFyLmRyYWcucmVtb3ZlQXR0cihcInN0eWxlXCIpKSB9LCB4LmRlc3Ryb3kgPSBmdW5jdGlvbihlLCBhKSB7IHguZGV0YWNoRXZlbnRzKCksIHguc3RvcEF1dG9wbGF5KCksIHgucGFyYW1zLnNjcm9sbGJhciAmJiB4LnNjcm9sbGJhciAmJiB4LnBhcmFtcy5zY3JvbGxiYXJEcmFnZ2FibGUgJiYgeC5zY3JvbGxiYXIuZGlzYWJsZURyYWdnYWJsZSgpLCB4LnBhcmFtcy5sb29wICYmIHguZGVzdHJveUxvb3AoKSwgYSAmJiB4LmNsZWFudXBTdHlsZXMoKSwgeC5kaXNjb25uZWN0T2JzZXJ2ZXJzKCksIHgucGFyYW1zLnpvb20gJiYgeC56b29tICYmIHguem9vbS5kZXN0cm95KCksIHgucGFyYW1zLmtleWJvYXJkQ29udHJvbCAmJiB4LmRpc2FibGVLZXlib2FyZENvbnRyb2wgJiYgeC5kaXNhYmxlS2V5Ym9hcmRDb250cm9sKCksIHgucGFyYW1zLm1vdXNld2hlZWxDb250cm9sICYmIHguZGlzYWJsZU1vdXNld2hlZWxDb250cm9sICYmIHguZGlzYWJsZU1vdXNld2hlZWxDb250cm9sKCksIHgucGFyYW1zLmExMXkgJiYgeC5hMTF5ICYmIHguYTExeS5kZXN0cm95KCksIHgucGFyYW1zLmhpc3RvcnkgJiYgIXgucGFyYW1zLnJlcGxhY2VTdGF0ZSAmJiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHguaGlzdG9yeS5zZXRIaXN0b3J5UG9wU3RhdGUpLCB4LnBhcmFtcy5oYXNobmF2ICYmIHguaGFzaG5hdiAmJiB4Lmhhc2huYXYuZGVzdHJveSgpLCB4LmVtaXQoXCJvbkRlc3Ryb3lcIiksIGUgIT09ICExICYmICh4ID0gbnVsbCkgfSwgeC5pbml0KCksIHhcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgYS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgaXNTYWZhcmk6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7IHJldHVybiBlLmluZGV4T2YoXCJzYWZhcmlcIikgPj0gMCAmJiBlLmluZGV4T2YoXCJjaHJvbWVcIikgPCAwICYmIGUuaW5kZXhPZihcImFuZHJvaWRcIikgPCAwIH0oKSxcclxuICAgICAgICBpc1VpV2ViVmlldzogLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSxcclxuICAgICAgICBpc0FycmF5OiBmdW5jdGlvbihlKSB7IHJldHVybiBcIltvYmplY3QgQXJyYXldXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoZSkgfSxcclxuICAgICAgICBicm93c2VyOiB7IGllOiB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCwgaWVUb3VjaDogd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkICYmIHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDEgfHwgd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSwgbHRlSUU5OiBmdW5jdGlvbigpIHsgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyByZXR1cm4gZS5pbm5lckhUTUwgPSBcIjwhLS1baWYgbHRlIElFIDldPjxpPjwvaT48IVtlbmRpZl0tLT5cIiwgMSA9PT0gZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlcIikubGVuZ3RoIH0oKSB9LFxyXG4gICAgICAgIGRldmljZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQsXHJcbiAgICAgICAgICAgICAgICBhID0gZS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/LyksXHJcbiAgICAgICAgICAgICAgICB0ID0gZS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pLFxyXG4gICAgICAgICAgICAgICAgcyA9IGUubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKSxcclxuICAgICAgICAgICAgICAgIHIgPSAhdCAmJiBlLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pO1xyXG4gICAgICAgICAgICByZXR1cm4geyBpb3M6IHQgfHwgciB8fCBzLCBhbmRyb2lkOiBhIH1cclxuICAgICAgICB9KCksXHJcbiAgICAgICAgc3VwcG9ydDoge1xyXG4gICAgICAgICAgICB0b3VjaDogd2luZG93Lk1vZGVybml6ciAmJiBNb2Rlcm5penIudG91Y2ggPT09ICEwIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gISEoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoKSB9KCksXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybXMzZDogd2luZG93Lk1vZGVybml6ciAmJiBNb2Rlcm5penIuY3NzdHJhbnNmb3JtczNkID09PSAhMCB8fCBmdW5jdGlvbigpIHsgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlOyByZXR1cm4gXCJ3ZWJraXRQZXJzcGVjdGl2ZVwiIGluIGUgfHwgXCJNb3pQZXJzcGVjdGl2ZVwiIGluIGUgfHwgXCJPUGVyc3BlY3RpdmVcIiBpbiBlIHx8IFwiTXNQZXJzcGVjdGl2ZVwiIGluIGUgfHwgXCJwZXJzcGVjdGl2ZVwiIGluIGUgfSgpLFxyXG4gICAgICAgICAgICBmbGV4Ym94OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLCBhID0gXCJhbGlnbkl0ZW1zIHdlYmtpdEFsaWduSXRlbXMgd2Via2l0Qm94QWxpZ24gbXNGbGV4QWxpZ24gbW96Qm94QWxpZ24gd2Via2l0RmxleERpcmVjdGlvbiBtc0ZsZXhEaXJlY3Rpb24gbW96Qm94RGlyZWN0aW9uIG1vekJveE9yaWVudCB3ZWJraXRCb3hEaXJlY3Rpb24gd2Via2l0Qm94T3JpZW50XCIuc3BsaXQoXCIgXCIpLCB0ID0gMDsgdCA8IGEubGVuZ3RoOyB0KyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFbdF0gaW4gZSkgcmV0dXJuICEwXHJcbiAgICAgICAgICAgIH0oKSxcclxuICAgICAgICAgICAgb2JzZXJ2ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJNdXRhdGlvbk9ic2VydmVyXCIgaW4gd2luZG93IHx8IFwiV2Via2l0TXV0YXRpb25PYnNlcnZlclwiIGluIHdpbmRvdyB9KCksXHJcbiAgICAgICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9ICExO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgZSA9ICEwIH0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZUxpc3RlbmVyXCIsIG51bGwsIGEpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVcclxuICAgICAgICAgICAgfSgpLFxyXG4gICAgICAgICAgICBnZXN0dXJlczogZnVuY3Rpb24oKSB7IHJldHVybiBcIm9uZ2VzdHVyZXN0YXJ0XCIgaW4gd2luZG93IH0oKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGx1Z2luczoge31cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciB0ID0gW1wialF1ZXJ5XCIsIFwiWmVwdG9cIiwgXCJEb203XCJdLCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspIHdpbmRvd1t0W3NdXSAmJiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgZS5mbi5zd2lwZXIgPSBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgIHZhciBzO1xyXG4gICAgICAgICAgICByZXR1cm4gZSh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBuZXcgYSh0aGlzLCB0KTtcclxuICAgICAgICAgICAgICAgIHMgfHwgKHMgPSBlKVxyXG4gICAgICAgICAgICB9KSwgc1xyXG4gICAgICAgIH1cclxuICAgIH0od2luZG93W3Rbc11dKTtcclxuICAgIHZhciByO1xyXG4gICAgciA9IFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIERvbTcgPyB3aW5kb3cuRG9tNyB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSA6IERvbTcsIHIgJiYgKFwidHJhbnNpdGlvbkVuZFwiIGluIHIuZm4gfHwgKHIuZm4udHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBmdW5jdGlvbiBhKGkpIHtcclxuICAgICAgICAgICAgaWYgKGkudGFyZ2V0ID09PSB0aGlzKVxyXG4gICAgICAgICAgICAgICAgZm9yIChlLmNhbGwodGhpcywgaSksIHQgPSAwOyB0IDwgcy5sZW5ndGg7IHQrKykgci5vZmYoc1t0XSwgYSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHQsIHMgPSBbXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvbmVuZFwiLCBcIm9UcmFuc2l0aW9uRW5kXCIsIFwiTVNUcmFuc2l0aW9uRW5kXCIsIFwibXNUcmFuc2l0aW9uRW5kXCJdLFxyXG4gICAgICAgICAgICByID0gdGhpcztcclxuICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgZm9yICh0ID0gMDsgdCA8IHMubGVuZ3RoOyB0KyspIHIub24oc1t0XSwgYSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0pLCBcInRyYW5zZm9ybVwiIGluIHIuZm4gfHwgKHIuZm4udHJhbnNmb3JtID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRoaXNbYV0uc3R5bGU7XHJcbiAgICAgICAgICAgIHQud2Via2l0VHJhbnNmb3JtID0gdC5Nc1RyYW5zZm9ybSA9IHQubXNUcmFuc2Zvcm0gPSB0Lk1velRyYW5zZm9ybSA9IHQuT1RyYW5zZm9ybSA9IHQudHJhbnNmb3JtID0gZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfSksIFwidHJhbnNpdGlvblwiIGluIHIuZm4gfHwgKHIuZm4udHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChlICs9IFwibXNcIik7XHJcbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gdGhpc1thXS5zdHlsZTtcclxuICAgICAgICAgICAgdC53ZWJraXRUcmFuc2l0aW9uRHVyYXRpb24gPSB0Lk1zVHJhbnNpdGlvbkR1cmF0aW9uID0gdC5tc1RyYW5zaXRpb25EdXJhdGlvbiA9IHQuTW96VHJhbnNpdGlvbkR1cmF0aW9uID0gdC5PVHJhbnNpdGlvbkR1cmF0aW9uID0gdC50cmFuc2l0aW9uRHVyYXRpb24gPSBlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9KSwgXCJvdXRlcldpZHRoXCIgaW4gci5mbiB8fCAoci5mbi5vdXRlcldpZHRoID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5sZW5ndGggPiAwID8gZSA/IHRoaXNbMF0ub2Zmc2V0V2lkdGggKyBwYXJzZUZsb2F0KHRoaXMuY3NzKFwibWFyZ2luLXJpZ2h0XCIpKSArIHBhcnNlRmxvYXQodGhpcy5jc3MoXCJtYXJnaW4tbGVmdFwiKSkgOiB0aGlzWzBdLm9mZnNldFdpZHRoIDogbnVsbCB9KSksIHdpbmRvdy5Td2lwZXIgPSBhXHJcbn0oKSwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuU3dpcGVyIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyBcInVzZSBzdHJpY3RcIjsgcmV0dXJuIHdpbmRvdy5Td2lwZXIgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcHMvc3dpcGVyLmpxdWVyeS5taW4uanMubWFwIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
